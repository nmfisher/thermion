// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:jsgen`.
// ignore_for_file: type=lint
import 'thermion_dart_js_interop.g.dart' as self;
import 'dart:typed_data';
import 'dart:js_interop';
import 'dart:js_interop_unsafe';

///
/// Sub-classes of [NativeType] represent a "native" type (by which we mean a
/// type that can be passed to a WASM-compiled native function), and its
/// equivalent Dart representation.
///
/// Most sub-classes are non-constructible; they are only intended to preserve
/// compile-time type information and to translate between native types and
/// their Dart equivalent.
///
/// The exceptions are [Pointer], [Array] and sub-classes of [Struct]; these can be
/// instantiated and returned to the user.
///
/// Sub-classes doesn't necessarily represent a singular WASM type; for example,
/// WASM does not have a char type but we implement a [Char] type to help
/// preserve "native" type information. Without this, [const char*] would only be
/// represented as Pointer<Int64>, and we would have no way of knowing that
/// it can safely be interpreted/converted to a Dart String.
///
///

extension type Char._(int value) implements NativeType {
  static Pointer<Char> stackAlloc(int count) {
    return _lib._stackAlloc<Char>(4 * count);
  }
}

extension type const NativeType(int addr) {}
extension type const Int32._(int addr) implements NativeType {
  static Pointer<Int32> stackAlloc(int count) {
    return _lib._stackAlloc<Int32>(4 * count);
  }
}
extension type Int64(int addr) implements NativeType {
  static Pointer<Int64> stackAlloc(int count) {
    return _lib._stackAlloc<Int64>(8 * count);
  }
}
extension type Float32._(int addr) implements NativeType {
  static Pointer<Float32> stackAlloc(int count) {
    return _lib._stackAlloc<Float32>(4 * count);
  }
}
extension type Float64._(int addr) implements NativeType {
  static Pointer<Float64> stackAlloc(int count) {
    return _lib._stackAlloc<Float64>(8 * count);
  }
}
extension type NativeFunction<T>._(int addr) implements NativeType {}
extension type Void._(int addr) implements NativeType {}

extension type Pointer<T extends NativeType>(int addr) implements NativeType {
  String get llvmType => '*';
  int size() => 4;

  static Pointer<Pointer<T>> stackAlloc<T extends NativeType>(int count) {
    return _lib._stackAlloc<T>(4 * count) as Pointer<Pointer<T>>;
  }

  Pointer<T> operator +(int numElements) =>
      Pointer<T>(addr + (numElements * size()));
  Pointer<U> cast<U extends NativeType>() => this as Pointer<U>;
}

extension Int32Pointer on Pointer<Int32> {
  String get llvmType => 'i32';

  void setValue(int value) {
    _lib.setValue(this, value.toJS, llvmType);
  }

  int getValue() {
    return _lib.getValue(this, llvmType).toDartInt;
  }
}

extension Int64Pointer on Pointer<Int64> {
  String get llvmType => 'i64';

  void setValue(int value) {
    _lib.setValue(this, value.toJS, llvmType);
  }

  int getValue() {
    return _lib.getValue(this, llvmType).toDartInt;
  }
}

extension Float32Pointer on Pointer<Float32> {
  String get llvmType => 'float';

  void setValue(double value) {
    _lib.setValue(this, value.toJS, llvmType);
  }

  double getValue() {
    return _lib.getValue(this, llvmType).toDartDouble;
  }
}

extension Float64Pointer on Pointer<Float64> {
  String get llvmType => 'double';

  void setValue(double value) {
    _lib.setValue(this, value.toJS, llvmType);
  }

  double getValue() {
    return _lib.getValue(this, llvmType).toDartDouble;
  }
}

extension StringUtils on String {
  self.Pointer<Char> toNativePointer() {
    var len = _lib._lengthBytesUTF8(this) + 1;
    var ptr = _lib._stackAlloc<Char>(len);
    _lib._stringToUTF8(this, ptr, len);
    return ptr;
  }
}

extension CharPtr on Pointer<Char> {
  void setValue(String value) {
    var len = _lib._lengthBytesUTF8(value);
    _lib._stringToUTF8(value, this, len);
  }

  String getValue() {
    return _lib._UTF8ToString(this);
  }
}

extension type Struct(int addr) implements NativeType {}

abstract class DartStruct {}

extension type const Array<T extends NativeType>._(
    ({int numElements, Pointer<T> addr}) _) {
  Array<U> cast<U extends NativeType>() => this as Array<U>;

  Uint8List asUint8List() {
    final start = _.addr;
    final end = _.addr + _.numElements;

    return Uint8List.sublistView(
      _lib.HEAPU8.toDart,
      start.addr,
      end.addr,
    );
  }

  void setValue(Uint8List data) {
    _lib.writeArrayToMemory(data.toJS, _.addr);
  }
}

late _NativeLibrary _lib;

class NativeLibrary {
  static void initBindings(String moduleName) {
    _lib = globalContext.getProperty(moduleName.toJS);
  }
}

extension type _NativeLibrary(JSObject _) implements JSObject {
  @JS('stackAlloc')
  external Pointer<T> _stackAlloc<T extends NativeType>(int numBytes);

  external Pointer<T> _malloc<T extends NativeType>(int numBytes);
  external void _free(Pointer ptr);

  external JSNumber getValue(Pointer addr, String llvmType);
  external void setValue(Pointer addr, JSNumber value, String llvmType);

  @JS("lengthBytesUTF8")
  external int _lengthBytesUTF8(String str);

  @JS("UTF8ToString")
  external String _UTF8ToString(Pointer<Char> ptr);

  @JS("stringToUTF8")
  external void _stringToUTF8(
      String str, Pointer<Char> ptr, int maxBytesToWrite);

  external void writeArrayToMemory(JSUint8Array data, Pointer ptr);

  external Pointer<NativeFunction> addFunction(JSFunction f, String signature);
  external void removeFunction(Pointer<NativeFunction> f);
  external JSUint8Array get HEAPU8;

  external int _Thermion_createGLContext();
  external Pointer<TMaterialInstance> _Material_createInstance(
    Pointer<TMaterial> tMaterial,
  );
  external Pointer<TMaterial> _Material_createImageMaterial(
    Pointer<TEngine> tEngine,
  );
  external Pointer<TMaterial> _Material_createGridMaterial(
    Pointer<TEngine> tEngine,
  );
  external Pointer<TMaterial> _Material_createGizmoMaterial(
    Pointer<TEngine> tEngine,
  );
  external bool _Material_hasParameter(
    Pointer<TMaterial> tMaterial,
    Pointer<Char> propertyName,
  );
  external bool _MaterialInstance_isStencilWriteEnabled(
    Pointer<TMaterialInstance> materialInstance,
  );
  external void _MaterialInstance_setStencilWrite(
    Pointer<TMaterialInstance> materialInstance,
    bool enabled,
  );
  external void _MaterialInstance_setCullingMode(
    Pointer<TMaterialInstance> materialInstance,
    int culling,
  );
  external void _MaterialInstance_setDepthWrite(
    Pointer<TMaterialInstance> materialInstance,
    bool enabled,
  );
  external void _MaterialInstance_setDepthCulling(
    Pointer<TMaterialInstance> materialInstance,
    bool enabled,
  );
  external void _MaterialInstance_setParameterFloat(
    Pointer<TMaterialInstance> materialInstance,
    Pointer<Char> propertyName,
    double value,
  );
  external void _MaterialInstance_setParameterFloat2(
    Pointer<TMaterialInstance> materialInstance,
    Pointer<Char> propertyName,
    double x,
    double y,
  );
  external void _MaterialInstance_setParameterFloat3(
    Pointer<TMaterialInstance> materialInstance,
    Pointer<Char> propertyName,
    double x,
    double y,
    double z,
  );
  external void _MaterialInstance_setParameterFloat3Array(
    Pointer<TMaterialInstance> tMaterialInstance,
    Pointer<Char> propertyName,
    Pointer<Float64> raw,
    int length,
  );
  external void _MaterialInstance_setParameterFloat4(
    Pointer<TMaterialInstance> materialInstance,
    Pointer<Char> propertyName,
    double x,
    double y,
    double w,
    double z,
  );
  external void _MaterialInstance_setParameterMat4(
    Pointer<TMaterialInstance> materialInstance,
    Pointer<Char> propertyName,
    Pointer<Float64> matrix,
  );
  external void _MaterialInstance_setParameterInt(
    Pointer<TMaterialInstance> materialInstance,
    Pointer<Char> propertyName,
    int value,
  );
  external void _MaterialInstance_setParameterBool(
    Pointer<TMaterialInstance> materialInstance,
    Pointer<Char> propertyName,
    bool value,
  );
  external void _MaterialInstance_setParameterTexture(
    Pointer<TMaterialInstance> materialInstance,
    Pointer<Char> propertyName,
    Pointer<TTexture> texture,
    Pointer<TTextureSampler> sampler,
  );
  external void _MaterialInstance_setDepthFunc(
    Pointer<TMaterialInstance> materialInstance,
    int depthFunc,
  );
  external void _MaterialInstance_setStencilOpStencilFail(
    Pointer<TMaterialInstance> materialInstance,
    int op,
    int face,
  );
  external void _MaterialInstance_setStencilOpDepthFail(
    Pointer<TMaterialInstance> materialInstance,
    int op,
    int face,
  );
  external void _MaterialInstance_setStencilOpDepthStencilPass(
    Pointer<TMaterialInstance> materialInstance,
    int op,
    int face,
  );
  external void _MaterialInstance_setStencilCompareFunction(
    Pointer<TMaterialInstance> materialInstance,
    int func,
    int face,
  );
  external void _MaterialInstance_setStencilReferenceValue(
    Pointer<TMaterialInstance> materialInstance,
    int value,
    int face,
  );
  external void _MaterialInstance_setStencilReadMask(
    Pointer<TMaterialInstance> materialInstance,
    int mask,
  );
  external void _MaterialInstance_setStencilWriteMask(
    Pointer<TMaterialInstance> materialInstance,
    int mask,
  );
  external void _MaterialInstance_setTransparencyMode(
    Pointer<TMaterialInstance> materialInstance,
    int transparencyMode,
  );
  external void _LightManager_setPosition(
    Pointer<TLightManager> tLightManager,
    EntityId light,
    double x,
    double y,
    double z,
  );
  external void _LightManager_setDirection(
    Pointer<TLightManager> tLightManager,
    EntityId light,
    double x,
    double y,
    double z,
  );
  external int _LightManager_createLight(
    Pointer<TEngine> tEngine,
    Pointer<TLightManager> tLightManager,
    int tLightTtype,
  );
  external void _LightManager_destroyLight(
    Pointer<TLightManager> tLightManager,
    EntityId entity,
  );
  external void _LightManager_setColor(
    Pointer<TLightManager> tLightManager,
    EntityId entity,
    double colorTemperature,
  );
  external void _LightManager_setIntensity(
    Pointer<TLightManager> tLightManager,
    EntityId entity,
    double intensity,
  );
  external void _LightManager_setFalloff(
    Pointer<TLightManager> tLightManager,
    EntityId entity,
    double falloff,
  );
  external void _LightManager_setSpotLightCone(
    Pointer<TLightManager> tLightManager,
    EntityId entity,
    double inner,
    double outer,
  );
  external void _LightManager_setShadowCaster(
    Pointer<TLightManager> tLightManager,
    EntityId entity,
    bool enabled,
  );
  external int _FilamentAsset_getEntityCount(
    Pointer<TFilamentAsset> filamentAsset,
  );
  external void _FilamentAsset_getEntities(
    Pointer<TFilamentAsset> filamentAsset,
    Pointer<Int32> out,
  );
  external Pointer<TGltfAssetLoader> _GltfAssetLoader_create(
    Pointer<TEngine> tEngine,
    Pointer<TMaterialProvider> tMaterialProvider,
  );
  external Pointer<TMaterialInstance> _GltfAssetLoader_getMaterialInstance(
    Pointer<TRenderableManager> tRenderableManager,
    Pointer<TFilamentAsset> tAsset,
  );
  external Pointer<TMaterialProvider> _GltfAssetLoader_getMaterialProvider(
    Pointer<TGltfAssetLoader> tAssetLoader,
  );
  external int _FilamentAsset_getResourceUriCount(
    Pointer<TFilamentAsset> tFilamentAsset,
  );
  external Pointer<self.Pointer<Char>> _FilamentAsset_getResourceUris(
    Pointer<TFilamentAsset> tFilamentAsset,
  );
  external void _View_getViewport(
    Pointer<TViewport> TViewport_out,
    Pointer<TView> view,
  );
  external Pointer<TColorGrading> _ColorGrading_create(
    Pointer<TEngine> tEngine,
    int toneMapping,
  );
  external void _View_setColorGrading(
    Pointer<TView> tView,
    Pointer<TColorGrading> tColorGrading,
  );
  external void _View_setBlendMode(
    Pointer<TView> view,
    int blendMode,
  );
  external void _View_setViewport(
    Pointer<TView> view,
    int width,
    int height,
  );
  external void _View_setRenderTarget(
    Pointer<TView> view,
    Pointer<TRenderTarget> renderTarget,
  );
  external void _View_setFrustumCullingEnabled(
    Pointer<TView> view,
    bool enabled,
  );
  external Pointer<TRenderTarget> _View_getRenderTarget(
    Pointer<TView> tView,
  );
  external void _View_setPostProcessing(
    Pointer<TView> tView,
    bool enabled,
  );
  external void _View_setShadowsEnabled(
    Pointer<TView> tView,
    bool enabled,
  );
  external void _View_setShadowType(
    Pointer<TView> tView,
    int shadowType,
  );
  external void _View_setSoftShadowOptions(
    Pointer<TView> tView,
    double penumbraScale,
    double penumbraRatioScale,
  );
  external void _View_setBloom(
    Pointer<TView> tView,
    bool enabled,
    double strength,
  );
  external void _View_setRenderQuality(
    Pointer<TView> tView,
    int qualityLevel,
  );
  external void _View_setAntiAliasing(
    Pointer<TView> tView,
    bool msaa,
    bool fxaa,
    bool taa,
  );
  external void _View_setLayerEnabled(
    Pointer<TView> tView,
    int layer,
    bool visible,
  );
  external void _View_setCamera(
    Pointer<TView> tView,
    Pointer<TCamera> tCamera,
  );
  external Pointer<TScene> _View_getScene(
    Pointer<TView> tView,
  );
  external Pointer<TCamera> _View_getCamera(
    Pointer<TView> tView,
  );
  external void _View_setStencilBufferEnabled(
    Pointer<TView> tView,
    bool enabled,
  );
  external bool _View_isStencilBufferEnabled(
    Pointer<TView> tView,
  );
  external void _View_setDitheringEnabled(
    Pointer<TView> tView,
    bool enabled,
  );
  external bool _View_isDitheringEnabled(
    Pointer<TView> tView,
  );
  external void _View_setScene(
    Pointer<TView> tView,
    Pointer<TScene> tScene,
  );
  external void _View_setFrontFaceWindingInverted(
    Pointer<TView> tView,
    bool inverted,
  );
  external void _View_pick(
    Pointer<TView> tView,
    int requestId,
    int x,
    int y,
    PickCallback callback,
  );
  external Pointer<TNameComponentManager> _NameComponentManager_create();
  external Pointer<Char> _NameComponentManager_getName(
    Pointer<TNameComponentManager> tNameComponentManager,
    EntityId entity,
  );
  external void _IndirectLight_setRotation(
    Pointer<TIndirectLight> tIndirectLight,
    Pointer<Float64> rotation,
  );
  external Pointer<TTexture> _Texture_build(
    Pointer<TEngine> engine,
    int width,
    int height,
    int depth,
    int levels,
    int tUsage,
    int import1,
    int sampler,
    int format,
  );
  external bool _Texture_loadImage(
    Pointer<TEngine> tEngine,
    Pointer<TTexture> tTexture,
    Pointer<TLinearImage> tImage,
    int bufferFormat,
    int pixelDataType,
  );
  external int _Texture_getWidth(
    Pointer<TTexture> tTexture,
    int level,
  );
  external int _Texture_getHeight(
    Pointer<TTexture> tTexture,
    int level,
  );
  external int _Texture_getDepth(
    Pointer<TTexture> tTexture,
    int level,
  );
  external int _Texture_getUsage(
    Pointer<TTexture> tTexture,
    int level,
  );
  external Pointer<TLinearImage> _Image_createEmpty(
    int width,
    int height,
    int channel,
  );
  external Pointer<Float32> _Image_getBytes(
    Pointer<TLinearImage> tLinearImage,
  );
  external void _Image_destroy(
    Pointer<TLinearImage> tLinearImage,
  );
  external int _Image_getWidth(
    Pointer<TLinearImage> tLinearImage,
  );
  external int _Image_getHeight(
    Pointer<TLinearImage> tLinearImage,
  );
  external int _Image_getChannels(
    Pointer<TLinearImage> tLinearImage,
  );
  external Pointer<TTexture> _RenderTarget_getColorTexture(
    Pointer<TRenderTarget> tRenderTarget,
  );
  external Pointer<TTexture> _RenderTarget_getDepthTexture(
    Pointer<TRenderTarget> tRenderTarget,
  );
  external Pointer<TTextureSampler> _TextureSampler_create();
  external Pointer<TTextureSampler> _TextureSampler_createWithFiltering(
    int minFilter,
    int magFilter,
    int wrapS,
    int wrapT,
    int wrapR,
  );
  external Pointer<TTextureSampler> _TextureSampler_createWithComparison(
    int compareMode,
    int compareFunc,
  );
  external void _TextureSampler_setMinFilter(
    Pointer<TTextureSampler> sampler,
    int filter,
  );
  external void _TextureSampler_setMagFilter(
    Pointer<TTextureSampler> sampler,
    int filter,
  );
  external void _TextureSampler_setWrapModeS(
    Pointer<TTextureSampler> sampler,
    int mode,
  );
  external void _TextureSampler_setWrapModeT(
    Pointer<TTextureSampler> sampler,
    int mode,
  );
  external void _TextureSampler_setWrapModeR(
    Pointer<TTextureSampler> sampler,
    int mode,
  );
  external void _TextureSampler_setAnisotropy(
    Pointer<TTextureSampler> sampler,
    double anisotropy,
  );
  external void _TextureSampler_setCompareMode(
    Pointer<TTextureSampler> sampler,
    int mode,
    int func,
  );
  external void _TextureSampler_destroy(
    Pointer<TTextureSampler> sampler,
  );
  external Pointer<TGizmo> _Gizmo_create(
    Pointer<TEngine> tEngine,
    Pointer<TGltfAssetLoader> assetLoader,
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
    Pointer<TNameComponentManager> tNameComponentManager,
    Pointer<TView> tView,
    Pointer<TMaterial> tMaterial,
    int tGizmoType,
  );
  external void _Gizmo_pick(
    Pointer<TGizmo> tGizmo,
    int x,
    int y,
    GizmoPickCallback callback,
  );
  external void _Gizmo_highlight(
    Pointer<TGizmo> tGizmo,
    int axis,
  );
  external void _Gizmo_unhighlight(
    Pointer<TGizmo> tGizmo,
  );
  external Pointer<TMaterialInstance> _MaterialProvider_createMaterialInstance(
    Pointer<TMaterialProvider> provider,
    Pointer<TMaterialKey> key,
  );
  external Pointer<TRenderTarget> _RenderTarget_create(
    Pointer<TEngine> tEngine,
    int width,
    int height,
    Pointer<TTexture> color,
    Pointer<TTexture> depth,
  );
  external void _RenderTarget_destroy(
    Pointer<TEngine> tEngine,
    Pointer<TRenderTarget> tRenderTarget,
  );
  external void _Scene_addEntity(
    Pointer<TScene> tScene,
    EntityId entityId,
  );
  external void _Scene_removeEntity(
    Pointer<TScene> tScene,
    EntityId entityId,
  );
  external void _Scene_setSkybox(
    Pointer<TScene> tScene,
    Pointer<TSkybox> skybox,
  );
  external void _Scene_setIndirectLight(
    Pointer<TScene> tScene,
    Pointer<TIndirectLight> tIndirectLight,
  );
  external void _Scene_addFilamentAsset(
    Pointer<TScene> tScene,
    Pointer<TFilamentAsset> asset,
  );
  external void _Camera_setExposure(
    Pointer<TCamera> camera,
    double aperture,
    double shutterSpeed,
    double sensitivity,
  );
  external void _Camera_getModelMatrix(
    Pointer<double4x4> double4x4_out,
    Pointer<TCamera> camera,
  );
  external void _Camera_getViewMatrix(
    Pointer<double4x4> double4x4_out,
    Pointer<TCamera> camera,
  );
  external void _Camera_getProjectionMatrix(
    Pointer<double4x4> double4x4_out,
    Pointer<TCamera> camera,
  );
  external void _Camera_getCullingProjectionMatrix(
    Pointer<double4x4> double4x4_out,
    Pointer<TCamera> camera,
  );
  external void _Camera_getFrustum(
    Pointer<TCamera> camera,
    Pointer<Float64> out,
  );
  external void _Camera_setProjectionMatrix(
    Pointer<TCamera> camera,
    Pointer<Float64> matrix,
    double near,
    double far,
  );
  external void _Camera_setProjectionFromFov(
    Pointer<TCamera> camera,
    double fovInDegrees,
    double aspect,
    double near,
    double far,
    bool horizontal,
  );
  external double _Camera_getFocalLength(
    Pointer<TCamera> camera,
  );
  external void _Camera_lookAt(
    Pointer<TCamera> camera,
    Pointer<double3> eye_structPtr,
    Pointer<double3> focus_structPtr,
    Pointer<double3> up_structPtr,
  );
  external double _Camera_getNear(
    Pointer<TCamera> camera,
  );
  external double _Camera_getCullingFar(
    Pointer<TCamera> camera,
  );
  external double _Camera_getFov(
    Pointer<TCamera> camera,
    bool horizontal,
  );
  external double _Camera_getFocusDistance(
    Pointer<TCamera> camera,
  );
  external void _Camera_setFocusDistance(
    Pointer<TCamera> camera,
    double focusDistance,
  );
  external void _Camera_setCustomProjectionWithCulling(
    Pointer<TCamera> camera,
    Pointer<double4x4> projectionMatrix_structPtr,
    double near,
    double far,
  );
  external void _Camera_setModelMatrix(
    Pointer<TCamera> camera,
    Pointer<Float64> tModelMatrix,
  );
  external void _Camera_setLensProjection(
    Pointer<TCamera> camera,
    double near,
    double far,
    double aspect,
    double focalLength,
  );
  external EntityId _Camera_getEntity(
    Pointer<TCamera> camera,
  );
  external void _Camera_setProjection(
    Pointer<TCamera> tCamera,
    int projection,
    double left,
    double right,
    double bottom,
    double top,
    double near,
    double far,
  );
  external void _TransformManager_getLocalTransform(
    Pointer<double4x4> double4x4_out,
    Pointer<TTransformManager> tTransformManager,
    EntityId entityId,
  );
  external void _TransformManager_getWorldTransform(
    Pointer<double4x4> double4x4_out,
    Pointer<TTransformManager> tTransformManager,
    EntityId entityId,
  );
  external void _TransformManager_setTransform(
    Pointer<TTransformManager> tTransformManager,
    EntityId entityId,
    Pointer<double4x4> transform_structPtr,
  );
  external void _TransformManager_transformToUnitCube(
    Pointer<TTransformManager> tTransformManager,
    EntityId entityId,
    Pointer<Aabb3> boundingBox_structPtr,
  );
  external void _TransformManager_setParent(
    Pointer<TTransformManager> tTransformManager,
    EntityId child,
    EntityId parent,
    bool preserveScaling,
  );
  external EntityId _TransformManager_getParent(
    Pointer<TTransformManager> tTransformManager,
    EntityId child,
  );
  external EntityId _TransformManager_getAncestor(
    Pointer<TTransformManager> tTransformManager,
    EntityId childEntityId,
  );
  external void _Renderer_setClearOptions(
    Pointer<TRenderer> tRenderer,
    double clearR,
    double clearG,
    double clearB,
    double clearA,
    int clearStencil,
    bool clear,
    bool discard,
  );
  external bool _Renderer_beginFrame(
    Pointer<TRenderer> tRenderer,
    Pointer<TSwapChain> tSwapChain,
    int frameTimeInNanos,
  );
  external void _Renderer_endFrame(
    Pointer<TRenderer> tRenderer,
  );
  external void _Renderer_render(
    Pointer<TRenderer> tRenderer,
    Pointer<TView> tView,
  );
  external void _Renderer_renderStandaloneView(
    Pointer<TRenderer> tRenderer,
    Pointer<TView> tView,
  );
  external void _Renderer_setFrameInterval(
    Pointer<TRenderer> tRenderer,
    double headRoomRatio,
    double scaleRate,
    int history,
    int interval,
  );
  external Pointer<TRenderTicker> _RenderTicker_create(
    Pointer<TRenderer> tRenderer,
  );
  external void _RenderTicker_destroy(
    Pointer<TRenderTicker> tRenderTicker,
  );
  external void _RenderTicker_addAnimationManager(
    Pointer<TRenderTicker> tRenderTicker,
    Pointer<TAnimationManager> tAnimationManager,
  );
  external void _RenderTicker_removeAnimationManager(
    Pointer<TRenderTicker> tRenderTicker,
    Pointer<TAnimationManager> tAnimationManager,
  );
  external void _RenderTicker_render(
    Pointer<TRenderTicker> tRenderTicker,
    int frameTimeInNanos,
  );
  external void _RenderTicker_setRenderable(
    Pointer<TRenderTicker> tRenderTicker,
    Pointer<TSwapChain> swapChain,
    Pointer<self.Pointer<TView>> views,
    int numViews,
  );
  external void _RenderThread_create();
  external void _RenderThread_destroy();
  external void _RenderThread_requestFrame(
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _RenderThread_setRenderTicker(
    Pointer<TRenderTicker> tRenderTicker,
  );
  external void _RenderThread_addTask(
    Pointer<self.NativeFunction<void Function()>> task_interopFnPtr,
  );
  external void _RenderTicker_renderRenderThread(
    Pointer<TRenderTicker> tRenderTicker,
    int frameTimeInNanos,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _AnimationManager_createRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TScene> tScene,
    Pointer<self.NativeFunction<void Function(Pointer<TAnimationManager>)>>
        onComplete_interopFnPtr,
  );
  external void _Engine_createRenderThread(
    int backend,
    Pointer<Void> platform,
    Pointer<Void> sharedContext,
    int stereoscopicEyeCount,
    bool disableHandleUseAfterFreeCheck,
    Pointer<self.NativeFunction<void Function(Pointer<TEngine>)>>
        onComplete_interopFnPtr,
  );
  external void _Engine_createRendererRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<self.NativeFunction<void Function(Pointer<TRenderer>)>>
        onComplete_interopFnPtr,
  );
  external void _Engine_createSwapChainRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<Void> window,
    int flags,
    Pointer<self.NativeFunction<void Function(Pointer<TSwapChain>)>>
        onComplete_interopFnPtr,
  );
  external void _Engine_createHeadlessSwapChainRenderThread(
    Pointer<TEngine> tEngine,
    int width,
    int height,
    int flags,
    Pointer<self.NativeFunction<void Function(Pointer<TSwapChain>)>>
        onComplete_interopFnPtr,
  );
  external void _Engine_createCameraRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<self.NativeFunction<void Function(Pointer<TCamera>)>>
        onComplete_interopFnPtr,
  );
  external void _Engine_createViewRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<self.NativeFunction<void Function(Pointer<TView>)>>
        onComplete_interopFnPtr,
  );
  external void _Engine_destroyRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Engine_destroySwapChainRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TSwapChain> tSwapChain,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Engine_destroyViewRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TView> tView,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Engine_destroySceneRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TScene> tScene,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Engine_destroyColorGradingRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TColorGrading> tColorGrading,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Engine_destroyMaterialRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TMaterial> tMaterial,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Engine_destroyMaterialInstanceRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TMaterialInstance> tMaterialInstance,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Engine_destroySkyboxRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TSkybox> tSkybox,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Engine_destroyIndirectLightRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TIndirectLight> tIndirectLight,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Texture_buildRenderThread(
    Pointer<TEngine> engine,
    int width,
    int height,
    int depth,
    int levels,
    int tUsage,
    int import1,
    int sampler,
    int format,
    Pointer<self.NativeFunction<void Function(Pointer<TTexture>)>>
        onComplete_interopFnPtr,
  );
  external void _Engine_destroyTextureRenderThread(
    Pointer<TEngine> engine,
    Pointer<TTexture> tTexture,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Engine_createFenceRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<self.NativeFunction<void Function(Pointer<TFence>)>>
        onComplete_interopFnPtr,
  );
  external void _Engine_destroyFenceRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TFence> tFence,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Engine_flushAndWaitRenderThead(
    Pointer<TEngine> tEngine,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Renderer_setClearOptionsRenderThread(
    Pointer<TRenderer> tRenderer,
    double clearR,
    double clearG,
    double clearB,
    double clearA,
    int clearStencil,
    bool clear,
    bool discard,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Renderer_beginFrameRenderThread(
    Pointer<TRenderer> tRenderer,
    Pointer<TSwapChain> tSwapChain,
    int frameTimeInNanos,
    Pointer<self.NativeFunction<void Function(bool)>> onComplete_interopFnPtr,
  );
  external void _Renderer_endFrameRenderThread(
    Pointer<TRenderer> tRenderer,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Renderer_renderRenderThread(
    Pointer<TRenderer> tRenderer,
    Pointer<TView> tView,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Renderer_renderStandaloneViewRenderThread(
    Pointer<TRenderer> tRenderer,
    Pointer<TView> tView,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Material_createInstanceRenderThread(
    Pointer<TMaterial> tMaterial,
    Pointer<self.NativeFunction<void Function(Pointer<TMaterialInstance>)>>
        onComplete_interopFnPtr,
  );
  external void _Material_createImageMaterialRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<self.NativeFunction<void Function(Pointer<TMaterial>)>>
        onComplete_interopFnPtr,
  );
  external void _Material_createGizmoMaterialRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<self.NativeFunction<void Function(Pointer<TMaterial>)>>
        onComplete_interopFnPtr,
  );
  external void _ColorGrading_createRenderThread(
    Pointer<TEngine> tEngine,
    int toneMapping,
    Pointer<self.NativeFunction<void Function(Pointer<TColorGrading>)>>
        callback_interopFnPtr,
  );
  external void _View_setColorGradingRenderThread(
    Pointer<TView> tView,
    Pointer<TColorGrading> tColorGrading,
    Pointer<self.NativeFunction<void Function()>> callback_interopFnPtr,
  );
  external void _View_setBloomRenderThread(
    Pointer<TView> tView,
    bool enabled,
    double strength,
    Pointer<self.NativeFunction<void Function()>> callback_interopFnPtr,
  );
  external void _View_setCameraRenderThread(
    Pointer<TView> tView,
    Pointer<TCamera> tCamera,
    Pointer<self.NativeFunction<void Function()>> callback_interopFnPtr,
  );
  external FilamentRenderCallback _make_render_callback_fn_pointer(
    FilamentRenderCallback arg0,
  );
  external void _SceneAsset_destroyRenderThread(
    Pointer<TSceneAsset> tSceneAsset,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _SceneAsset_createFromFilamentAssetRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TGltfAssetLoader> tAssetLoader,
    Pointer<TNameComponentManager> tNameComponentManager,
    Pointer<TFilamentAsset> tFilamentAsset,
    Pointer<self.NativeFunction<void Function(Pointer<TSceneAsset>)>>
        onComplete_interopFnPtr,
  );
  external void _SceneAsset_createInstanceRenderThread(
    Pointer<TSceneAsset> asset,
    Pointer<self.Pointer<TMaterialInstance>> tMaterialInstances,
    int materialInstanceCount,
    Pointer<self.NativeFunction<void Function(Pointer<TSceneAsset>)>>
        callback_interopFnPtr,
  );
  external void _SceneAsset_createGeometryRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<Float32> vertices,
    int numVertices,
    Pointer<Float32> normals,
    int numNormals,
    Pointer<Float32> uvs,
    int numUvs,
    Pointer<Int32> indices,
    int numIndices,
    int tPrimitiveType,
    Pointer<self.Pointer<TMaterialInstance>> materialInstances,
    int materialInstanceCount,
    Pointer<self.NativeFunction<void Function(Pointer<TSceneAsset>)>>
        callback_interopFnPtr,
  );
  external void _MaterialProvider_createMaterialInstanceRenderThread(
    Pointer<TMaterialProvider> tMaterialProvider,
    Pointer<TMaterialKey> tKey,
    Pointer<self.NativeFunction<void Function(Pointer<TMaterialInstance>)>>
        callback_interopFnPtr,
  );
  external void _AnimationManager_updateBoneMatricesRenderThread(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    Pointer<self.NativeFunction<void Function(bool)>> callback_interopFnPtr,
  );
  external void _AnimationManager_setMorphTargetWeightsRenderThread(
    Pointer<TAnimationManager> tAnimationManager,
    EntityId entityId,
    Pointer<Float32> morphData,
    int numWeights,
    Pointer<self.NativeFunction<void Function(bool)>> callback_interopFnPtr,
  );
  external void _Image_createEmptyRenderThread(
    int width,
    int height,
    int channel,
    Pointer<self.NativeFunction<void Function(Pointer<TLinearImage>)>>
        onComplete_interopFnPtr,
  );
  external void _Image_getBytesRenderThread(
    Pointer<TLinearImage> tLinearImage,
    Pointer<self.NativeFunction<void Function(Pointer<Float32>)>>
        onComplete_interopFnPtr,
  );
  external void _Image_destroyRenderThread(
    Pointer<TLinearImage> tLinearImage,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _Image_getWidthRenderThread(
    Pointer<TLinearImage> tLinearImage,
    Pointer<self.NativeFunction<void Function(int)>> onComplete_interopFnPtr,
  );
  external void _Image_getHeightRenderThread(
    Pointer<TLinearImage> tLinearImage,
    Pointer<self.NativeFunction<void Function(int)>> onComplete_interopFnPtr,
  );
  external void _Image_getChannelsRenderThread(
    Pointer<TLinearImage> tLinearImage,
    Pointer<self.NativeFunction<void Function(int)>> onComplete_interopFnPtr,
  );
  external void _Texture_loadImageRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TTexture> tTexture,
    Pointer<TLinearImage> tImage,
    int bufferFormat,
    int pixelDataType,
    Pointer<self.NativeFunction<void Function(bool)>> onComplete_interopFnPtr,
  );
  external void _RenderTarget_getColorTextureRenderThread(
    Pointer<TRenderTarget> tRenderTarget,
    Pointer<self.NativeFunction<void Function(Pointer<TTexture>)>>
        onComplete_interopFnPtr,
  );
  external void _RenderTarget_createRenderThread(
    Pointer<TEngine> tEngine,
    int width,
    int height,
    Pointer<TTexture> color,
    Pointer<TTexture> depth,
    Pointer<self.NativeFunction<void Function(Pointer<TRenderTarget>)>>
        onComplete_interopFnPtr,
  );
  external void _RenderTarget_destroyRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TRenderTarget> tRenderTarget,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _TextureSampler_createRenderThread(
    Pointer<self.NativeFunction<void Function(Pointer<TTextureSampler>)>>
        onComplete_interopFnPtr,
  );
  external void _TextureSampler_createWithFilteringRenderThread(
    int minFilter,
    int magFilter,
    int wrapS,
    int wrapT,
    int wrapR,
    Pointer<self.NativeFunction<void Function(Pointer<TTextureSampler>)>>
        onComplete_interopFnPtr,
  );
  external void _TextureSampler_createWithComparisonRenderThread(
    int compareMode,
    int compareFunc,
    Pointer<self.NativeFunction<void Function(Pointer<TTextureSampler>)>>
        onComplete_interopFnPtr,
  );
  external void _TextureSampler_setMinFilterRenderThread(
    Pointer<TTextureSampler> sampler,
    int filter,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _TextureSampler_setMagFilterRenderThread(
    Pointer<TTextureSampler> sampler,
    int filter,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _TextureSampler_setWrapModeSRenderThread(
    Pointer<TTextureSampler> sampler,
    int mode,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _TextureSampler_setWrapModeTRenderThread(
    Pointer<TTextureSampler> sampler,
    int mode,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _TextureSampler_setWrapModeRRenderThread(
    Pointer<TTextureSampler> sampler,
    int mode,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _TextureSampler_setAnisotropyRenderThread(
    Pointer<TTextureSampler> sampler,
    double anisotropy,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _TextureSampler_setCompareModeRenderThread(
    Pointer<TTextureSampler> sampler,
    int mode,
    int func,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _TextureSampler_destroyRenderThread(
    Pointer<TTextureSampler> sampler,
    Pointer<self.NativeFunction<void Function()>> onComplete_interopFnPtr,
  );
  external void _AnimationManager_setBoneTransformRenderThread(
    Pointer<TAnimationManager> tAnimationManager,
    EntityId asset,
    int skinIndex,
    int boneIndex,
    Pointer<Float32> transform,
    Pointer<self.NativeFunction<void Function(bool)>> callback_interopFnPtr,
  );
  external void _AnimationManager_resetToRestPoseRenderThread(
    Pointer<TAnimationManager> tAnimationManager,
    EntityId entityId,
    Pointer<self.NativeFunction<void Function()>> callback_interopFnPtr,
  );
  external void _GltfAssetLoader_createRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TMaterialProvider> tMaterialProvider,
    Pointer<self.NativeFunction<void Function(Pointer<TGltfAssetLoader>)>>
        callback_interopFnPtr,
  );
  external void _GltfResourceLoader_createRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<Char> relativeResourcePath,
    Pointer<self.NativeFunction<void Function(Pointer<TGltfResourceLoader>)>>
        callback_interopFnPtr,
  );
  external void _GltfResourceLoader_destroyRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TGltfResourceLoader> tResourceLoader,
    Pointer<self.NativeFunction<void Function()>> callback_interopFnPtr,
  );
  external void _GltfResourceLoader_loadResourcesRenderThread(
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
    Pointer<TFilamentAsset> tFilamentAsset,
    Pointer<self.NativeFunction<void Function(bool)>> callback_interopFnPtr,
  );
  external void _GltfResourceLoader_asyncBeginLoadRenderThread(
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
    Pointer<TFilamentAsset> tFilamentAsset,
    Pointer<self.NativeFunction<void Function(bool)>> callback_interopFnPtr,
  );
  external void _GltfResourceLoader_asyncUpdateLoadRenderThread(
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
  );
  external void _GltfResourceLoader_asyncGetLoadProgressRenderThread(
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
    Pointer<self.NativeFunction<void Function(double)>> callback_interopFnPtr,
  );
  external void _Scene_addFilamentAssetRenderThread(
    Pointer<TScene> tScene,
    Pointer<TFilamentAsset> tAsset,
    Pointer<self.NativeFunction<void Function()>> callback_interopFnPtr,
  );
  external void _Gizmo_createRenderThread(
    Pointer<TEngine> tEngine,
    Pointer<TGltfAssetLoader> tAssetLoader,
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
    Pointer<TNameComponentManager> tNameComponentManager,
    Pointer<TView> tView,
    Pointer<TMaterial> tMaterial,
    int tGizmoType,
    Pointer<self.NativeFunction<void Function(Pointer<TGizmo>)>>
        callback_interopFnPtr,
  );
  external Pointer<TGltfResourceLoader> _GltfResourceLoader_create(
    Pointer<TEngine> tEngine,
    Pointer<Char> relativeResourcePath,
  );
  external void _GltfResourceLoader_destroy(
    Pointer<TEngine> tEngine,
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
  );
  external bool _GltfResourceLoader_asyncBeginLoad(
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
    Pointer<TFilamentAsset> tFilamentAsset,
  );
  external void _GltfResourceLoader_asyncUpdateLoad(
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
  );
  external double _GltfResourceLoader_asyncGetLoadProgress(
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
  );
  external bool _GltfResourceLoader_loadResources(
    Pointer<TGltfResourceLoader> tGltfResourceLoader,
    Pointer<TFilamentAsset> tFilamentAsset,
  );
  external void _RenderableManager_setMaterialInstanceAt(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
    int primitiveIndex,
    Pointer<TMaterialInstance> tMaterialInstance,
  );
  external Pointer<TMaterialInstance> _RenderableManager_getMaterialInstanceAt(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
    int primitiveIndex,
  );
  external bool _RenderableManager_isRenderable(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
  );
  external bool _RenderableManager_hasComponent(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
  );
  external bool _RenderableManager_empty(
    Pointer<TRenderableManager> tRenderableManager,
  );
  external bool _RenderableManager_getLightChannel(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
    int channel,
  );
  external bool _RenderableManager_isShadowCaster(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
  );
  external void _RenderableManager_setCastShadows(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
    bool castShadows,
  );
  external void _RenderableManager_setReceiveShadows(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
    bool receiveShadows,
  );
  external bool _RenderableManager_isShadowReceiver(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
  );
  external bool _RenderableManager_getFogEnabled(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
  );
  external void _RenderableManager_getAabb(
    Pointer<Aabb3> Aabb3_out,
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
  );
  external void _RenderableManager_setVisibilityLayer(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
    int layer,
  );
  external void _RenderableManager_setPriority(
    Pointer<TRenderableManager> tRenderableManager,
    EntityId entityId,
    int priority,
  );
  external Pointer<TEngine> _Engine_create(
    int backend,
    Pointer<Void> platform,
    Pointer<Void> sharedContext,
    int stereoscopicEyeCount,
    bool disableHandleUseAfterFreeCheck,
  );
  external void _Engine_destroy(
    Pointer<TEngine> tEngine,
  );
  external Pointer<TRenderer> _Engine_createRenderer(
    Pointer<TEngine> tEngine,
  );
  external Pointer<TSwapChain> _Engine_createSwapChain(
    Pointer<TEngine> tEngine,
    Pointer<Void> window,
    int flags,
  );
  external Pointer<TSwapChain> _Engine_createHeadlessSwapChain(
    Pointer<TEngine> tEngine,
    int width,
    int height,
    int flags,
  );
  external void _Engine_destroySwapChain(
    Pointer<TEngine> tEngine,
    Pointer<TSwapChain> tSwapChain,
  );
  external void _Engine_destroyView(
    Pointer<TEngine> tEngine,
    Pointer<TView> tView,
  );
  external void _Engine_destroyScene(
    Pointer<TEngine> tEngine,
    Pointer<TScene> tScene,
  );
  external void _Engine_destroyColorGrading(
    Pointer<TEngine> tEngine,
    Pointer<TColorGrading> tColorGrading,
  );
  external Pointer<TCamera> _Engine_createCamera(
    Pointer<TEngine> tEngine,
  );
  external void _Engine_destroyCamera(
    Pointer<TEngine> tEngine,
    Pointer<TCamera> tCamera,
  );
  external Pointer<TView> _Engine_createView(
    Pointer<TEngine> tEngine,
  );
  external Pointer<TCamera> _Engine_getCameraComponent(
    Pointer<TEngine> tEngine,
    EntityId entityId,
  );
  external Pointer<TTransformManager> _Engine_getTransformManager(
    Pointer<TEngine> engine,
  );
  external Pointer<TRenderableManager> _Engine_getRenderableManager(
    Pointer<TEngine> engine,
  );
  external Pointer<TLightManager> _Engine_getLightManager(
    Pointer<TEngine> engine,
  );
  external Pointer<TEntityManager> _Engine_getEntityManager(
    Pointer<TEngine> engine,
  );
  external void _Engine_destroyTexture(
    Pointer<TEngine> tEngine,
    Pointer<TTexture> tTexture,
  );
  external Pointer<TFence> _Engine_createFence(
    Pointer<TEngine> tEngine,
  );
  external void _Engine_destroyFence(
    Pointer<TEngine> tEngine,
    Pointer<TFence> tFence,
  );
  external void _Engine_flushAndWait(
    Pointer<TEngine> tEngine,
  );
  external void _Engine_destroyMaterial(
    Pointer<TEngine> tEngine,
    Pointer<TMaterial> tMaterial,
  );
  external void _Engine_destroyMaterialInstance(
    Pointer<TEngine> tEngine,
    Pointer<TMaterialInstance> tMaterialInstance,
  );
  external Pointer<TScene> _Engine_createScene(
    Pointer<TEngine> tEngine,
  );
  external void _Engine_destroySkybox(
    Pointer<TEngine> tEngine,
    Pointer<TSkybox> tSkybox,
  );
  external void _Engine_destroyIndirectLight(
    Pointer<TEngine> tEngine,
    Pointer<TIndirectLight> tIndirectLight,
  );
  external int _int_foo(
    int bar,
  );
  external Pointer<Char> _string_foo(
    Pointer<Char> bar,
  );
  external int _sum(
    int a,
    int b,
  );
  external int _subtract(
    Pointer<Int32> a,
    int b,
  );
  external Pointer<Float64> _dividePrecision(
    Pointer<Float64> a,
    Pointer<Float64> b,
  );
  external void _getfoo(
    Pointer<Foo> Foo_out,
  );
  external void _setfoo(
    Pointer<Foo> foo_structPtr,
  );
  external void _invoke_Fn(
    Pointer<self.NativeFunction<void Function(int)>> fn_interopFnPtr,
  );
  external Pointer<TSceneAsset> _SceneAsset_createGeometry(
    Pointer<TEngine> tEngine,
    Pointer<Float32> vertices,
    int numVertices,
    Pointer<Float32> normals,
    int numNormals,
    Pointer<Float32> uvs,
    int numUvs,
    Pointer<Int32> indices,
    int numIndices,
    int tPrimitiveType,
    Pointer<self.Pointer<TMaterialInstance>> materialInstances,
    int materialInstanceCount,
  );
  external Pointer<TSceneAsset> _SceneAsset_createFromFilamentAsset(
    Pointer<TEngine> tEngine,
    Pointer<TGltfAssetLoader> tAssetLoader,
    Pointer<TNameComponentManager> tNameComponentManager,
    Pointer<TFilamentAsset> tFilamentAsset,
  );
  external Pointer<TFilamentAsset> _SceneAsset_getFilamentAsset(
    Pointer<TSceneAsset> tSceneAsset,
  );
  external Pointer<TSceneAsset> _SceneAsset_createGrid(
    Pointer<TEngine> tEngine,
    Pointer<TMaterial> tMaterial,
  );
  external void _SceneAsset_destroy(
    Pointer<TSceneAsset> tSceneAsset,
  );
  external void _SceneAsset_addToScene(
    Pointer<TSceneAsset> tSceneAsset,
    Pointer<TScene> tScene,
  );
  external void _SceneAsset_removeFromScene(
    Pointer<TSceneAsset> tSceneAsset,
    Pointer<TScene> tScene,
  );
  external EntityId _SceneAsset_getEntity(
    Pointer<TSceneAsset> tSceneAsset,
  );
  external int _SceneAsset_getChildEntityCount(
    Pointer<TSceneAsset> tSceneAsset,
  );
  external void _SceneAsset_getChildEntities(
    Pointer<TSceneAsset> tSceneAsset,
    Pointer<Int32> out,
  );
  external Pointer<Int32> _SceneAsset_getCameraEntities(
    Pointer<TSceneAsset> tSceneAsset,
  );
  external Pointer<Int32> _SceneAsset_getLightEntities(
    Pointer<TSceneAsset> tSceneAsset,
  );
  external Pointer<TSceneAsset> _SceneAsset_getInstance(
    Pointer<TSceneAsset> tSceneAsset,
    int index,
  );
  external Pointer<TSceneAsset> _SceneAsset_createInstance(
    Pointer<TSceneAsset> asset,
    Pointer<self.Pointer<TMaterialInstance>> materialInstances,
    int materialInstanceCount,
  );
  external void _SceneAsset_getBoundingBox(
    Pointer<Aabb3> Aabb3_out,
    Pointer<TSceneAsset> asset,
  );
  external Pointer<TAnimationManager> _AnimationManager_create(
    Pointer<TEngine> tEngine,
    Pointer<TScene> tScene,
  );
  external void _AnimationManager_update(
    Pointer<TAnimationManager> tAnimationManager,
    int frameTimeInNanos,
  );
  external void _AnimationManager_addAnimationComponent(
    Pointer<TAnimationManager> tAnimationManager,
    EntityId entityId,
  );
  external void _AnimationManager_removeAnimationComponent(
    Pointer<TAnimationManager> tAnimationManager,
    EntityId entityId,
  );
  external bool _AnimationManager_setMorphAnimation(
    Pointer<TAnimationManager> tAnimationManager,
    EntityId entityId,
    Pointer<Float32> morphData,
    Pointer<Int32> morphIndices,
    int numMorphTargets,
    int numFrames,
    double frameLengthInMs,
  );
  external bool _AnimationManager_clearMorphAnimation(
    Pointer<TAnimationManager> tAnimationManager,
    EntityId entityId,
  );
  external void _AnimationManager_resetToRestPose(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
  );
  external void _AnimationManager_addBoneAnimation(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> tSceneAsset,
    int skinIndex,
    int boneIndex,
    Pointer<Float32> frameData,
    int numFrames,
    double frameLengthInMs,
    double fadeOutInSecs,
    double fadeInInSecs,
    double maxDelta,
  );
  external EntityId _AnimationManager_getBone(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    int skinIndex,
    int boneIndex,
  );
  external void _AnimationManager_getRestLocalTransforms(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    int skinIndex,
    Pointer<Float32> out,
    int numBones,
  );
  external void _AnimationManager_getInverseBindMatrix(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    int skinIndex,
    int boneIndex,
    Pointer<Float32> out,
  );
  external void _AnimationManager_playAnimation(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    int index,
    bool loop,
    bool reverse,
    bool replaceActive,
    double crossfade,
    double startOffset,
  );
  external void _AnimationManager_stopAnimation(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    int index,
  );
  external double _AnimationManager_getAnimationDuration(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    int animationIndex,
  );
  external int _AnimationManager_getAnimationCount(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
  );
  external void _AnimationManager_getAnimationName(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    Pointer<Char> outPtr,
    int index,
  );
  external int _AnimationManager_getBoneCount(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    int skinIndex,
  );
  external void _AnimationManager_getBoneNames(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    Pointer<self.Pointer<Char>> out,
    int skinIndex,
  );
  external int _AnimationManager_getMorphTargetNameCount(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    EntityId childEntity,
  );
  external void _AnimationManager_getMorphTargetName(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
    EntityId childEntity,
    Pointer<Char> outPtr,
    int index,
  );
  external bool _AnimationManager_updateBoneMatrices(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> sceneAsset,
  );
  external bool _AnimationManager_setMorphTargetWeights(
    Pointer<TAnimationManager> tAnimationManager,
    EntityId entityId,
    Pointer<Float32> morphData,
    int numWeights,
  );
  external void _AnimationManager_setGltfAnimationFrame(
    Pointer<TAnimationManager> tAnimationManager,
    Pointer<TSceneAsset> tSceneAsset,
    int animationIndex,
    int frame,
  );
}

int Thermion_createGLContext() {
  final result = _lib._Thermion_createGLContext();
  return result;
}

self.Pointer<TMaterialInstance> Material_createInstance(
  self.Pointer<TMaterial> tMaterial,
) {
  final result =
      _lib._Material_createInstance(tMaterial.addr as Pointer<TMaterial>);
  return result;
}

self.Pointer<TMaterial> Material_createImageMaterial(
  self.Pointer<TEngine> tEngine,
) {
  final result =
      _lib._Material_createImageMaterial(tEngine.addr as Pointer<TEngine>);
  return result;
}

self.Pointer<TMaterial> Material_createGridMaterial(
  self.Pointer<TEngine> tEngine,
) {
  final result =
      _lib._Material_createGridMaterial(tEngine.addr as Pointer<TEngine>);
  return result;
}

self.Pointer<TMaterial> Material_createGizmoMaterial(
  self.Pointer<TEngine> tEngine,
) {
  final result =
      _lib._Material_createGizmoMaterial(tEngine.addr as Pointer<TEngine>);
  return result;
}

bool Material_hasParameter(
  self.Pointer<TMaterial> tMaterial,
  self.Pointer<Char> propertyName,
) {
  final result = _lib._Material_hasParameter(
      tMaterial.addr as Pointer<TMaterial>, propertyName.addr as Pointer<Char>);
  return result;
}

bool MaterialInstance_isStencilWriteEnabled(
  self.Pointer<TMaterialInstance> materialInstance,
) {
  final result = _lib._MaterialInstance_isStencilWriteEnabled(
      materialInstance.addr as Pointer<TMaterialInstance>);
  return result;
}

void MaterialInstance_setStencilWrite(
  self.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
) {
  final result = _lib._MaterialInstance_setStencilWrite(
      materialInstance.addr as Pointer<TMaterialInstance>, enabled);
  return result;
}

void MaterialInstance_setCullingMode(
  self.Pointer<TMaterialInstance> materialInstance,
  TCullingMode culling,
) {
  final result = _lib._MaterialInstance_setCullingMode(
      materialInstance.addr as Pointer<TMaterialInstance>, culling.value);
  return result;
}

void MaterialInstance_setDepthWrite(
  self.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
) {
  final result = _lib._MaterialInstance_setDepthWrite(
      materialInstance.addr as Pointer<TMaterialInstance>, enabled);
  return result;
}

void MaterialInstance_setDepthCulling(
  self.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
) {
  final result = _lib._MaterialInstance_setDepthCulling(
      materialInstance.addr as Pointer<TMaterialInstance>, enabled);
  return result;
}

void MaterialInstance_setParameterFloat(
  self.Pointer<TMaterialInstance> materialInstance,
  self.Pointer<Char> propertyName,
  double value,
) {
  final result = _lib._MaterialInstance_setParameterFloat(
      materialInstance.addr as Pointer<TMaterialInstance>,
      propertyName.addr as Pointer<Char>,
      value);
  return result;
}

void MaterialInstance_setParameterFloat2(
  self.Pointer<TMaterialInstance> materialInstance,
  self.Pointer<Char> propertyName,
  double x,
  double y,
) {
  final result = _lib._MaterialInstance_setParameterFloat2(
      materialInstance.addr as Pointer<TMaterialInstance>,
      propertyName.addr as Pointer<Char>,
      x,
      y);
  return result;
}

void MaterialInstance_setParameterFloat3(
  self.Pointer<TMaterialInstance> materialInstance,
  self.Pointer<Char> propertyName,
  double x,
  double y,
  double z,
) {
  final result = _lib._MaterialInstance_setParameterFloat3(
      materialInstance.addr as Pointer<TMaterialInstance>,
      propertyName.addr as Pointer<Char>,
      x,
      y,
      z);
  return result;
}

void MaterialInstance_setParameterFloat3Array(
  self.Pointer<TMaterialInstance> tMaterialInstance,
  self.Pointer<Char> propertyName,
  self.Pointer<Float64> raw,
  int length,
) {
  final result = _lib._MaterialInstance_setParameterFloat3Array(
      tMaterialInstance.addr as Pointer<TMaterialInstance>,
      propertyName.addr as Pointer<Char>,
      raw.addr as Pointer<Float64>,
      length);
  return result;
}

void MaterialInstance_setParameterFloat4(
  self.Pointer<TMaterialInstance> materialInstance,
  self.Pointer<Char> propertyName,
  double x,
  double y,
  double w,
  double z,
) {
  final result = _lib._MaterialInstance_setParameterFloat4(
      materialInstance.addr as Pointer<TMaterialInstance>,
      propertyName.addr as Pointer<Char>,
      x,
      y,
      w,
      z);
  return result;
}

void MaterialInstance_setParameterMat4(
  self.Pointer<TMaterialInstance> materialInstance,
  self.Pointer<Char> propertyName,
  self.Pointer<Float64> matrix,
) {
  final result = _lib._MaterialInstance_setParameterMat4(
      materialInstance.addr as Pointer<TMaterialInstance>,
      propertyName.addr as Pointer<Char>,
      matrix.addr as Pointer<Float64>);
  return result;
}

void MaterialInstance_setParameterInt(
  self.Pointer<TMaterialInstance> materialInstance,
  self.Pointer<Char> propertyName,
  int value,
) {
  final result = _lib._MaterialInstance_setParameterInt(
      materialInstance.addr as Pointer<TMaterialInstance>,
      propertyName.addr as Pointer<Char>,
      value);
  return result;
}

void MaterialInstance_setParameterBool(
  self.Pointer<TMaterialInstance> materialInstance,
  self.Pointer<Char> propertyName,
  bool value,
) {
  final result = _lib._MaterialInstance_setParameterBool(
      materialInstance.addr as Pointer<TMaterialInstance>,
      propertyName.addr as Pointer<Char>,
      value);
  return result;
}

void MaterialInstance_setParameterTexture(
  self.Pointer<TMaterialInstance> materialInstance,
  self.Pointer<Char> propertyName,
  self.Pointer<TTexture> texture,
  self.Pointer<TTextureSampler> sampler,
) {
  final result = _lib._MaterialInstance_setParameterTexture(
      materialInstance.addr as Pointer<TMaterialInstance>,
      propertyName.addr as Pointer<Char>,
      texture.addr as Pointer<TTexture>,
      sampler.addr as Pointer<TTextureSampler>);
  return result;
}

void MaterialInstance_setDepthFunc(
  self.Pointer<TMaterialInstance> materialInstance,
  TSamplerCompareFunc depthFunc,
) {
  final result = _lib._MaterialInstance_setDepthFunc(
      materialInstance.addr as Pointer<TMaterialInstance>, depthFunc.value);
  return result;
}

void MaterialInstance_setStencilOpStencilFail(
  self.Pointer<TMaterialInstance> materialInstance,
  TStencilOperation op,
  TStencilFace face,
) {
  final result = _lib._MaterialInstance_setStencilOpStencilFail(
      materialInstance.addr as Pointer<TMaterialInstance>,
      op.value,
      face.value);
  return result;
}

void MaterialInstance_setStencilOpDepthFail(
  self.Pointer<TMaterialInstance> materialInstance,
  TStencilOperation op,
  TStencilFace face,
) {
  final result = _lib._MaterialInstance_setStencilOpDepthFail(
      materialInstance.addr as Pointer<TMaterialInstance>,
      op.value,
      face.value);
  return result;
}

void MaterialInstance_setStencilOpDepthStencilPass(
  self.Pointer<TMaterialInstance> materialInstance,
  TStencilOperation op,
  TStencilFace face,
) {
  final result = _lib._MaterialInstance_setStencilOpDepthStencilPass(
      materialInstance.addr as Pointer<TMaterialInstance>,
      op.value,
      face.value);
  return result;
}

void MaterialInstance_setStencilCompareFunction(
  self.Pointer<TMaterialInstance> materialInstance,
  TSamplerCompareFunc func,
  TStencilFace face,
) {
  final result = _lib._MaterialInstance_setStencilCompareFunction(
      materialInstance.addr as Pointer<TMaterialInstance>,
      func.value,
      face.value);
  return result;
}

void MaterialInstance_setStencilReferenceValue(
  self.Pointer<TMaterialInstance> materialInstance,
  int value,
  TStencilFace face,
) {
  final result = _lib._MaterialInstance_setStencilReferenceValue(
      materialInstance.addr as Pointer<TMaterialInstance>, value, face.value);
  return result;
}

void MaterialInstance_setStencilReadMask(
  self.Pointer<TMaterialInstance> materialInstance,
  int mask,
) {
  final result = _lib._MaterialInstance_setStencilReadMask(
      materialInstance.addr as Pointer<TMaterialInstance>, mask);
  return result;
}

void MaterialInstance_setStencilWriteMask(
  self.Pointer<TMaterialInstance> materialInstance,
  int mask,
) {
  final result = _lib._MaterialInstance_setStencilWriteMask(
      materialInstance.addr as Pointer<TMaterialInstance>, mask);
  return result;
}

void MaterialInstance_setTransparencyMode(
  self.Pointer<TMaterialInstance> materialInstance,
  TTransparencyMode transparencyMode,
) {
  final result = _lib._MaterialInstance_setTransparencyMode(
      materialInstance.addr as Pointer<TMaterialInstance>,
      transparencyMode.value);
  return result;
}

void LightManager_setPosition(
  self.Pointer<TLightManager> tLightManager,
  DartEntityId light,
  double x,
  double y,
  double z,
) {
  final result = _lib._LightManager_setPosition(
      tLightManager.addr as Pointer<TLightManager>, light, x, y, z);
  return result;
}

void LightManager_setDirection(
  self.Pointer<TLightManager> tLightManager,
  DartEntityId light,
  double x,
  double y,
  double z,
) {
  final result = _lib._LightManager_setDirection(
      tLightManager.addr as Pointer<TLightManager>, light, x, y, z);
  return result;
}

int LightManager_createLight(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TLightManager> tLightManager,
  TLightType tLightTtype,
) {
  final result = _lib._LightManager_createLight(
      tEngine.addr as Pointer<TEngine>,
      tLightManager.addr as Pointer<TLightManager>,
      tLightTtype.value);
  return result;
}

void LightManager_destroyLight(
  self.Pointer<TLightManager> tLightManager,
  DartEntityId entity,
) {
  final result = _lib._LightManager_destroyLight(
      tLightManager.addr as Pointer<TLightManager>, entity);
  return result;
}

void LightManager_setColor(
  self.Pointer<TLightManager> tLightManager,
  DartEntityId entity,
  double colorTemperature,
) {
  final result = _lib._LightManager_setColor(
      tLightManager.addr as Pointer<TLightManager>, entity, colorTemperature);
  return result;
}

void LightManager_setIntensity(
  self.Pointer<TLightManager> tLightManager,
  DartEntityId entity,
  double intensity,
) {
  final result = _lib._LightManager_setIntensity(
      tLightManager.addr as Pointer<TLightManager>, entity, intensity);
  return result;
}

void LightManager_setFalloff(
  self.Pointer<TLightManager> tLightManager,
  DartEntityId entity,
  double falloff,
) {
  final result = _lib._LightManager_setFalloff(
      tLightManager.addr as Pointer<TLightManager>, entity, falloff);
  return result;
}

void LightManager_setSpotLightCone(
  self.Pointer<TLightManager> tLightManager,
  DartEntityId entity,
  double inner,
  double outer,
) {
  final result = _lib._LightManager_setSpotLightCone(
      tLightManager.addr as Pointer<TLightManager>, entity, inner, outer);
  return result;
}

void LightManager_setShadowCaster(
  self.Pointer<TLightManager> tLightManager,
  DartEntityId entity,
  bool enabled,
) {
  final result = _lib._LightManager_setShadowCaster(
      tLightManager.addr as Pointer<TLightManager>, entity, enabled);
  return result;
}

int FilamentAsset_getEntityCount(
  self.Pointer<TFilamentAsset> filamentAsset,
) {
  final result = _lib._FilamentAsset_getEntityCount(
      filamentAsset.addr as Pointer<TFilamentAsset>);
  return result;
}

void FilamentAsset_getEntities(
  self.Pointer<TFilamentAsset> filamentAsset,
  self.Pointer<Int32> out,
) {
  final result = _lib._FilamentAsset_getEntities(
      filamentAsset.addr as Pointer<TFilamentAsset>,
      out.addr as Pointer<Int32>);
  return result;
}

self.Pointer<TGltfAssetLoader> GltfAssetLoader_create(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TMaterialProvider> tMaterialProvider,
) {
  final result = _lib._GltfAssetLoader_create(tEngine.addr as Pointer<TEngine>,
      tMaterialProvider.addr as Pointer<TMaterialProvider>);
  return result;
}

self.Pointer<TMaterialInstance> GltfAssetLoader_getMaterialInstance(
  self.Pointer<TRenderableManager> tRenderableManager,
  self.Pointer<TFilamentAsset> tAsset,
) {
  final result = _lib._GltfAssetLoader_getMaterialInstance(
      tRenderableManager.addr as Pointer<TRenderableManager>,
      tAsset.addr as Pointer<TFilamentAsset>);
  return result;
}

self.Pointer<TMaterialProvider> GltfAssetLoader_getMaterialProvider(
  self.Pointer<TGltfAssetLoader> tAssetLoader,
) {
  final result = _lib._GltfAssetLoader_getMaterialProvider(
      tAssetLoader.addr as Pointer<TGltfAssetLoader>);
  return result;
}

int FilamentAsset_getResourceUriCount(
  self.Pointer<TFilamentAsset> tFilamentAsset,
) {
  final result = _lib._FilamentAsset_getResourceUriCount(
      tFilamentAsset.addr as Pointer<TFilamentAsset>);
  return result;
}

self.Pointer<self.Pointer<Char>> FilamentAsset_getResourceUris(
  self.Pointer<TFilamentAsset> tFilamentAsset,
) {
  final result = _lib._FilamentAsset_getResourceUris(
      tFilamentAsset.addr as Pointer<TFilamentAsset>);
  return result;
}

DartTViewport View_getViewport(
  self.Pointer<TView> view,
) {
  final TViewport_out = TViewport.stackAlloc();
  final result = _lib._View_getViewport(
      TViewport_out.addr as Pointer<TViewport>, view.addr as Pointer<TView>);
  return TViewport_out.toDart();
}

self.Pointer<TColorGrading> ColorGrading_create(
  self.Pointer<TEngine> tEngine,
  TToneMapping toneMapping,
) {
  final result = _lib._ColorGrading_create(
      tEngine.addr as Pointer<TEngine>, toneMapping.value);
  return result;
}

void View_setColorGrading(
  self.Pointer<TView> tView,
  self.Pointer<TColorGrading> tColorGrading,
) {
  final result = _lib._View_setColorGrading(tView.addr as Pointer<TView>,
      tColorGrading.addr as Pointer<TColorGrading>);
  return result;
}

void View_setBlendMode(
  self.Pointer<TView> view,
  TBlendMode blendMode,
) {
  final result =
      _lib._View_setBlendMode(view.addr as Pointer<TView>, blendMode.value);
  return result;
}

void View_setViewport(
  self.Pointer<TView> view,
  int width,
  int height,
) {
  final result =
      _lib._View_setViewport(view.addr as Pointer<TView>, width, height);
  return result;
}

void View_setRenderTarget(
  self.Pointer<TView> view,
  self.Pointer<TRenderTarget> renderTarget,
) {
  final result = _lib._View_setRenderTarget(
      view.addr as Pointer<TView>, renderTarget.addr as Pointer<TRenderTarget>);
  return result;
}

void View_setFrustumCullingEnabled(
  self.Pointer<TView> view,
  bool enabled,
) {
  final result =
      _lib._View_setFrustumCullingEnabled(view.addr as Pointer<TView>, enabled);
  return result;
}

self.Pointer<TRenderTarget> View_getRenderTarget(
  self.Pointer<TView> tView,
) {
  final result = _lib._View_getRenderTarget(tView.addr as Pointer<TView>);
  return result;
}

void View_setPostProcessing(
  self.Pointer<TView> tView,
  bool enabled,
) {
  final result =
      _lib._View_setPostProcessing(tView.addr as Pointer<TView>, enabled);
  return result;
}

void View_setShadowsEnabled(
  self.Pointer<TView> tView,
  bool enabled,
) {
  final result =
      _lib._View_setShadowsEnabled(tView.addr as Pointer<TView>, enabled);
  return result;
}

void View_setShadowType(
  self.Pointer<TView> tView,
  int shadowType,
) {
  final result =
      _lib._View_setShadowType(tView.addr as Pointer<TView>, shadowType);
  return result;
}

void View_setSoftShadowOptions(
  self.Pointer<TView> tView,
  double penumbraScale,
  double penumbraRatioScale,
) {
  final result = _lib._View_setSoftShadowOptions(
      tView.addr as Pointer<TView>, penumbraScale, penumbraRatioScale);
  return result;
}

void View_setBloom(
  self.Pointer<TView> tView,
  bool enabled,
  double strength,
) {
  final result =
      _lib._View_setBloom(tView.addr as Pointer<TView>, enabled, strength);
  return result;
}

void View_setRenderQuality(
  self.Pointer<TView> tView,
  TQualityLevel qualityLevel,
) {
  final result = _lib._View_setRenderQuality(
      tView.addr as Pointer<TView>, qualityLevel.value);
  return result;
}

void View_setAntiAliasing(
  self.Pointer<TView> tView,
  bool msaa,
  bool fxaa,
  bool taa,
) {
  final result =
      _lib._View_setAntiAliasing(tView.addr as Pointer<TView>, msaa, fxaa, taa);
  return result;
}

void View_setLayerEnabled(
  self.Pointer<TView> tView,
  int layer,
  bool visible,
) {
  final result =
      _lib._View_setLayerEnabled(tView.addr as Pointer<TView>, layer, visible);
  return result;
}

void View_setCamera(
  self.Pointer<TView> tView,
  self.Pointer<TCamera> tCamera,
) {
  final result = _lib._View_setCamera(
      tView.addr as Pointer<TView>, tCamera.addr as Pointer<TCamera>);
  return result;
}

self.Pointer<TScene> View_getScene(
  self.Pointer<TView> tView,
) {
  final result = _lib._View_getScene(tView.addr as Pointer<TView>);
  return result;
}

self.Pointer<TCamera> View_getCamera(
  self.Pointer<TView> tView,
) {
  final result = _lib._View_getCamera(tView.addr as Pointer<TView>);
  return result;
}

void View_setStencilBufferEnabled(
  self.Pointer<TView> tView,
  bool enabled,
) {
  final result =
      _lib._View_setStencilBufferEnabled(tView.addr as Pointer<TView>, enabled);
  return result;
}

bool View_isStencilBufferEnabled(
  self.Pointer<TView> tView,
) {
  final result =
      _lib._View_isStencilBufferEnabled(tView.addr as Pointer<TView>);
  return result;
}

void View_setDitheringEnabled(
  self.Pointer<TView> tView,
  bool enabled,
) {
  final result =
      _lib._View_setDitheringEnabled(tView.addr as Pointer<TView>, enabled);
  return result;
}

bool View_isDitheringEnabled(
  self.Pointer<TView> tView,
) {
  final result = _lib._View_isDitheringEnabled(tView.addr as Pointer<TView>);
  return result;
}

void View_setScene(
  self.Pointer<TView> tView,
  self.Pointer<TScene> tScene,
) {
  final result = _lib._View_setScene(
      tView.addr as Pointer<TView>, tScene.addr as Pointer<TScene>);
  return result;
}

void View_setFrontFaceWindingInverted(
  self.Pointer<TView> tView,
  bool inverted,
) {
  final result = _lib._View_setFrontFaceWindingInverted(
      tView.addr as Pointer<TView>, inverted);
  return result;
}

void View_pick(
  self.Pointer<TView> tView,
  int requestId,
  int x,
  int y,
  DartPickCallback callback,
) {
  final result = _lib._View_pick(tView.addr as Pointer<TView>, requestId, x, y,
      callback.addr as Pointer<self.NativeFunction<PickCallbackFunction>>);
  return result;
}

self.Pointer<TNameComponentManager> NameComponentManager_create() {
  final result = _lib._NameComponentManager_create();
  return result;
}

self.Pointer<Char> NameComponentManager_getName(
  self.Pointer<TNameComponentManager> tNameComponentManager,
  DartEntityId entity,
) {
  final result = _lib._NameComponentManager_getName(
      tNameComponentManager.addr as Pointer<TNameComponentManager>, entity);
  return result;
}

void IndirectLight_setRotation(
  self.Pointer<TIndirectLight> tIndirectLight,
  self.Pointer<Float64> rotation,
) {
  final result = _lib._IndirectLight_setRotation(
      tIndirectLight.addr as Pointer<TIndirectLight>,
      rotation.addr as Pointer<Float64>);
  return result;
}

self.Pointer<TTexture> Texture_build(
  self.Pointer<TEngine> engine,
  int width,
  int height,
  int depth,
  int levels,
  int tUsage,
  int import1,
  TTextureSamplerType sampler,
  TTextureFormat format,
) {
  final result = _lib._Texture_build(engine.addr as Pointer<TEngine>, width,
      height, depth, levels, tUsage, import1, sampler.value, format.value);
  return result;
}

bool Texture_loadImage(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TTexture> tTexture,
  self.Pointer<TLinearImage> tImage,
  TPixelDataFormat bufferFormat,
  TPixelDataType pixelDataType,
) {
  final result = _lib._Texture_loadImage(
      tEngine.addr as Pointer<TEngine>,
      tTexture.addr as Pointer<TTexture>,
      tImage.addr as Pointer<TLinearImage>,
      bufferFormat.value,
      pixelDataType.value);
  return result;
}

int Texture_getWidth(
  self.Pointer<TTexture> tTexture,
  int level,
) {
  final result =
      _lib._Texture_getWidth(tTexture.addr as Pointer<TTexture>, level);
  return result;
}

int Texture_getHeight(
  self.Pointer<TTexture> tTexture,
  int level,
) {
  final result =
      _lib._Texture_getHeight(tTexture.addr as Pointer<TTexture>, level);
  return result;
}

int Texture_getDepth(
  self.Pointer<TTexture> tTexture,
  int level,
) {
  final result =
      _lib._Texture_getDepth(tTexture.addr as Pointer<TTexture>, level);
  return result;
}

TTextureUsage Texture_getUsage(
  self.Pointer<TTexture> tTexture,
  int level,
) {
  final result =
      _lib._Texture_getUsage(tTexture.addr as Pointer<TTexture>, level);
  return TTextureUsage.fromValue(result);
}

self.Pointer<TLinearImage> Image_createEmpty(
  int width,
  int height,
  int channel,
) {
  final result = _lib._Image_createEmpty(width, height, channel);
  return result;
}

self.Pointer<Float32> Image_getBytes(
  self.Pointer<TLinearImage> tLinearImage,
) {
  final result =
      _lib._Image_getBytes(tLinearImage.addr as Pointer<TLinearImage>);
  return result;
}

void Image_destroy(
  self.Pointer<TLinearImage> tLinearImage,
) {
  final result =
      _lib._Image_destroy(tLinearImage.addr as Pointer<TLinearImage>);
  return result;
}

int Image_getWidth(
  self.Pointer<TLinearImage> tLinearImage,
) {
  final result =
      _lib._Image_getWidth(tLinearImage.addr as Pointer<TLinearImage>);
  return result;
}

int Image_getHeight(
  self.Pointer<TLinearImage> tLinearImage,
) {
  final result =
      _lib._Image_getHeight(tLinearImage.addr as Pointer<TLinearImage>);
  return result;
}

int Image_getChannels(
  self.Pointer<TLinearImage> tLinearImage,
) {
  final result =
      _lib._Image_getChannels(tLinearImage.addr as Pointer<TLinearImage>);
  return result;
}

self.Pointer<TTexture> RenderTarget_getColorTexture(
  self.Pointer<TRenderTarget> tRenderTarget,
) {
  final result = _lib._RenderTarget_getColorTexture(
      tRenderTarget.addr as Pointer<TRenderTarget>);
  return result;
}

self.Pointer<TTexture> RenderTarget_getDepthTexture(
  self.Pointer<TRenderTarget> tRenderTarget,
) {
  final result = _lib._RenderTarget_getDepthTexture(
      tRenderTarget.addr as Pointer<TRenderTarget>);
  return result;
}

self.Pointer<TTextureSampler> TextureSampler_create() {
  final result = _lib._TextureSampler_create();
  return result;
}

self.Pointer<TTextureSampler> TextureSampler_createWithFiltering(
  TSamplerMinFilter minFilter,
  TSamplerMagFilter magFilter,
  TSamplerWrapMode wrapS,
  TSamplerWrapMode wrapT,
  TSamplerWrapMode wrapR,
) {
  final result = _lib._TextureSampler_createWithFiltering(
      minFilter.value, magFilter.value, wrapS.value, wrapT.value, wrapR.value);
  return result;
}

self.Pointer<TTextureSampler> TextureSampler_createWithComparison(
  TSamplerCompareMode compareMode,
  TSamplerCompareFunc compareFunc,
) {
  final result = _lib._TextureSampler_createWithComparison(
      compareMode.value, compareFunc.value);
  return result;
}

void TextureSampler_setMinFilter(
  self.Pointer<TTextureSampler> sampler,
  TSamplerMinFilter filter,
) {
  final result = _lib._TextureSampler_setMinFilter(
      sampler.addr as Pointer<TTextureSampler>, filter.value);
  return result;
}

void TextureSampler_setMagFilter(
  self.Pointer<TTextureSampler> sampler,
  TSamplerMagFilter filter,
) {
  final result = _lib._TextureSampler_setMagFilter(
      sampler.addr as Pointer<TTextureSampler>, filter.value);
  return result;
}

void TextureSampler_setWrapModeS(
  self.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
) {
  final result = _lib._TextureSampler_setWrapModeS(
      sampler.addr as Pointer<TTextureSampler>, mode.value);
  return result;
}

void TextureSampler_setWrapModeT(
  self.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
) {
  final result = _lib._TextureSampler_setWrapModeT(
      sampler.addr as Pointer<TTextureSampler>, mode.value);
  return result;
}

void TextureSampler_setWrapModeR(
  self.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
) {
  final result = _lib._TextureSampler_setWrapModeR(
      sampler.addr as Pointer<TTextureSampler>, mode.value);
  return result;
}

void TextureSampler_setAnisotropy(
  self.Pointer<TTextureSampler> sampler,
  double anisotropy,
) {
  final result = _lib._TextureSampler_setAnisotropy(
      sampler.addr as Pointer<TTextureSampler>, anisotropy);
  return result;
}

void TextureSampler_setCompareMode(
  self.Pointer<TTextureSampler> sampler,
  TSamplerCompareMode mode,
  TSamplerCompareFunc func,
) {
  final result = _lib._TextureSampler_setCompareMode(
      sampler.addr as Pointer<TTextureSampler>, mode.value, func.value);
  return result;
}

void TextureSampler_destroy(
  self.Pointer<TTextureSampler> sampler,
) {
  final result =
      _lib._TextureSampler_destroy(sampler.addr as Pointer<TTextureSampler>);
  return result;
}

self.Pointer<TGizmo> Gizmo_create(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TGltfAssetLoader> assetLoader,
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  self.Pointer<TNameComponentManager> tNameComponentManager,
  self.Pointer<TView> tView,
  self.Pointer<TMaterial> tMaterial,
  TGizmoType tGizmoType,
) {
  final result = _lib._Gizmo_create(
      tEngine.addr as Pointer<TEngine>,
      assetLoader.addr as Pointer<TGltfAssetLoader>,
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>,
      tNameComponentManager.addr as Pointer<TNameComponentManager>,
      tView.addr as Pointer<TView>,
      tMaterial.addr as Pointer<TMaterial>,
      tGizmoType.value);
  return result;
}

void Gizmo_pick(
  self.Pointer<TGizmo> tGizmo,
  int x,
  int y,
  DartGizmoPickCallback callback,
) {
  final result = _lib._Gizmo_pick(tGizmo.addr as Pointer<TGizmo>, x, y,
      callback.addr as Pointer<self.NativeFunction<GizmoPickCallbackFunction>>);
  return result;
}

void Gizmo_highlight(
  self.Pointer<TGizmo> tGizmo,
  TGizmoAxis axis,
) {
  final result =
      _lib._Gizmo_highlight(tGizmo.addr as Pointer<TGizmo>, axis.value);
  return result;
}

void Gizmo_unhighlight(
  self.Pointer<TGizmo> tGizmo,
) {
  final result = _lib._Gizmo_unhighlight(tGizmo.addr as Pointer<TGizmo>);
  return result;
}

self.Pointer<TMaterialInstance> MaterialProvider_createMaterialInstance(
  self.Pointer<TMaterialProvider> provider,
  self.Pointer<TMaterialKey> key,
) {
  final result = _lib._MaterialProvider_createMaterialInstance(
      provider.addr as Pointer<TMaterialProvider>,
      key.addr as Pointer<TMaterialKey>);
  return result;
}

self.Pointer<TRenderTarget> RenderTarget_create(
  self.Pointer<TEngine> tEngine,
  int width,
  int height,
  self.Pointer<TTexture> color,
  self.Pointer<TTexture> depth,
) {
  final result = _lib._RenderTarget_create(
      tEngine.addr as Pointer<TEngine>,
      width,
      height,
      color.addr as Pointer<TTexture>,
      depth.addr as Pointer<TTexture>);
  return result;
}

void RenderTarget_destroy(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TRenderTarget> tRenderTarget,
) {
  final result = _lib._RenderTarget_destroy(tEngine.addr as Pointer<TEngine>,
      tRenderTarget.addr as Pointer<TRenderTarget>);
  return result;
}

void Scene_addEntity(
  self.Pointer<TScene> tScene,
  DartEntityId entityId,
) {
  final result =
      _lib._Scene_addEntity(tScene.addr as Pointer<TScene>, entityId);
  return result;
}

void Scene_removeEntity(
  self.Pointer<TScene> tScene,
  DartEntityId entityId,
) {
  final result =
      _lib._Scene_removeEntity(tScene.addr as Pointer<TScene>, entityId);
  return result;
}

void Scene_setSkybox(
  self.Pointer<TScene> tScene,
  self.Pointer<TSkybox> skybox,
) {
  final result = _lib._Scene_setSkybox(
      tScene.addr as Pointer<TScene>, skybox.addr as Pointer<TSkybox>);
  return result;
}

void Scene_setIndirectLight(
  self.Pointer<TScene> tScene,
  self.Pointer<TIndirectLight> tIndirectLight,
) {
  final result = _lib._Scene_setIndirectLight(tScene.addr as Pointer<TScene>,
      tIndirectLight.addr as Pointer<TIndirectLight>);
  return result;
}

void Scene_addFilamentAsset(
  self.Pointer<TScene> tScene,
  self.Pointer<TFilamentAsset> asset,
) {
  final result = _lib._Scene_addFilamentAsset(
      tScene.addr as Pointer<TScene>, asset.addr as Pointer<TFilamentAsset>);
  return result;
}

void Camera_setExposure(
  self.Pointer<TCamera> camera,
  double aperture,
  double shutterSpeed,
  double sensitivity,
) {
  final result = _lib._Camera_setExposure(
      camera.addr as Pointer<TCamera>, aperture, shutterSpeed, sensitivity);
  return result;
}

Dartdouble4x4 Camera_getModelMatrix(
  self.Pointer<TCamera> camera,
) {
  final double4x4_out = double4x4.stackAlloc();
  final result = _lib._Camera_getModelMatrix(
      double4x4_out.addr as Pointer<double4x4>,
      camera.addr as Pointer<TCamera>);
  return double4x4_out.toDart();
}

Dartdouble4x4 Camera_getViewMatrix(
  self.Pointer<TCamera> camera,
) {
  final double4x4_out = double4x4.stackAlloc();
  final result = _lib._Camera_getViewMatrix(
      double4x4_out.addr as Pointer<double4x4>,
      camera.addr as Pointer<TCamera>);
  return double4x4_out.toDart();
}

Dartdouble4x4 Camera_getProjectionMatrix(
  self.Pointer<TCamera> camera,
) {
  final double4x4_out = double4x4.stackAlloc();
  final result = _lib._Camera_getProjectionMatrix(
      double4x4_out.addr as Pointer<double4x4>,
      camera.addr as Pointer<TCamera>);
  return double4x4_out.toDart();
}

Dartdouble4x4 Camera_getCullingProjectionMatrix(
  self.Pointer<TCamera> camera,
) {
  final double4x4_out = double4x4.stackAlloc();
  final result = _lib._Camera_getCullingProjectionMatrix(
      double4x4_out.addr as Pointer<double4x4>,
      camera.addr as Pointer<TCamera>);
  return double4x4_out.toDart();
}

void Camera_getFrustum(
  self.Pointer<TCamera> camera,
  self.Pointer<Float64> out,
) {
  final result = _lib._Camera_getFrustum(
      camera.addr as Pointer<TCamera>, out.addr as Pointer<Float64>);
  return result;
}

void Camera_setProjectionMatrix(
  self.Pointer<TCamera> camera,
  self.Pointer<Float64> matrix,
  double near,
  double far,
) {
  final result = _lib._Camera_setProjectionMatrix(
      camera.addr as Pointer<TCamera>,
      matrix.addr as Pointer<Float64>,
      near,
      far);
  return result;
}

void Camera_setProjectionFromFov(
  self.Pointer<TCamera> camera,
  double fovInDegrees,
  double aspect,
  double near,
  double far,
  bool horizontal,
) {
  final result = _lib._Camera_setProjectionFromFov(
      camera.addr as Pointer<TCamera>,
      fovInDegrees,
      aspect,
      near,
      far,
      horizontal);
  return result;
}

double Camera_getFocalLength(
  self.Pointer<TCamera> camera,
) {
  final result = _lib._Camera_getFocalLength(camera.addr as Pointer<TCamera>);
  return result;
}

void Camera_lookAt(
  self.Pointer<TCamera> camera,
  Dartdouble3 eye,
  Dartdouble3 focus,
  Dartdouble3 up,
) {
  final eye_structPtr = _lib._stackAlloc<double3>(24);
  _lib.setValue((eye_structPtr.addr + 0) as Pointer, eye.x.toJS, 'double');
  _lib.setValue((eye_structPtr.addr + 8) as Pointer, eye.y.toJS, 'double');
  _lib.setValue((eye_structPtr.addr + 16) as Pointer, eye.z.toJS, 'double');

  final focus_structPtr = _lib._stackAlloc<double3>(24);
  _lib.setValue((focus_structPtr.addr + 0) as Pointer, focus.x.toJS, 'double');
  _lib.setValue((focus_structPtr.addr + 8) as Pointer, focus.y.toJS, 'double');
  _lib.setValue((focus_structPtr.addr + 16) as Pointer, focus.z.toJS, 'double');

  final up_structPtr = _lib._stackAlloc<double3>(24);
  _lib.setValue((up_structPtr.addr + 0) as Pointer, up.x.toJS, 'double');
  _lib.setValue((up_structPtr.addr + 8) as Pointer, up.y.toJS, 'double');
  _lib.setValue((up_structPtr.addr + 16) as Pointer, up.z.toJS, 'double');

  final result = _lib._Camera_lookAt(
      camera.addr as Pointer<TCamera>,
      eye_structPtr.addr as Pointer<double3>,
      focus_structPtr.addr as Pointer<double3>,
      up_structPtr.addr as Pointer<double3>);
  return result;
}

double Camera_getNear(
  self.Pointer<TCamera> camera,
) {
  final result = _lib._Camera_getNear(camera.addr as Pointer<TCamera>);
  return result;
}

double Camera_getCullingFar(
  self.Pointer<TCamera> camera,
) {
  final result = _lib._Camera_getCullingFar(camera.addr as Pointer<TCamera>);
  return result;
}

double Camera_getFov(
  self.Pointer<TCamera> camera,
  bool horizontal,
) {
  final result =
      _lib._Camera_getFov(camera.addr as Pointer<TCamera>, horizontal);
  return result;
}

double Camera_getFocusDistance(
  self.Pointer<TCamera> camera,
) {
  final result = _lib._Camera_getFocusDistance(camera.addr as Pointer<TCamera>);
  return result;
}

void Camera_setFocusDistance(
  self.Pointer<TCamera> camera,
  double focusDistance,
) {
  final result = _lib._Camera_setFocusDistance(
      camera.addr as Pointer<TCamera>, focusDistance);
  return result;
}

void Camera_setCustomProjectionWithCulling(
  self.Pointer<TCamera> camera,
  Dartdouble4x4 projectionMatrix,
  double near,
  double far,
) {
  final projectionMatrix_structPtr = _lib._stackAlloc<double4x4>(128);
  _lib.writeArrayToMemory(
      projectionMatrix.col1.asUint8List().toJS, projectionMatrix_structPtr + 0);
  _lib.writeArrayToMemory(projectionMatrix.col2.asUint8List().toJS,
      projectionMatrix_structPtr + 32);
  _lib.writeArrayToMemory(projectionMatrix.col3.asUint8List().toJS,
      projectionMatrix_structPtr + 64);
  _lib.writeArrayToMemory(projectionMatrix.col4.asUint8List().toJS,
      projectionMatrix_structPtr + 96);
  final result = _lib._Camera_setCustomProjectionWithCulling(
      camera.addr as Pointer<TCamera>,
      projectionMatrix_structPtr.addr as Pointer<double4x4>,
      near,
      far);
  return result;
}

void Camera_setModelMatrix(
  self.Pointer<TCamera> camera,
  self.Pointer<Float64> tModelMatrix,
) {
  final result = _lib._Camera_setModelMatrix(
      camera.addr as Pointer<TCamera>, tModelMatrix.addr as Pointer<Float64>);
  return result;
}

void Camera_setLensProjection(
  self.Pointer<TCamera> camera,
  double near,
  double far,
  double aspect,
  double focalLength,
) {
  final result = _lib._Camera_setLensProjection(
      camera.addr as Pointer<TCamera>, near, far, aspect, focalLength);
  return result;
}

DartEntityId Camera_getEntity(
  self.Pointer<TCamera> camera,
) {
  final result = _lib._Camera_getEntity(camera.addr as Pointer<TCamera>);
  return result;
}

void Camera_setProjection(
  self.Pointer<TCamera> tCamera,
  TProjection projection,
  double left,
  double right,
  double bottom,
  double top,
  double near,
  double far,
) {
  final result = _lib._Camera_setProjection(tCamera.addr as Pointer<TCamera>,
      projection.value, left, right, bottom, top, near, far);
  return result;
}

Dartdouble4x4 TransformManager_getLocalTransform(
  self.Pointer<TTransformManager> tTransformManager,
  DartEntityId entityId,
) {
  final double4x4_out = double4x4.stackAlloc();
  final result = _lib._TransformManager_getLocalTransform(
      double4x4_out.addr as Pointer<double4x4>,
      tTransformManager.addr as Pointer<TTransformManager>,
      entityId);
  return double4x4_out.toDart();
}

Dartdouble4x4 TransformManager_getWorldTransform(
  self.Pointer<TTransformManager> tTransformManager,
  DartEntityId entityId,
) {
  final double4x4_out = double4x4.stackAlloc();
  final result = _lib._TransformManager_getWorldTransform(
      double4x4_out.addr as Pointer<double4x4>,
      tTransformManager.addr as Pointer<TTransformManager>,
      entityId);
  return double4x4_out.toDart();
}

void TransformManager_setTransform(
  self.Pointer<TTransformManager> tTransformManager,
  DartEntityId entityId,
  Dartdouble4x4 transform,
) {
  final transform_structPtr = _lib._stackAlloc<double4x4>(128);
  _lib.writeArrayToMemory(
      transform.col1.asUint8List().toJS, transform_structPtr + 0);
  _lib.writeArrayToMemory(
      transform.col2.asUint8List().toJS, transform_structPtr + 32);
  _lib.writeArrayToMemory(
      transform.col3.asUint8List().toJS, transform_structPtr + 64);
  _lib.writeArrayToMemory(
      transform.col4.asUint8List().toJS, transform_structPtr + 96);
  final result = _lib._TransformManager_setTransform(
      tTransformManager.addr as Pointer<TTransformManager>,
      entityId,
      transform_structPtr.addr as Pointer<double4x4>);
  return result;
}

void TransformManager_transformToUnitCube(
  self.Pointer<TTransformManager> tTransformManager,
  DartEntityId entityId,
  DartAabb3 boundingBox,
) {
  final boundingBox_structPtr = _lib._stackAlloc<Aabb3>(24);
  _lib.setValue((boundingBox_structPtr.addr + 0) as Pointer,
      boundingBox.centerX.toJS, 'float');
  _lib.setValue((boundingBox_structPtr.addr + 4) as Pointer,
      boundingBox.centerY.toJS, 'float');
  _lib.setValue((boundingBox_structPtr.addr + 8) as Pointer,
      boundingBox.centerZ.toJS, 'float');
  _lib.setValue((boundingBox_structPtr.addr + 12) as Pointer,
      boundingBox.halfExtentX.toJS, 'float');
  _lib.setValue((boundingBox_structPtr.addr + 16) as Pointer,
      boundingBox.halfExtentY.toJS, 'float');
  _lib.setValue((boundingBox_structPtr.addr + 20) as Pointer,
      boundingBox.halfExtentZ.toJS, 'float');

  final result = _lib._TransformManager_transformToUnitCube(
      tTransformManager.addr as Pointer<TTransformManager>,
      entityId,
      boundingBox_structPtr.addr as Pointer<Aabb3>);
  return result;
}

void TransformManager_setParent(
  self.Pointer<TTransformManager> tTransformManager,
  DartEntityId child,
  DartEntityId parent,
  bool preserveScaling,
) {
  final result = _lib._TransformManager_setParent(
      tTransformManager.addr as Pointer<TTransformManager>,
      child,
      parent,
      preserveScaling);
  return result;
}

DartEntityId TransformManager_getParent(
  self.Pointer<TTransformManager> tTransformManager,
  DartEntityId child,
) {
  final result = _lib._TransformManager_getParent(
      tTransformManager.addr as Pointer<TTransformManager>, child);
  return result;
}

DartEntityId TransformManager_getAncestor(
  self.Pointer<TTransformManager> tTransformManager,
  DartEntityId childEntityId,
) {
  final result = _lib._TransformManager_getAncestor(
      tTransformManager.addr as Pointer<TTransformManager>, childEntityId);
  return result;
}

void Renderer_setClearOptions(
  self.Pointer<TRenderer> tRenderer,
  double clearR,
  double clearG,
  double clearB,
  double clearA,
  int clearStencil,
  bool clear,
  bool discard,
) {
  final result = _lib._Renderer_setClearOptions(
      tRenderer.addr as Pointer<TRenderer>,
      clearR,
      clearG,
      clearB,
      clearA,
      clearStencil,
      clear,
      discard);
  return result;
}

bool Renderer_beginFrame(
  self.Pointer<TRenderer> tRenderer,
  self.Pointer<TSwapChain> tSwapChain,
  int frameTimeInNanos,
) {
  final result = _lib._Renderer_beginFrame(tRenderer.addr as Pointer<TRenderer>,
      tSwapChain.addr as Pointer<TSwapChain>, frameTimeInNanos);
  return result;
}

void Renderer_endFrame(
  self.Pointer<TRenderer> tRenderer,
) {
  final result = _lib._Renderer_endFrame(tRenderer.addr as Pointer<TRenderer>);
  return result;
}

void Renderer_render(
  self.Pointer<TRenderer> tRenderer,
  self.Pointer<TView> tView,
) {
  final result = _lib._Renderer_render(
      tRenderer.addr as Pointer<TRenderer>, tView.addr as Pointer<TView>);
  return result;
}

void Renderer_renderStandaloneView(
  self.Pointer<TRenderer> tRenderer,
  self.Pointer<TView> tView,
) {
  final result = _lib._Renderer_renderStandaloneView(
      tRenderer.addr as Pointer<TRenderer>, tView.addr as Pointer<TView>);
  return result;
}

void Renderer_setFrameInterval(
  self.Pointer<TRenderer> tRenderer,
  double headRoomRatio,
  double scaleRate,
  int history,
  int interval,
) {
  final result = _lib._Renderer_setFrameInterval(
      tRenderer.addr as Pointer<TRenderer>,
      headRoomRatio,
      scaleRate,
      history,
      interval);
  return result;
}

self.Pointer<TRenderTicker> RenderTicker_create(
  self.Pointer<TRenderer> tRenderer,
) {
  final result =
      _lib._RenderTicker_create(tRenderer.addr as Pointer<TRenderer>);
  return result;
}

void RenderTicker_destroy(
  self.Pointer<TRenderTicker> tRenderTicker,
) {
  final result =
      _lib._RenderTicker_destroy(tRenderTicker.addr as Pointer<TRenderTicker>);
  return result;
}

void RenderTicker_addAnimationManager(
  self.Pointer<TRenderTicker> tRenderTicker,
  self.Pointer<TAnimationManager> tAnimationManager,
) {
  final result = _lib._RenderTicker_addAnimationManager(
      tRenderTicker.addr as Pointer<TRenderTicker>,
      tAnimationManager.addr as Pointer<TAnimationManager>);
  return result;
}

void RenderTicker_removeAnimationManager(
  self.Pointer<TRenderTicker> tRenderTicker,
  self.Pointer<TAnimationManager> tAnimationManager,
) {
  final result = _lib._RenderTicker_removeAnimationManager(
      tRenderTicker.addr as Pointer<TRenderTicker>,
      tAnimationManager.addr as Pointer<TAnimationManager>);
  return result;
}

void RenderTicker_render(
  self.Pointer<TRenderTicker> tRenderTicker,
  int frameTimeInNanos,
) {
  final result = _lib._RenderTicker_render(
      tRenderTicker.addr as Pointer<TRenderTicker>, frameTimeInNanos);
  return result;
}

void RenderTicker_setRenderable(
  self.Pointer<TRenderTicker> tRenderTicker,
  self.Pointer<TSwapChain> swapChain,
  self.Pointer<self.Pointer<TView>> views,
  int numViews,
) {
  final result = _lib._RenderTicker_setRenderable(
      tRenderTicker.addr as Pointer<TRenderTicker>,
      swapChain.addr as Pointer<TSwapChain>,
      views.addr as Pointer<self.Pointer<TView>>,
      numViews);
  return result;
}

void RenderThread_create() {
  final result = _lib._RenderThread_create();
  return result;
}

void RenderThread_destroy() {
  final result = _lib._RenderThread_destroy();
  return result;
}

void RenderThread_requestFrame(
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result =
      _lib._RenderThread_requestFrame(onComplete_interopFnPtr.cast());
  return result;
}

void RenderThread_setRenderTicker(
  self.Pointer<TRenderTicker> tRenderTicker,
) {
  final result = _lib._RenderThread_setRenderTicker(
      tRenderTicker.addr as Pointer<TRenderTicker>);
  return result;
}

void RenderThread_addTask(
  void Function() task,
) {
  void Function() task_internal = () {
    task();
  };
  final task_interopFnPtr = _lib.addFunction(task_internal.toJS, "v");

  final result = _lib._RenderThread_addTask(task_interopFnPtr.cast());
  return result;
}

void RenderTicker_renderRenderThread(
  self.Pointer<TRenderTicker> tRenderTicker,
  int frameTimeInNanos,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._RenderTicker_renderRenderThread(
      tRenderTicker.addr as Pointer<TRenderTicker>,
      frameTimeInNanos,
      onComplete_interopFnPtr.cast());
  return result;
}

void AnimationManager_createRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TScene> tScene,
  void Function(self.Pointer<TAnimationManager>) onComplete,
) {
  void Function(Pointer<TAnimationManager>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._AnimationManager_createRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tScene.addr as Pointer<TScene>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_createRenderThread(
  int backend,
  self.Pointer<Void> platform,
  self.Pointer<Void> sharedContext,
  int stereoscopicEyeCount,
  bool disableHandleUseAfterFreeCheck,
  Pointer onComplete,
) {
  // void Function(Pointer<TEngine>) onComplete_internal = (_internal) {
  //   onComplete(_internal);
  // };
  // final onComplete_interopFnPtr =
  //     _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Engine_createRenderThread(
      backend,
      platform.addr as Pointer<Void>,
      sharedContext.addr as Pointer<Void>,
      stereoscopicEyeCount,
      disableHandleUseAfterFreeCheck,
      onComplete.cast());
  return result;
}

void Engine_createRendererRenderThread(
  self.Pointer<TEngine> tEngine,
  void Function(self.Pointer<TRenderer>) onComplete,
) {
  void Function(Pointer<TRenderer>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Engine_createRendererRenderThread(
      tEngine.addr as Pointer<TEngine>, onComplete_interopFnPtr.cast());
  return result;
}

void Engine_createSwapChainRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<Void> window,
  int flags,
  void Function(self.Pointer<TSwapChain>) onComplete,
) {
  void Function(Pointer<TSwapChain>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Engine_createSwapChainRenderThread(
      tEngine.addr as Pointer<TEngine>,
      window.addr as Pointer<Void>,
      flags,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_createHeadlessSwapChainRenderThread(
  self.Pointer<TEngine> tEngine,
  int width,
  int height,
  int flags,
  void Function(self.Pointer<TSwapChain>) onComplete,
) {
  void Function(Pointer<TSwapChain>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Engine_createHeadlessSwapChainRenderThread(
      tEngine.addr as Pointer<TEngine>,
      width,
      height,
      flags,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_createCameraRenderThread(
  self.Pointer<TEngine> tEngine,
  void Function(self.Pointer<TCamera>) onComplete,
) {
  void Function(Pointer<TCamera>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Engine_createCameraRenderThread(
      tEngine.addr as Pointer<TEngine>, onComplete_interopFnPtr.cast());
  return result;
}

_NativeLibrary getLib() => _lib;

void Engine_createViewRenderThread(
    self.Pointer<TEngine> tEngine,
    // void Function(self.Pointer<TView>) onComplete,
    self.Pointer<NativeFunction<void Function(self.Pointer<TView>)>>
        onComplete) {
  // void Function(Pointer<TView>) onComplete_internal = (_internal) {
  //   onComplete(_internal);
  // };
  // final onComplete_interopFnPtr =
  //     _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Engine_createViewRenderThread(
      tEngine.addr as Pointer<TEngine>, onComplete.cast());
  return result;
}

void Engine_destroyRenderThread(
  self.Pointer<TEngine> tEngine,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroyRenderThread(
      tEngine.addr as Pointer<TEngine>, onComplete_interopFnPtr.cast());
  return result;
}

void Engine_destroySwapChainRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TSwapChain> tSwapChain,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroySwapChainRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tSwapChain.addr as Pointer<TSwapChain>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_destroyViewRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TView> tView,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroyViewRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tView.addr as Pointer<TView>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_destroySceneRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TScene> tScene,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroySceneRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tScene.addr as Pointer<TScene>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_destroyColorGradingRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TColorGrading> tColorGrading,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroyColorGradingRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tColorGrading.addr as Pointer<TColorGrading>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_destroyMaterialRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TMaterial> tMaterial,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroyMaterialRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tMaterial.addr as Pointer<TMaterial>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_destroyMaterialInstanceRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TMaterialInstance> tMaterialInstance,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroyMaterialInstanceRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tMaterialInstance.addr as Pointer<TMaterialInstance>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_destroySkyboxRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TSkybox> tSkybox,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroySkyboxRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tSkybox.addr as Pointer<TSkybox>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_destroyIndirectLightRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TIndirectLight> tIndirectLight,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroyIndirectLightRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tIndirectLight.addr as Pointer<TIndirectLight>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Texture_buildRenderThread(
  self.Pointer<TEngine> engine,
  int width,
  int height,
  int depth,
  int levels,
  int tUsage,
  int import1,
  TTextureSamplerType sampler,
  TTextureFormat format,
  void Function(self.Pointer<TTexture>) onComplete,
) {
  void Function(Pointer<TTexture>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Texture_buildRenderThread(
      engine.addr as Pointer<TEngine>,
      width,
      height,
      depth,
      levels,
      tUsage,
      import1,
      sampler.value,
      format.value,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_destroyTextureRenderThread(
  self.Pointer<TEngine> engine,
  self.Pointer<TTexture> tTexture,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroyTextureRenderThread(
      engine.addr as Pointer<TEngine>,
      tTexture.addr as Pointer<TTexture>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_createFenceRenderThread(
  self.Pointer<TEngine> tEngine,
  void Function(self.Pointer<TFence>) onComplete,
) {
  void Function(Pointer<TFence>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Engine_createFenceRenderThread(
      tEngine.addr as Pointer<TEngine>, onComplete_interopFnPtr.cast());
  return result;
}

void Engine_destroyFenceRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TFence> tFence,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_destroyFenceRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tFence.addr as Pointer<TFence>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Engine_flushAndWaitRenderThead(
  self.Pointer<TEngine> tEngine,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Engine_flushAndWaitRenderThead(
      tEngine.addr as Pointer<TEngine>, onComplete_interopFnPtr.cast());
  return result;
}

void Renderer_setClearOptionsRenderThread(
  self.Pointer<TRenderer> tRenderer,
  double clearR,
  double clearG,
  double clearB,
  double clearA,
  int clearStencil,
  bool clear,
  bool discard,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Renderer_setClearOptionsRenderThread(
      tRenderer.addr as Pointer<TRenderer>,
      clearR,
      clearG,
      clearB,
      clearA,
      clearStencil,
      clear,
      discard,
      onComplete_interopFnPtr.cast());
  return result;
}

void Renderer_beginFrameRenderThread(
  self.Pointer<TRenderer> tRenderer,
  self.Pointer<TSwapChain> tSwapChain,
  int frameTimeInNanos,
  void Function(bool) onComplete,
) {
  void Function(bool) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vi");

  final result = _lib._Renderer_beginFrameRenderThread(
      tRenderer.addr as Pointer<TRenderer>,
      tSwapChain.addr as Pointer<TSwapChain>,
      frameTimeInNanos,
      onComplete_interopFnPtr.cast());
  return result;
}

void Renderer_endFrameRenderThread(
  self.Pointer<TRenderer> tRenderer,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Renderer_endFrameRenderThread(
      tRenderer.addr as Pointer<TRenderer>, onComplete_interopFnPtr.cast());
  return result;
}

void Renderer_renderRenderThread(
  self.Pointer<TRenderer> tRenderer,
  self.Pointer<TView> tView,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Renderer_renderRenderThread(
      tRenderer.addr as Pointer<TRenderer>,
      tView.addr as Pointer<TView>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Renderer_renderStandaloneViewRenderThread(
  self.Pointer<TRenderer> tRenderer,
  self.Pointer<TView> tView,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Renderer_renderStandaloneViewRenderThread(
      tRenderer.addr as Pointer<TRenderer>,
      tView.addr as Pointer<TView>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Material_createInstanceRenderThread(
  self.Pointer<TMaterial> tMaterial,
  void Function(self.Pointer<TMaterialInstance>) onComplete,
) {
  void Function(Pointer<TMaterialInstance>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Material_createInstanceRenderThread(
      tMaterial.addr as Pointer<TMaterial>, onComplete_interopFnPtr.cast());
  return result;
}

void Material_createImageMaterialRenderThread(
  self.Pointer<TEngine> tEngine,
  void Function(self.Pointer<TMaterial>) onComplete,
) {
  void Function(Pointer<TMaterial>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Material_createImageMaterialRenderThread(
      tEngine.addr as Pointer<TEngine>, onComplete_interopFnPtr.cast());
  return result;
}

void Material_createGizmoMaterialRenderThread(
  self.Pointer<TEngine> tEngine,
  void Function(self.Pointer<TMaterial>) onComplete,
) {
  void Function(Pointer<TMaterial>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Material_createGizmoMaterialRenderThread(
      tEngine.addr as Pointer<TEngine>, onComplete_interopFnPtr.cast());
  return result;
}

void ColorGrading_createRenderThread(
  self.Pointer<TEngine> tEngine,
  TToneMapping toneMapping,
  void Function(self.Pointer<TColorGrading>) callback,
) {
  void Function(Pointer<TColorGrading>) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vp");

  final result = _lib._ColorGrading_createRenderThread(
      tEngine.addr as Pointer<TEngine>,
      toneMapping.value,
      callback_interopFnPtr.cast());
  return result;
}

void View_setColorGradingRenderThread(
  self.Pointer<TView> tView,
  self.Pointer<TColorGrading> tColorGrading,
  void Function() callback,
) {
  void Function() callback_internal = () {
    callback();
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "v");

  final result = _lib._View_setColorGradingRenderThread(
      tView.addr as Pointer<TView>,
      tColorGrading.addr as Pointer<TColorGrading>,
      callback_interopFnPtr.cast());
  return result;
}

void View_setBloomRenderThread(
  self.Pointer<TView> tView,
  bool enabled,
  double strength,
  void Function() callback,
) {
  void Function() callback_internal = () {
    callback();
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "v");

  final result = _lib._View_setBloomRenderThread(tView.addr as Pointer<TView>,
      enabled, strength, callback_interopFnPtr.cast());
  return result;
}

void View_setCameraRenderThread(
  self.Pointer<TView> tView,
  self.Pointer<TCamera> tCamera,
  void Function() callback,
) {
  void Function() callback_internal = () {
    callback();
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "v");

  final result = _lib._View_setCameraRenderThread(tView.addr as Pointer<TView>,
      tCamera.addr as Pointer<TCamera>, callback_interopFnPtr.cast());
  return result;
}

DartFilamentRenderCallback make_render_callback_fn_pointer(
  DartFilamentRenderCallback arg0,
) {
  final result = _lib._make_render_callback_fn_pointer(arg0.addr
      as Pointer<self.NativeFunction<FilamentRenderCallbackFunction>>);
  return result;
}

void SceneAsset_destroyRenderThread(
  self.Pointer<TSceneAsset> tSceneAsset,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._SceneAsset_destroyRenderThread(
      tSceneAsset.addr as Pointer<TSceneAsset>, onComplete_interopFnPtr.cast());
  return result;
}

void SceneAsset_createFromFilamentAssetRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TGltfAssetLoader> tAssetLoader,
  self.Pointer<TNameComponentManager> tNameComponentManager,
  self.Pointer<TFilamentAsset> tFilamentAsset,
  void Function(self.Pointer<TSceneAsset>) onComplete,
) {
  void Function(Pointer<TSceneAsset>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._SceneAsset_createFromFilamentAssetRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tAssetLoader.addr as Pointer<TGltfAssetLoader>,
      tNameComponentManager.addr as Pointer<TNameComponentManager>,
      tFilamentAsset.addr as Pointer<TFilamentAsset>,
      onComplete_interopFnPtr.cast());
  return result;
}

void SceneAsset_createInstanceRenderThread(
  self.Pointer<TSceneAsset> asset,
  self.Pointer<self.Pointer<TMaterialInstance>> tMaterialInstances,
  int materialInstanceCount,
  void Function(self.Pointer<TSceneAsset>) callback,
) {
  void Function(Pointer<TSceneAsset>) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vp");

  final result = _lib._SceneAsset_createInstanceRenderThread(
      asset.addr as Pointer<TSceneAsset>,
      tMaterialInstances.addr as Pointer<self.Pointer<TMaterialInstance>>,
      materialInstanceCount,
      callback_interopFnPtr.cast());
  return result;
}

void SceneAsset_createGeometryRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<Float32> vertices,
  int numVertices,
  self.Pointer<Float32> normals,
  int numNormals,
  self.Pointer<Float32> uvs,
  int numUvs,
  self.Pointer<Int32> indices,
  int numIndices,
  TPrimitiveType tPrimitiveType,
  self.Pointer<self.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
  void Function(self.Pointer<TSceneAsset>) callback,
) {
  void Function(Pointer<TSceneAsset>) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vp");

  final result = _lib._SceneAsset_createGeometryRenderThread(
      tEngine.addr as Pointer<TEngine>,
      vertices.addr as Pointer<Float32>,
      numVertices,
      normals.addr as Pointer<Float32>,
      numNormals,
      uvs.addr as Pointer<Float32>,
      numUvs,
      indices.addr as Pointer<Int32>,
      numIndices,
      tPrimitiveType.value,
      materialInstances.addr as Pointer<self.Pointer<TMaterialInstance>>,
      materialInstanceCount,
      callback_interopFnPtr.cast());
  return result;
}

void MaterialProvider_createMaterialInstanceRenderThread(
  self.Pointer<TMaterialProvider> tMaterialProvider,
  self.Pointer<TMaterialKey> tKey,
  void Function(self.Pointer<TMaterialInstance>) callback,
) {
  void Function(Pointer<TMaterialInstance>) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vp");

  final result = _lib._MaterialProvider_createMaterialInstanceRenderThread(
      tMaterialProvider.addr as Pointer<TMaterialProvider>,
      tKey.addr as Pointer<TMaterialKey>,
      callback_interopFnPtr.cast());
  return result;
}

void AnimationManager_updateBoneMatricesRenderThread(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  void Function(bool) callback,
) {
  void Function(bool) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vi");

  final result = _lib._AnimationManager_updateBoneMatricesRenderThread(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      callback_interopFnPtr.cast());
  return result;
}

void AnimationManager_setMorphTargetWeightsRenderThread(
  self.Pointer<TAnimationManager> tAnimationManager,
  DartEntityId entityId,
  self.Pointer<Float32> morphData,
  int numWeights,
  void Function(bool) callback,
) {
  void Function(bool) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vi");

  final result = _lib._AnimationManager_setMorphTargetWeightsRenderThread(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      entityId,
      morphData.addr as Pointer<Float32>,
      numWeights,
      callback_interopFnPtr.cast());
  return result;
}

void Image_createEmptyRenderThread(
  int width,
  int height,
  int channel,
  void Function(self.Pointer<TLinearImage>) onComplete,
) {
  void Function(Pointer<TLinearImage>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Image_createEmptyRenderThread(
      width, height, channel, onComplete_interopFnPtr.cast());
  return result;
}

void Image_getBytesRenderThread(
  self.Pointer<TLinearImage> tLinearImage,
  void Function(self.Pointer<Float32>) onComplete,
) {
  void Function(Pointer<Float32>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._Image_getBytesRenderThread(
      tLinearImage.addr as Pointer<TLinearImage>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Image_destroyRenderThread(
  self.Pointer<TLinearImage> tLinearImage,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._Image_destroyRenderThread(
      tLinearImage.addr as Pointer<TLinearImage>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Image_getWidthRenderThread(
  self.Pointer<TLinearImage> tLinearImage,
  void Function(int) onComplete,
) {
  void Function(int) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vi");

  final result = _lib._Image_getWidthRenderThread(
      tLinearImage.addr as Pointer<TLinearImage>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Image_getHeightRenderThread(
  self.Pointer<TLinearImage> tLinearImage,
  void Function(int) onComplete,
) {
  void Function(int) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vi");

  final result = _lib._Image_getHeightRenderThread(
      tLinearImage.addr as Pointer<TLinearImage>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Image_getChannelsRenderThread(
  self.Pointer<TLinearImage> tLinearImage,
  void Function(int) onComplete,
) {
  void Function(int) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vi");

  final result = _lib._Image_getChannelsRenderThread(
      tLinearImage.addr as Pointer<TLinearImage>,
      onComplete_interopFnPtr.cast());
  return result;
}

void Texture_loadImageRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TTexture> tTexture,
  self.Pointer<TLinearImage> tImage,
  TPixelDataFormat bufferFormat,
  TPixelDataType pixelDataType,
  void Function(bool) onComplete,
) {
  void Function(bool) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vi");

  final result = _lib._Texture_loadImageRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tTexture.addr as Pointer<TTexture>,
      tImage.addr as Pointer<TLinearImage>,
      bufferFormat.value,
      pixelDataType.value,
      onComplete_interopFnPtr.cast());
  return result;
}

void RenderTarget_getColorTextureRenderThread(
  self.Pointer<TRenderTarget> tRenderTarget,
  void Function(self.Pointer<TTexture>) onComplete,
) {
  void Function(Pointer<TTexture>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._RenderTarget_getColorTextureRenderThread(
      tRenderTarget.addr as Pointer<TRenderTarget>,
      onComplete_interopFnPtr.cast());
  return result;
}

void RenderTarget_createRenderThread(
  self.Pointer<TEngine> tEngine,
  int width,
  int height,
  self.Pointer<TTexture> color,
  self.Pointer<TTexture> depth,
  void Function(self.Pointer<TRenderTarget>) onComplete,
) {
  void Function(Pointer<TRenderTarget>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._RenderTarget_createRenderThread(
      tEngine.addr as Pointer<TEngine>,
      width,
      height,
      color.addr as Pointer<TTexture>,
      depth.addr as Pointer<TTexture>,
      onComplete_interopFnPtr.cast());
  return result;
}

void RenderTarget_destroyRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TRenderTarget> tRenderTarget,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._RenderTarget_destroyRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tRenderTarget.addr as Pointer<TRenderTarget>,
      onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_createRenderThread(
  void Function(self.Pointer<TTextureSampler>) onComplete,
) {
  void Function(Pointer<TTextureSampler>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result =
      _lib._TextureSampler_createRenderThread(onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_createWithFilteringRenderThread(
  TSamplerMinFilter minFilter,
  TSamplerMagFilter magFilter,
  TSamplerWrapMode wrapS,
  TSamplerWrapMode wrapT,
  TSamplerWrapMode wrapR,
  void Function(self.Pointer<TTextureSampler>) onComplete,
) {
  void Function(Pointer<TTextureSampler>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._TextureSampler_createWithFilteringRenderThread(
      minFilter.value,
      magFilter.value,
      wrapS.value,
      wrapT.value,
      wrapR.value,
      onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_createWithComparisonRenderThread(
  TSamplerCompareMode compareMode,
  TSamplerCompareFunc compareFunc,
  void Function(self.Pointer<TTextureSampler>) onComplete,
) {
  void Function(Pointer<TTextureSampler>) onComplete_internal = (_internal) {
    onComplete(_internal);
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "vp");

  final result = _lib._TextureSampler_createWithComparisonRenderThread(
      compareMode.value, compareFunc.value, onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_setMinFilterRenderThread(
  self.Pointer<TTextureSampler> sampler,
  TSamplerMinFilter filter,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._TextureSampler_setMinFilterRenderThread(
      sampler.addr as Pointer<TTextureSampler>,
      filter.value,
      onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_setMagFilterRenderThread(
  self.Pointer<TTextureSampler> sampler,
  TSamplerMagFilter filter,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._TextureSampler_setMagFilterRenderThread(
      sampler.addr as Pointer<TTextureSampler>,
      filter.value,
      onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_setWrapModeSRenderThread(
  self.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._TextureSampler_setWrapModeSRenderThread(
      sampler.addr as Pointer<TTextureSampler>,
      mode.value,
      onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_setWrapModeTRenderThread(
  self.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._TextureSampler_setWrapModeTRenderThread(
      sampler.addr as Pointer<TTextureSampler>,
      mode.value,
      onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_setWrapModeRRenderThread(
  self.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._TextureSampler_setWrapModeRRenderThread(
      sampler.addr as Pointer<TTextureSampler>,
      mode.value,
      onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_setAnisotropyRenderThread(
  self.Pointer<TTextureSampler> sampler,
  double anisotropy,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._TextureSampler_setAnisotropyRenderThread(
      sampler.addr as Pointer<TTextureSampler>,
      anisotropy,
      onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_setCompareModeRenderThread(
  self.Pointer<TTextureSampler> sampler,
  TSamplerCompareMode mode,
  TSamplerCompareFunc func,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._TextureSampler_setCompareModeRenderThread(
      sampler.addr as Pointer<TTextureSampler>,
      mode.value,
      func.value,
      onComplete_interopFnPtr.cast());
  return result;
}

void TextureSampler_destroyRenderThread(
  self.Pointer<TTextureSampler> sampler,
  void Function() onComplete,
) {
  void Function() onComplete_internal = () {
    onComplete();
  };
  final onComplete_interopFnPtr =
      _lib.addFunction(onComplete_internal.toJS, "v");

  final result = _lib._TextureSampler_destroyRenderThread(
      sampler.addr as Pointer<TTextureSampler>, onComplete_interopFnPtr.cast());
  return result;
}

void AnimationManager_setBoneTransformRenderThread(
  self.Pointer<TAnimationManager> tAnimationManager,
  DartEntityId asset,
  int skinIndex,
  int boneIndex,
  self.Pointer<Float32> transform,
  void Function(bool) callback,
) {
  void Function(bool) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vi");

  final result = _lib._AnimationManager_setBoneTransformRenderThread(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      asset,
      skinIndex,
      boneIndex,
      transform.addr as Pointer<Float32>,
      callback_interopFnPtr.cast());
  return result;
}

void AnimationManager_resetToRestPoseRenderThread(
  self.Pointer<TAnimationManager> tAnimationManager,
  DartEntityId entityId,
  void Function() callback,
) {
  void Function() callback_internal = () {
    callback();
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "v");

  final result = _lib._AnimationManager_resetToRestPoseRenderThread(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      entityId,
      callback_interopFnPtr.cast());
  return result;
}

void GltfAssetLoader_createRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TMaterialProvider> tMaterialProvider,
  void Function(self.Pointer<TGltfAssetLoader>) callback,
) {
  void Function(Pointer<TGltfAssetLoader>) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vp");

  final result = _lib._GltfAssetLoader_createRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tMaterialProvider.addr as Pointer<TMaterialProvider>,
      callback_interopFnPtr.cast());
  return result;
}

void GltfResourceLoader_createRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<Char> relativeResourcePath,
  void Function(self.Pointer<TGltfResourceLoader>) callback,
) {
  void Function(Pointer<TGltfResourceLoader>) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vp");

  final result = _lib._GltfResourceLoader_createRenderThread(
      tEngine.addr as Pointer<TEngine>,
      relativeResourcePath.addr as Pointer<Char>,
      callback_interopFnPtr.cast());
  return result;
}

void GltfResourceLoader_destroyRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TGltfResourceLoader> tResourceLoader,
  void Function() callback,
) {
  void Function() callback_internal = () {
    callback();
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "v");

  final result = _lib._GltfResourceLoader_destroyRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tResourceLoader.addr as Pointer<TGltfResourceLoader>,
      callback_interopFnPtr.cast());
  return result;
}

void GltfResourceLoader_loadResourcesRenderThread(
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  self.Pointer<TFilamentAsset> tFilamentAsset,
  void Function(bool) callback,
) {
  void Function(bool) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vi");

  final result = _lib._GltfResourceLoader_loadResourcesRenderThread(
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>,
      tFilamentAsset.addr as Pointer<TFilamentAsset>,
      callback_interopFnPtr.cast());
  return result;
}

void GltfResourceLoader_asyncBeginLoadRenderThread(
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  self.Pointer<TFilamentAsset> tFilamentAsset,
  void Function(bool) callback,
) {
  void Function(bool) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vi");

  final result = _lib._GltfResourceLoader_asyncBeginLoadRenderThread(
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>,
      tFilamentAsset.addr as Pointer<TFilamentAsset>,
      callback_interopFnPtr.cast());
  return result;
}

void GltfResourceLoader_asyncUpdateLoadRenderThread(
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
) {
  final result = _lib._GltfResourceLoader_asyncUpdateLoadRenderThread(
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>);
  return result;
}

void GltfResourceLoader_asyncGetLoadProgressRenderThread(
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  void Function(double) callback,
) {
  void Function(double) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vf");

  final result = _lib._GltfResourceLoader_asyncGetLoadProgressRenderThread(
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>,
      callback_interopFnPtr.cast());
  return result;
}

void Scene_addFilamentAssetRenderThread(
  self.Pointer<TScene> tScene,
  self.Pointer<TFilamentAsset> tAsset,
  void Function() callback,
) {
  void Function() callback_internal = () {
    callback();
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "v");

  final result = _lib._Scene_addFilamentAssetRenderThread(
      tScene.addr as Pointer<TScene>,
      tAsset.addr as Pointer<TFilamentAsset>,
      callback_interopFnPtr.cast());
  return result;
}

void Gizmo_createRenderThread(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TGltfAssetLoader> tAssetLoader,
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  self.Pointer<TNameComponentManager> tNameComponentManager,
  self.Pointer<TView> tView,
  self.Pointer<TMaterial> tMaterial,
  TGizmoType tGizmoType,
  void Function(self.Pointer<TGizmo>) callback,
) {
  void Function(Pointer<TGizmo>) callback_internal = (_internal) {
    callback(_internal);
  };
  final callback_interopFnPtr = _lib.addFunction(callback_internal.toJS, "vp");

  final result = _lib._Gizmo_createRenderThread(
      tEngine.addr as Pointer<TEngine>,
      tAssetLoader.addr as Pointer<TGltfAssetLoader>,
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>,
      tNameComponentManager.addr as Pointer<TNameComponentManager>,
      tView.addr as Pointer<TView>,
      tMaterial.addr as Pointer<TMaterial>,
      tGizmoType.value,
      callback_interopFnPtr.cast());
  return result;
}

self.Pointer<TGltfResourceLoader> GltfResourceLoader_create(
  self.Pointer<TEngine> tEngine,
  self.Pointer<Char> relativeResourcePath,
) {
  final result = _lib._GltfResourceLoader_create(
      tEngine.addr as Pointer<TEngine>,
      relativeResourcePath.addr as Pointer<Char>);
  return result;
}

void GltfResourceLoader_destroy(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
) {
  final result = _lib._GltfResourceLoader_destroy(
      tEngine.addr as Pointer<TEngine>,
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>);
  return result;
}

bool GltfResourceLoader_asyncBeginLoad(
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  self.Pointer<TFilamentAsset> tFilamentAsset,
) {
  final result = _lib._GltfResourceLoader_asyncBeginLoad(
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>,
      tFilamentAsset.addr as Pointer<TFilamentAsset>);
  return result;
}

void GltfResourceLoader_asyncUpdateLoad(
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
) {
  final result = _lib._GltfResourceLoader_asyncUpdateLoad(
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>);
  return result;
}

double GltfResourceLoader_asyncGetLoadProgress(
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
) {
  final result = _lib._GltfResourceLoader_asyncGetLoadProgress(
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>);
  return result;
}

bool GltfResourceLoader_loadResources(
  self.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  self.Pointer<TFilamentAsset> tFilamentAsset,
) {
  final result = _lib._GltfResourceLoader_loadResources(
      tGltfResourceLoader.addr as Pointer<TGltfResourceLoader>,
      tFilamentAsset.addr as Pointer<TFilamentAsset>);
  return result;
}

void RenderableManager_setMaterialInstanceAt(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
  int primitiveIndex,
  self.Pointer<TMaterialInstance> tMaterialInstance,
) {
  final result = _lib._RenderableManager_setMaterialInstanceAt(
      tRenderableManager.addr as Pointer<TRenderableManager>,
      entityId,
      primitiveIndex,
      tMaterialInstance.addr as Pointer<TMaterialInstance>);
  return result;
}

self.Pointer<TMaterialInstance> RenderableManager_getMaterialInstanceAt(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
  int primitiveIndex,
) {
  final result = _lib._RenderableManager_getMaterialInstanceAt(
      tRenderableManager.addr as Pointer<TRenderableManager>,
      entityId,
      primitiveIndex);
  return result;
}

bool RenderableManager_isRenderable(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
) {
  final result = _lib._RenderableManager_isRenderable(
      tRenderableManager.addr as Pointer<TRenderableManager>, entityId);
  return result;
}

bool RenderableManager_hasComponent(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
) {
  final result = _lib._RenderableManager_hasComponent(
      tRenderableManager.addr as Pointer<TRenderableManager>, entityId);
  return result;
}

bool RenderableManager_empty(
  self.Pointer<TRenderableManager> tRenderableManager,
) {
  final result = _lib._RenderableManager_empty(
      tRenderableManager.addr as Pointer<TRenderableManager>);
  return result;
}

bool RenderableManager_getLightChannel(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
  int channel,
) {
  final result = _lib._RenderableManager_getLightChannel(
      tRenderableManager.addr as Pointer<TRenderableManager>,
      entityId,
      channel);
  return result;
}

bool RenderableManager_isShadowCaster(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
) {
  final result = _lib._RenderableManager_isShadowCaster(
      tRenderableManager.addr as Pointer<TRenderableManager>, entityId);
  return result;
}

void RenderableManager_setCastShadows(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
  bool castShadows,
) {
  final result = _lib._RenderableManager_setCastShadows(
      tRenderableManager.addr as Pointer<TRenderableManager>,
      entityId,
      castShadows);
  return result;
}

void RenderableManager_setReceiveShadows(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
  bool receiveShadows,
) {
  final result = _lib._RenderableManager_setReceiveShadows(
      tRenderableManager.addr as Pointer<TRenderableManager>,
      entityId,
      receiveShadows);
  return result;
}

bool RenderableManager_isShadowReceiver(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
) {
  final result = _lib._RenderableManager_isShadowReceiver(
      tRenderableManager.addr as Pointer<TRenderableManager>, entityId);
  return result;
}

bool RenderableManager_getFogEnabled(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
) {
  final result = _lib._RenderableManager_getFogEnabled(
      tRenderableManager.addr as Pointer<TRenderableManager>, entityId);
  return result;
}

DartAabb3 RenderableManager_getAabb(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
) {
  final Aabb3_out = Aabb3.stackAlloc();
  final result = _lib._RenderableManager_getAabb(
      Aabb3_out.addr as Pointer<Aabb3>,
      tRenderableManager.addr as Pointer<TRenderableManager>,
      entityId);
  return Aabb3_out.toDart();
}

void RenderableManager_setVisibilityLayer(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
  int layer,
) {
  final result = _lib._RenderableManager_setVisibilityLayer(
      tRenderableManager.addr as Pointer<TRenderableManager>, entityId, layer);
  return result;
}

void RenderableManager_setPriority(
  self.Pointer<TRenderableManager> tRenderableManager,
  DartEntityId entityId,
  int priority,
) {
  final result = _lib._RenderableManager_setPriority(
      tRenderableManager.addr as Pointer<TRenderableManager>,
      entityId,
      priority);
  return result;
}

self.Pointer<TEngine> Engine_create(
  TBackend backend,
  self.Pointer<Void> platform,
  self.Pointer<Void> sharedContext,
  int stereoscopicEyeCount,
  bool disableHandleUseAfterFreeCheck,
) {
  final result = _lib._Engine_create(
      backend.value,
      platform.addr as Pointer<Void>,
      sharedContext.addr as Pointer<Void>,
      stereoscopicEyeCount,
      disableHandleUseAfterFreeCheck);
  return result;
}

void Engine_destroy(
  self.Pointer<TEngine> tEngine,
) {
  final result = _lib._Engine_destroy(tEngine.addr as Pointer<TEngine>);
  return result;
}

self.Pointer<TRenderer> Engine_createRenderer(
  self.Pointer<TEngine> tEngine,
) {
  final result = _lib._Engine_createRenderer(tEngine.addr as Pointer<TEngine>);
  return result;
}

self.Pointer<TSwapChain> Engine_createSwapChain(
  self.Pointer<TEngine> tEngine,
  self.Pointer<Void> window,
  int flags,
) {
  final result = _lib._Engine_createSwapChain(
      tEngine.addr as Pointer<TEngine>, window.addr as Pointer<Void>, flags);
  return result;
}

self.Pointer<TSwapChain> Engine_createHeadlessSwapChain(
  self.Pointer<TEngine> tEngine,
  int width,
  int height,
  int flags,
) {
  final result = _lib._Engine_createHeadlessSwapChain(
      tEngine.addr as Pointer<TEngine>, width, height, flags);
  return result;
}

void Engine_destroySwapChain(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TSwapChain> tSwapChain,
) {
  final result = _lib._Engine_destroySwapChain(
      tEngine.addr as Pointer<TEngine>, tSwapChain.addr as Pointer<TSwapChain>);
  return result;
}

void Engine_destroyView(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TView> tView,
) {
  final result = _lib._Engine_destroyView(
      tEngine.addr as Pointer<TEngine>, tView.addr as Pointer<TView>);
  return result;
}

void Engine_destroyScene(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TScene> tScene,
) {
  final result = _lib._Engine_destroyScene(
      tEngine.addr as Pointer<TEngine>, tScene.addr as Pointer<TScene>);
  return result;
}

void Engine_destroyColorGrading(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TColorGrading> tColorGrading,
) {
  final result = _lib._Engine_destroyColorGrading(
      tEngine.addr as Pointer<TEngine>,
      tColorGrading.addr as Pointer<TColorGrading>);
  return result;
}

self.Pointer<TCamera> Engine_createCamera(
  self.Pointer<TEngine> tEngine,
) {
  final result = _lib._Engine_createCamera(tEngine.addr as Pointer<TEngine>);
  return result;
}

void Engine_destroyCamera(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TCamera> tCamera,
) {
  final result = _lib._Engine_destroyCamera(
      tEngine.addr as Pointer<TEngine>, tCamera.addr as Pointer<TCamera>);
  return result;
}

self.Pointer<TView> Engine_createView(
  self.Pointer<TEngine> tEngine,
) {
  final result = _lib._Engine_createView(tEngine.addr as Pointer<TEngine>);
  return result;
}

self.Pointer<TCamera> Engine_getCameraComponent(
  self.Pointer<TEngine> tEngine,
  DartEntityId entityId,
) {
  final result = _lib._Engine_getCameraComponent(
      tEngine.addr as Pointer<TEngine>, entityId);
  return result;
}

self.Pointer<TTransformManager> Engine_getTransformManager(
  self.Pointer<TEngine> engine,
) {
  final result =
      _lib._Engine_getTransformManager(engine.addr as Pointer<TEngine>);
  return result;
}

self.Pointer<TRenderableManager> Engine_getRenderableManager(
  self.Pointer<TEngine> engine,
) {
  final result =
      _lib._Engine_getRenderableManager(engine.addr as Pointer<TEngine>);
  return result;
}

self.Pointer<TLightManager> Engine_getLightManager(
  self.Pointer<TEngine> engine,
) {
  final result = _lib._Engine_getLightManager(engine.addr as Pointer<TEngine>);
  return result;
}

self.Pointer<TEntityManager> Engine_getEntityManager(
  self.Pointer<TEngine> engine,
) {
  final result = _lib._Engine_getEntityManager(engine.addr as Pointer<TEngine>);
  return result;
}

void Engine_destroyTexture(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TTexture> tTexture,
) {
  final result = _lib._Engine_destroyTexture(
      tEngine.addr as Pointer<TEngine>, tTexture.addr as Pointer<TTexture>);
  return result;
}

self.Pointer<TFence> Engine_createFence(
  self.Pointer<TEngine> tEngine,
) {
  final result = _lib._Engine_createFence(tEngine.addr as Pointer<TEngine>);
  return result;
}

void Engine_destroyFence(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TFence> tFence,
) {
  final result = _lib._Engine_destroyFence(
      tEngine.addr as Pointer<TEngine>, tFence.addr as Pointer<TFence>);
  return result;
}

void Engine_flushAndWait(
  self.Pointer<TEngine> tEngine,
) {
  final result = _lib._Engine_flushAndWait(tEngine.addr as Pointer<TEngine>);
  return result;
}

void Engine_destroyMaterial(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TMaterial> tMaterial,
) {
  final result = _lib._Engine_destroyMaterial(
      tEngine.addr as Pointer<TEngine>, tMaterial.addr as Pointer<TMaterial>);
  return result;
}

void Engine_destroyMaterialInstance(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TMaterialInstance> tMaterialInstance,
) {
  final result = _lib._Engine_destroyMaterialInstance(
      tEngine.addr as Pointer<TEngine>,
      tMaterialInstance.addr as Pointer<TMaterialInstance>);
  return result;
}

self.Pointer<TScene> Engine_createScene(
  self.Pointer<TEngine> tEngine,
) {
  final result = _lib._Engine_createScene(tEngine.addr as Pointer<TEngine>);
  return result;
}

void Engine_destroySkybox(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TSkybox> tSkybox,
) {
  final result = _lib._Engine_destroySkybox(
      tEngine.addr as Pointer<TEngine>, tSkybox.addr as Pointer<TSkybox>);
  return result;
}

void Engine_destroyIndirectLight(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TIndirectLight> tIndirectLight,
) {
  final result = _lib._Engine_destroyIndirectLight(
      tEngine.addr as Pointer<TEngine>,
      tIndirectLight.addr as Pointer<TIndirectLight>);
  return result;
}

int int_foo(
  int bar,
) {
  final result = _lib._int_foo(bar);
  return result;
}

self.Pointer<Char> string_foo(
  self.Pointer<Char> bar,
) {
  final result = _lib._string_foo(bar.addr as Pointer<Char>);
  return result;
}

int sum(
  int a,
  int b,
) {
  final result = _lib._sum(a, b);
  return result;
}

int subtract(
  self.Pointer<Int32> a,
  int b,
) {
  final result = _lib._subtract(a.addr as Pointer<Int32>, b);
  return result;
}

self.Pointer<Float64> dividePrecision(
  self.Pointer<Float64> a,
  self.Pointer<Float64> b,
) {
  final result = _lib._dividePrecision(
      a.addr as Pointer<Float64>, b.addr as Pointer<Float64>);
  return result;
}

DartFoo getfoo() {
  final Foo_out = Foo.stackAlloc();
  final result = _lib._getfoo(Foo_out.addr as Pointer<Foo>);
  return Foo_out.toDart();
}

void setfoo(
  DartFoo foo,
) {
  final foo_structPtr = _lib._stackAlloc<Foo>(8);
  _lib.setValue((foo_structPtr.addr + 0) as Pointer, foo.a.toJS, 'i32');
  _lib.setValue((foo_structPtr.addr + 4) as Pointer, foo.b.toJS, 'i32');

  final result = _lib._setfoo(foo_structPtr.addr as Pointer<Foo>);
  return result;
}

void invoke_Fn(
  void Function(int) fn,
) {
  void Function(int) fn_internal = (_internal) {
    fn(_internal);
  };
  final fn_interopFnPtr = _lib.addFunction(fn_internal.toJS, "vi");

  final result = _lib._invoke_Fn(fn_interopFnPtr.cast());
  return result;
}

self.Pointer<TSceneAsset> SceneAsset_createGeometry(
  self.Pointer<TEngine> tEngine,
  self.Pointer<Float32> vertices,
  int numVertices,
  self.Pointer<Float32> normals,
  int numNormals,
  self.Pointer<Float32> uvs,
  int numUvs,
  self.Pointer<Int32> indices,
  int numIndices,
  TPrimitiveType tPrimitiveType,
  self.Pointer<self.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
) {
  final result = _lib._SceneAsset_createGeometry(
      tEngine.addr as Pointer<TEngine>,
      vertices.addr as Pointer<Float32>,
      numVertices,
      normals.addr as Pointer<Float32>,
      numNormals,
      uvs.addr as Pointer<Float32>,
      numUvs,
      indices.addr as Pointer<Int32>,
      numIndices,
      tPrimitiveType.value,
      materialInstances.addr as Pointer<self.Pointer<TMaterialInstance>>,
      materialInstanceCount);
  return result;
}

self.Pointer<TSceneAsset> SceneAsset_createFromFilamentAsset(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TGltfAssetLoader> tAssetLoader,
  self.Pointer<TNameComponentManager> tNameComponentManager,
  self.Pointer<TFilamentAsset> tFilamentAsset,
) {
  final result = _lib._SceneAsset_createFromFilamentAsset(
      tEngine.addr as Pointer<TEngine>,
      tAssetLoader.addr as Pointer<TGltfAssetLoader>,
      tNameComponentManager.addr as Pointer<TNameComponentManager>,
      tFilamentAsset.addr as Pointer<TFilamentAsset>);
  return result;
}

self.Pointer<TFilamentAsset> SceneAsset_getFilamentAsset(
  self.Pointer<TSceneAsset> tSceneAsset,
) {
  final result = _lib._SceneAsset_getFilamentAsset(
      tSceneAsset.addr as Pointer<TSceneAsset>);
  return result;
}

self.Pointer<TSceneAsset> SceneAsset_createGrid(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TMaterial> tMaterial,
) {
  final result = _lib._SceneAsset_createGrid(
      tEngine.addr as Pointer<TEngine>, tMaterial.addr as Pointer<TMaterial>);
  return result;
}

void SceneAsset_destroy(
  self.Pointer<TSceneAsset> tSceneAsset,
) {
  final result =
      _lib._SceneAsset_destroy(tSceneAsset.addr as Pointer<TSceneAsset>);
  return result;
}

void SceneAsset_addToScene(
  self.Pointer<TSceneAsset> tSceneAsset,
  self.Pointer<TScene> tScene,
) {
  final result = _lib._SceneAsset_addToScene(
      tSceneAsset.addr as Pointer<TSceneAsset>, tScene.addr as Pointer<TScene>);
  return result;
}

void SceneAsset_removeFromScene(
  self.Pointer<TSceneAsset> tSceneAsset,
  self.Pointer<TScene> tScene,
) {
  final result = _lib._SceneAsset_removeFromScene(
      tSceneAsset.addr as Pointer<TSceneAsset>, tScene.addr as Pointer<TScene>);
  return result;
}

DartEntityId SceneAsset_getEntity(
  self.Pointer<TSceneAsset> tSceneAsset,
) {
  final result =
      _lib._SceneAsset_getEntity(tSceneAsset.addr as Pointer<TSceneAsset>);
  return result;
}

int SceneAsset_getChildEntityCount(
  self.Pointer<TSceneAsset> tSceneAsset,
) {
  final result = _lib._SceneAsset_getChildEntityCount(
      tSceneAsset.addr as Pointer<TSceneAsset>);
  return result;
}

void SceneAsset_getChildEntities(
  self.Pointer<TSceneAsset> tSceneAsset,
  self.Pointer<Int32> out,
) {
  final result = _lib._SceneAsset_getChildEntities(
      tSceneAsset.addr as Pointer<TSceneAsset>, out.addr as Pointer<Int32>);
  return result;
}

self.Pointer<Int32> SceneAsset_getCameraEntities(
  self.Pointer<TSceneAsset> tSceneAsset,
) {
  final result = _lib._SceneAsset_getCameraEntities(
      tSceneAsset.addr as Pointer<TSceneAsset>);
  return result;
}

self.Pointer<Int32> SceneAsset_getLightEntities(
  self.Pointer<TSceneAsset> tSceneAsset,
) {
  final result = _lib._SceneAsset_getLightEntities(
      tSceneAsset.addr as Pointer<TSceneAsset>);
  return result;
}

self.Pointer<TSceneAsset> SceneAsset_getInstance(
  self.Pointer<TSceneAsset> tSceneAsset,
  int index,
) {
  final result = _lib._SceneAsset_getInstance(
      tSceneAsset.addr as Pointer<TSceneAsset>, index);
  return result;
}

self.Pointer<TSceneAsset> SceneAsset_createInstance(
  self.Pointer<TSceneAsset> asset,
  self.Pointer<self.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
) {
  final result = _lib._SceneAsset_createInstance(
      asset.addr as Pointer<TSceneAsset>,
      materialInstances.addr as Pointer<self.Pointer<TMaterialInstance>>,
      materialInstanceCount);
  return result;
}

DartAabb3 SceneAsset_getBoundingBox(
  self.Pointer<TSceneAsset> asset,
) {
  final Aabb3_out = Aabb3.stackAlloc();
  final result = _lib._SceneAsset_getBoundingBox(
      Aabb3_out.addr as Pointer<Aabb3>, asset.addr as Pointer<TSceneAsset>);
  return Aabb3_out.toDart();
}

self.Pointer<TAnimationManager> AnimationManager_create(
  self.Pointer<TEngine> tEngine,
  self.Pointer<TScene> tScene,
) {
  final result = _lib._AnimationManager_create(
      tEngine.addr as Pointer<TEngine>, tScene.addr as Pointer<TScene>);
  return result;
}

void AnimationManager_update(
  self.Pointer<TAnimationManager> tAnimationManager,
  int frameTimeInNanos,
) {
  final result = _lib._AnimationManager_update(
      tAnimationManager.addr as Pointer<TAnimationManager>, frameTimeInNanos);
  return result;
}

void AnimationManager_addAnimationComponent(
  self.Pointer<TAnimationManager> tAnimationManager,
  DartEntityId entityId,
) {
  final result = _lib._AnimationManager_addAnimationComponent(
      tAnimationManager.addr as Pointer<TAnimationManager>, entityId);
  return result;
}

void AnimationManager_removeAnimationComponent(
  self.Pointer<TAnimationManager> tAnimationManager,
  DartEntityId entityId,
) {
  final result = _lib._AnimationManager_removeAnimationComponent(
      tAnimationManager.addr as Pointer<TAnimationManager>, entityId);
  return result;
}

bool AnimationManager_setMorphAnimation(
  self.Pointer<TAnimationManager> tAnimationManager,
  DartEntityId entityId,
  self.Pointer<Float32> morphData,
  self.Pointer<Int32> morphIndices,
  int numMorphTargets,
  int numFrames,
  double frameLengthInMs,
) {
  final result = _lib._AnimationManager_setMorphAnimation(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      entityId,
      morphData.addr as Pointer<Float32>,
      morphIndices.addr as Pointer<Int32>,
      numMorphTargets,
      numFrames,
      frameLengthInMs);
  return result;
}

bool AnimationManager_clearMorphAnimation(
  self.Pointer<TAnimationManager> tAnimationManager,
  DartEntityId entityId,
) {
  final result = _lib._AnimationManager_clearMorphAnimation(
      tAnimationManager.addr as Pointer<TAnimationManager>, entityId);
  return result;
}

void AnimationManager_resetToRestPose(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
) {
  final result = _lib._AnimationManager_resetToRestPose(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>);
  return result;
}

void AnimationManager_addBoneAnimation(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> tSceneAsset,
  int skinIndex,
  int boneIndex,
  self.Pointer<Float32> frameData,
  int numFrames,
  double frameLengthInMs,
  double fadeOutInSecs,
  double fadeInInSecs,
  double maxDelta,
) {
  final result = _lib._AnimationManager_addBoneAnimation(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      tSceneAsset.addr as Pointer<TSceneAsset>,
      skinIndex,
      boneIndex,
      frameData.addr as Pointer<Float32>,
      numFrames,
      frameLengthInMs,
      fadeOutInSecs,
      fadeInInSecs,
      maxDelta);
  return result;
}

DartEntityId AnimationManager_getBone(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  int boneIndex,
) {
  final result = _lib._AnimationManager_getBone(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      skinIndex,
      boneIndex);
  return result;
}

void AnimationManager_getRestLocalTransforms(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  self.Pointer<Float32> out,
  int numBones,
) {
  final result = _lib._AnimationManager_getRestLocalTransforms(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      skinIndex,
      out.addr as Pointer<Float32>,
      numBones);
  return result;
}

void AnimationManager_getInverseBindMatrix(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  int boneIndex,
  self.Pointer<Float32> out,
) {
  final result = _lib._AnimationManager_getInverseBindMatrix(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      skinIndex,
      boneIndex,
      out.addr as Pointer<Float32>);
  return result;
}

void AnimationManager_playAnimation(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  int index,
  bool loop,
  bool reverse,
  bool replaceActive,
  double crossfade,
  double startOffset,
) {
  final result = _lib._AnimationManager_playAnimation(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      index,
      loop,
      reverse,
      replaceActive,
      crossfade,
      startOffset);
  return result;
}

void AnimationManager_stopAnimation(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  int index,
) {
  final result = _lib._AnimationManager_stopAnimation(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      index);
  return result;
}

double AnimationManager_getAnimationDuration(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  int animationIndex,
) {
  final result = _lib._AnimationManager_getAnimationDuration(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      animationIndex);
  return result;
}

int AnimationManager_getAnimationCount(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
) {
  final result = _lib._AnimationManager_getAnimationCount(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>);
  return result;
}

void AnimationManager_getAnimationName(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  self.Pointer<Char> outPtr,
  int index,
) {
  final result = _lib._AnimationManager_getAnimationName(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      outPtr.addr as Pointer<Char>,
      index);
  return result;
}

int AnimationManager_getBoneCount(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
) {
  final result = _lib._AnimationManager_getBoneCount(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      skinIndex);
  return result;
}

void AnimationManager_getBoneNames(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  self.Pointer<self.Pointer<Char>> out,
  int skinIndex,
) {
  final result = _lib._AnimationManager_getBoneNames(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      out.addr as Pointer<self.Pointer<Char>>,
      skinIndex);
  return result;
}

int AnimationManager_getMorphTargetNameCount(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  DartEntityId childEntity,
) {
  final result = _lib._AnimationManager_getMorphTargetNameCount(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      childEntity);
  return result;
}

void AnimationManager_getMorphTargetName(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
  DartEntityId childEntity,
  self.Pointer<Char> outPtr,
  int index,
) {
  final result = _lib._AnimationManager_getMorphTargetName(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>,
      childEntity,
      outPtr.addr as Pointer<Char>,
      index);
  return result;
}

bool AnimationManager_updateBoneMatrices(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> sceneAsset,
) {
  final result = _lib._AnimationManager_updateBoneMatrices(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      sceneAsset.addr as Pointer<TSceneAsset>);
  return result;
}

bool AnimationManager_setMorphTargetWeights(
  self.Pointer<TAnimationManager> tAnimationManager,
  DartEntityId entityId,
  self.Pointer<Float32> morphData,
  int numWeights,
) {
  final result = _lib._AnimationManager_setMorphTargetWeights(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      entityId,
      morphData.addr as Pointer<Float32>,
      numWeights);
  return result;
}

void AnimationManager_setGltfAnimationFrame(
  self.Pointer<TAnimationManager> tAnimationManager,
  self.Pointer<TSceneAsset> tSceneAsset,
  int animationIndex,
  int frame,
) {
  final result = _lib._AnimationManager_setGltfAnimationFrame(
      tAnimationManager.addr as Pointer<TAnimationManager>,
      tSceneAsset.addr as Pointer<TSceneAsset>,
      animationIndex,
      frame);
  return result;
}

extension type TMaterialInstance(Struct addr) implements Struct {
  static Pointer<TMaterialInstance> stackAlloc() {
    return _lib._stackAlloc<TMaterialInstance>(0);
  }
}

extension TMaterialInstanceExt on Pointer<TMaterialInstance> {
  DartTMaterialInstance toDart() {
    return DartTMaterialInstance();
  }

  void setFrom(DartTMaterialInstance dartType) {}
}

final class DartTMaterialInstance extends self.DartStruct {
  DartTMaterialInstance();
}

extension type TMaterial(Struct addr) implements Struct {
  static Pointer<TMaterial> stackAlloc() {
    return _lib._stackAlloc<TMaterial>(0);
  }
}

extension TMaterialExt on Pointer<TMaterial> {
  DartTMaterial toDart() {
    return DartTMaterial();
  }

  void setFrom(DartTMaterial dartType) {}
}

final class DartTMaterial extends self.DartStruct {
  DartTMaterial();
}

extension type TEngine(Struct addr) implements Struct {
  static Pointer<TEngine> stackAlloc() {
    return _lib._stackAlloc<TEngine>(0);
  }
}

extension TEngineExt on Pointer<TEngine> {
  DartTEngine toDart() {
    return DartTEngine();
  }

  void setFrom(DartTEngine dartType) {}
}

final class DartTEngine extends self.DartStruct {
  DartTEngine();
}

enum TCullingMode {
  CULLING_MODE_NONE(0),
  CULLING_MODE_FRONT(1),
  CULLING_MODE_BACK(2),
  CULLING_MODE_FRONT_AND_BACK(3);

  final int value;
  const TCullingMode(this.value);

  static TCullingMode fromValue(int value) => switch (value) {
        0 => CULLING_MODE_NONE,
        1 => CULLING_MODE_FRONT,
        2 => CULLING_MODE_BACK,
        3 => CULLING_MODE_FRONT_AND_BACK,
        _ => throw ArgumentError("Unknown value for TCullingMode: $value"),
      };
}

extension type TTexture(Struct addr) implements Struct {
  static Pointer<TTexture> stackAlloc() {
    return _lib._stackAlloc<TTexture>(0);
  }
}

extension TTextureExt on Pointer<TTexture> {
  DartTTexture toDart() {
    return DartTTexture();
  }

  void setFrom(DartTTexture dartType) {}
}

final class DartTTexture extends self.DartStruct {
  DartTTexture();
}

extension type TTextureSampler(Struct addr) implements Struct {
  static Pointer<TTextureSampler> stackAlloc() {
    return _lib._stackAlloc<TTextureSampler>(0);
  }
}

extension TTextureSamplerExt on Pointer<TTextureSampler> {
  DartTTextureSampler toDart() {
    return DartTTextureSampler();
  }

  void setFrom(DartTTextureSampler dartType) {}
}

final class DartTTextureSampler extends self.DartStruct {
  DartTTextureSampler();
}

enum TSamplerCompareFunc {
  /// !< Less or equal
  LE(0),

  /// !< Greater or equal
  GE(1),

  /// !< Strictly less than
  L(2),

  /// !< Strictly greater than
  G(3),

  /// !< Equal
  E(4),

  /// !< Not equal
  NE(5),

  /// !< Always. Depth / stencil testing is deactivated.
  A(6),

  /// !< Never. The depth / stencil test always fails.
  N(7);

  final int value;
  const TSamplerCompareFunc(this.value);

  static TSamplerCompareFunc fromValue(int value) => switch (value) {
        0 => LE,
        1 => GE,
        2 => L,
        3 => G,
        4 => E,
        5 => NE,
        6 => A,
        7 => N,
        _ =>
          throw ArgumentError("Unknown value for TSamplerCompareFunc: $value"),
      };
}

enum TStencilOperation {
  KEEP(0),
  ZERO(1),
  REPLACE(2),
  INCR(3),
  INCR_WRAP(4),
  DECR(5),
  DECR_WRAP(6),
  INVERT(7);

  final int value;
  const TStencilOperation(this.value);

  static TStencilOperation fromValue(int value) => switch (value) {
        0 => KEEP,
        1 => ZERO,
        2 => REPLACE,
        3 => INCR,
        4 => INCR_WRAP,
        5 => DECR,
        6 => DECR_WRAP,
        7 => INVERT,
        _ => throw ArgumentError("Unknown value for TStencilOperation: $value"),
      };
}

enum TStencilFace {
  STENCIL_FACE_FRONT(1),
  STENCIL_FACE_BACK(2),
  STENCIL_FACE_FRONT_AND_BACK(3);

  final int value;
  const TStencilFace(this.value);

  static TStencilFace fromValue(int value) => switch (value) {
        1 => STENCIL_FACE_FRONT,
        2 => STENCIL_FACE_BACK,
        3 => STENCIL_FACE_FRONT_AND_BACK,
        _ => throw ArgumentError("Unknown value for TStencilFace: $value"),
      };
}

enum TTransparencyMode {
  /// ! the transparent object is drawn honoring the raster state
  DEFAULT(0),

  /// the transparent object is first drawn in the depth buffer,
  /// then in the color buffer, honoring the culling mode, but ignoring the depth test function
  TWO_PASSES_ONE_SIDE(1),

  /// the transparent object is drawn twice in the color buffer,
  /// first with back faces only, then with front faces; the culling
  /// mode is ignored. Can be combined with two-sided lighting
  TWO_PASSES_TWO_SIDES(2);

  final int value;
  const TTransparencyMode(this.value);

  static TTransparencyMode fromValue(int value) => switch (value) {
        0 => DEFAULT,
        1 => TWO_PASSES_ONE_SIDE,
        2 => TWO_PASSES_TWO_SIDES,
        _ => throw ArgumentError("Unknown value for TTransparencyMode: $value"),
      };
}

extension type TLightManager(Struct addr) implements Struct {
  static Pointer<TLightManager> stackAlloc() {
    return _lib._stackAlloc<TLightManager>(0);
  }
}

extension TLightManagerExt on Pointer<TLightManager> {
  DartTLightManager toDart() {
    return DartTLightManager();
  }

  void setFrom(DartTLightManager dartType) {}
}

final class DartTLightManager extends self.DartStruct {
  DartTLightManager();
}

typedef EntityId = int;
typedef DartEntityId = int;

enum TLightType {
  LIGHT_TYPE_SUN(0),
  LIGHT_TYPE_DIRECTIONAL(1),
  LIGHT_TYPE_POINT(2),
  LIGHT_TYPE_FOCUSED_SPOT(3),
  LIGHT_TYPE_SPOT(4);

  final int value;
  const TLightType(this.value);

  static TLightType fromValue(int value) => switch (value) {
        0 => LIGHT_TYPE_SUN,
        1 => LIGHT_TYPE_DIRECTIONAL,
        2 => LIGHT_TYPE_POINT,
        3 => LIGHT_TYPE_FOCUSED_SPOT,
        4 => LIGHT_TYPE_SPOT,
        _ => throw ArgumentError("Unknown value for TLightType: $value"),
      };
}

extension type TFilamentAsset(Struct addr) implements Struct {
  static Pointer<TFilamentAsset> stackAlloc() {
    return _lib._stackAlloc<TFilamentAsset>(0);
  }
}

extension TFilamentAssetExt on Pointer<TFilamentAsset> {
  DartTFilamentAsset toDart() {
    return DartTFilamentAsset();
  }

  void setFrom(DartTFilamentAsset dartType) {}
}

final class DartTFilamentAsset extends self.DartStruct {
  DartTFilamentAsset();
}

extension type TGltfAssetLoader(Struct addr) implements Struct {
  static Pointer<TGltfAssetLoader> stackAlloc() {
    return _lib._stackAlloc<TGltfAssetLoader>(0);
  }
}

extension TGltfAssetLoaderExt on Pointer<TGltfAssetLoader> {
  DartTGltfAssetLoader toDart() {
    return DartTGltfAssetLoader();
  }

  void setFrom(DartTGltfAssetLoader dartType) {}
}

final class DartTGltfAssetLoader extends self.DartStruct {
  DartTGltfAssetLoader();
}

extension type TMaterialProvider(Struct addr) implements Struct {
  static Pointer<TMaterialProvider> stackAlloc() {
    return _lib._stackAlloc<TMaterialProvider>(0);
  }
}

extension TMaterialProviderExt on Pointer<TMaterialProvider> {
  DartTMaterialProvider toDart() {
    return DartTMaterialProvider();
  }

  void setFrom(DartTMaterialProvider dartType) {}
}

final class DartTMaterialProvider extends self.DartStruct {
  DartTMaterialProvider();
}

extension type TRenderableManager(Struct addr) implements Struct {
  static Pointer<TRenderableManager> stackAlloc() {
    return _lib._stackAlloc<TRenderableManager>(0);
  }
}

extension TRenderableManagerExt on Pointer<TRenderableManager> {
  DartTRenderableManager toDart() {
    return DartTRenderableManager();
  }

  void setFrom(DartTRenderableManager dartType) {}
}

final class DartTRenderableManager extends self.DartStruct {
  DartTRenderableManager();
}

extension type TViewport(Struct addr) implements Struct {
  static Pointer<TViewport> stackAlloc() {
    return _lib._stackAlloc<TViewport>(16);
  }
}

extension TViewportExt on Pointer<TViewport> {
  DartTViewport toDart() {
    var left = _lib.getValue((addr as Pointer) + 0, "i32").toDartInt;
    var bottom = _lib.getValue((addr as Pointer) + 4, "i32").toDartInt;
    var width = _lib.getValue((addr as Pointer) + 8, "i32").toDartInt;
    var height = _lib.getValue((addr as Pointer) + 12, "i32").toDartInt;
    return DartTViewport(left, bottom, width, height);
  }

  void setFrom(DartTViewport dartType) {
    _lib.setValue((addr as Pointer) + 0, dartType.left.toJS, "i32");
    _lib.setValue((addr as Pointer) + 4, dartType.bottom.toJS, "i32");
    _lib.setValue((addr as Pointer) + 8, dartType.width.toJS, "i32");
    _lib.setValue((addr as Pointer) + 12, dartType.height.toJS, "i32");
  }
}

final class DartTViewport extends self.DartStruct {
  final int left;

  final int bottom;

  final int width;

  final int height;

  DartTViewport(this.left, this.bottom, this.width, this.height);
}

extension type TView(Struct addr) implements Struct {
  static Pointer<TView> stackAlloc() {
    return _lib._stackAlloc<TView>(0);
  }
}

extension TViewExt on Pointer<TView> {
  DartTView toDart() {
    return DartTView();
  }

  void setFrom(DartTView dartType) {}
}

final class DartTView extends self.DartStruct {
  DartTView();
}

extension type TColorGrading(Struct addr) implements Struct {
  static Pointer<TColorGrading> stackAlloc() {
    return _lib._stackAlloc<TColorGrading>(0);
  }
}

extension TColorGradingExt on Pointer<TColorGrading> {
  DartTColorGrading toDart() {
    return DartTColorGrading();
  }

  void setFrom(DartTColorGrading dartType) {}
}

final class DartTColorGrading extends self.DartStruct {
  DartTColorGrading();
}

enum TToneMapping {
  ACES(0),
  FILMIC(1),
  LINEAR(2);

  final int value;
  const TToneMapping(this.value);

  static TToneMapping fromValue(int value) => switch (value) {
        0 => ACES,
        1 => FILMIC,
        2 => LINEAR,
        _ => throw ArgumentError("Unknown value for TToneMapping: $value"),
      };
}

enum TBlendMode {
  OPAQUE(0),
  TRANSLUCENT(1);

  final int value;
  const TBlendMode(this.value);

  static TBlendMode fromValue(int value) => switch (value) {
        0 => OPAQUE,
        1 => TRANSLUCENT,
        _ => throw ArgumentError("Unknown value for TBlendMode: $value"),
      };
}

extension type TRenderTarget(Struct addr) implements Struct {
  static Pointer<TRenderTarget> stackAlloc() {
    return _lib._stackAlloc<TRenderTarget>(0);
  }
}

extension TRenderTargetExt on Pointer<TRenderTarget> {
  DartTRenderTarget toDart() {
    return DartTRenderTarget();
  }

  void setFrom(DartTRenderTarget dartType) {}
}

final class DartTRenderTarget extends self.DartStruct {
  DartTRenderTarget();
}

enum TQualityLevel {
  LOW(0),
  MEDIUM(1),
  HIGH(2),
  ULTRA(3);

  final int value;
  const TQualityLevel(this.value);

  static TQualityLevel fromValue(int value) => switch (value) {
        0 => LOW,
        1 => MEDIUM,
        2 => HIGH,
        3 => ULTRA,
        _ => throw ArgumentError("Unknown value for TQualityLevel: $value"),
      };
}

extension type TCamera(Struct addr) implements Struct {
  static Pointer<TCamera> stackAlloc() {
    return _lib._stackAlloc<TCamera>(0);
  }
}

extension TCameraExt on Pointer<TCamera> {
  DartTCamera toDart() {
    return DartTCamera();
  }

  void setFrom(DartTCamera dartType) {}
}

final class DartTCamera extends self.DartStruct {
  DartTCamera();
}

extension type TScene(Struct addr) implements Struct {
  static Pointer<TScene> stackAlloc() {
    return _lib._stackAlloc<TScene>(0);
  }
}

extension TSceneExt on Pointer<TScene> {
  DartTScene toDart() {
    return DartTScene();
  }

  void setFrom(DartTScene dartType) {}
}

final class DartTScene extends self.DartStruct {
  DartTScene();
}

typedef PickCallback = Pointer<self.NativeFunction<PickCallbackFunction>>;
typedef DartPickCallback
    = self.Pointer<self.NativeFunction<PickCallbackFunction>>;
typedef PickCallbackFunction = void Function(int requestId, EntityId entityId,
    double depth, double fragX, double fragY, double fragZ);
typedef DartPickCallbackFunction = void Function(
    int requestId,
    DartEntityId entityId,
    double depth,
    double fragX,
    double fragY,
    double fragZ);
extension type TNameComponentManager(Struct addr) implements Struct {
  static Pointer<TNameComponentManager> stackAlloc() {
    return _lib._stackAlloc<TNameComponentManager>(0);
  }
}

extension TNameComponentManagerExt on Pointer<TNameComponentManager> {
  DartTNameComponentManager toDart() {
    return DartTNameComponentManager();
  }

  void setFrom(DartTNameComponentManager dartType) {}
}

final class DartTNameComponentManager extends self.DartStruct {
  DartTNameComponentManager();
}

extension type TIndirectLight(Struct addr) implements Struct {
  static Pointer<TIndirectLight> stackAlloc() {
    return _lib._stackAlloc<TIndirectLight>(0);
  }
}

extension TIndirectLightExt on Pointer<TIndirectLight> {
  DartTIndirectLight toDart() {
    return DartTIndirectLight();
  }

  void setFrom(DartTIndirectLight dartType) {}
}

final class DartTIndirectLight extends self.DartStruct {
  DartTIndirectLight();
}

enum TTextureSamplerType {
  SAMPLER_2D(0),
  SAMPLER_2D_ARRAY(1),
  SAMPLER_CUBEMAP(2),
  SAMPLER_EXTERNAL(3),
  SAMPLER_3D(4),
  SAMPLER_CUBEMAP_ARRAY(5);

  final int value;
  const TTextureSamplerType(this.value);

  static TTextureSamplerType fromValue(int value) => switch (value) {
        0 => SAMPLER_2D,
        1 => SAMPLER_2D_ARRAY,
        2 => SAMPLER_CUBEMAP,
        3 => SAMPLER_EXTERNAL,
        4 => SAMPLER_3D,
        5 => SAMPLER_CUBEMAP_ARRAY,
        _ =>
          throw ArgumentError("Unknown value for TTextureSamplerType: $value"),
      };
}

enum TTextureFormat {
  TEXTUREFORMAT_R8(0),
  TEXTUREFORMAT_R8_SNORM(1),
  TEXTUREFORMAT_R8UI(2),
  TEXTUREFORMAT_R8I(3),
  TEXTUREFORMAT_STENCIL8(4),
  TEXTUREFORMAT_R16F(5),
  TEXTUREFORMAT_R16UI(6),
  TEXTUREFORMAT_R16I(7),
  TEXTUREFORMAT_RG8(8),
  TEXTUREFORMAT_RG8_SNORM(9),
  TEXTUREFORMAT_RG8UI(10),
  TEXTUREFORMAT_RG8I(11),
  TEXTUREFORMAT_RGB565(12),
  TEXTUREFORMAT_RGB9_E5(13),
  TEXTUREFORMAT_RGB5_A1(14),
  TEXTUREFORMAT_RGBA4(15),
  TEXTUREFORMAT_DEPTH16(16),
  TEXTUREFORMAT_RGB8(17),
  TEXTUREFORMAT_SRGB8(18),
  TEXTUREFORMAT_RGB8_SNORM(19),
  TEXTUREFORMAT_RGB8UI(20),
  TEXTUREFORMAT_RGB8I(21),
  TEXTUREFORMAT_DEPTH24(22),
  TEXTUREFORMAT_R32F(23),
  TEXTUREFORMAT_R32UI(24),
  TEXTUREFORMAT_R32I(25),
  TEXTUREFORMAT_RG16F(26),
  TEXTUREFORMAT_RG16UI(27),
  TEXTUREFORMAT_RG16I(28),
  TEXTUREFORMAT_R11F_G11F_B10F(29),
  TEXTUREFORMAT_RGBA8(30),
  TEXTUREFORMAT_SRGB8_A8(31),
  TEXTUREFORMAT_RGBA8_SNORM(32),
  TEXTUREFORMAT_UNUSED(33),
  TEXTUREFORMAT_RGB10_A2(34),
  TEXTUREFORMAT_RGBA8UI(35),
  TEXTUREFORMAT_RGBA8I(36),
  TEXTUREFORMAT_DEPTH32F(37),
  TEXTUREFORMAT_DEPTH24_STENCIL8(38),
  TEXTUREFORMAT_DEPTH32F_STENCIL8(39),
  TEXTUREFORMAT_RGB16F(40),
  TEXTUREFORMAT_RGB16UI(41),
  TEXTUREFORMAT_RGB16I(42),
  TEXTUREFORMAT_RG32F(43),
  TEXTUREFORMAT_RG32UI(44),
  TEXTUREFORMAT_RG32I(45),
  TEXTUREFORMAT_RGBA16F(46),
  TEXTUREFORMAT_RGBA16UI(47),
  TEXTUREFORMAT_RGBA16I(48),
  TEXTUREFORMAT_RGB32F(49),
  TEXTUREFORMAT_RGB32UI(50),
  TEXTUREFORMAT_RGB32I(51),
  TEXTUREFORMAT_RGBA32F(52),
  TEXTUREFORMAT_RGBA32UI(53),
  TEXTUREFORMAT_RGBA32I(54),
  TEXTUREFORMAT_EAC_R11(55),
  TEXTUREFORMAT_EAC_R11_SIGNED(56),
  TEXTUREFORMAT_EAC_RG11(57),
  TEXTUREFORMAT_EAC_RG11_SIGNED(58),
  TEXTUREFORMAT_ETC2_RGB8(59),
  TEXTUREFORMAT_ETC2_SRGB8(60),
  TEXTUREFORMAT_ETC2_RGB8_A1(61),
  TEXTUREFORMAT_ETC2_SRGB8_A1(62),
  TEXTUREFORMAT_ETC2_EAC_RGBA8(63),
  TEXTUREFORMAT_ETC2_EAC_SRGBA8(64),
  TEXTUREFORMAT_DXT1_RGB(65),
  TEXTUREFORMAT_DXT1_RGBA(66),
  TEXTUREFORMAT_DXT3_RGBA(67),
  TEXTUREFORMAT_DXT5_RGBA(68),
  TEXTUREFORMAT_DXT1_SRGB(69),
  TEXTUREFORMAT_DXT1_SRGBA(70),
  TEXTUREFORMAT_DXT3_SRGBA(71),
  TEXTUREFORMAT_DXT5_SRGBA(72),
  TEXTUREFORMAT_RGBA_ASTC_4x4(73),
  TEXTUREFORMAT_RGBA_ASTC_5x4(74),
  TEXTUREFORMAT_RGBA_ASTC_5x5(75),
  TEXTUREFORMAT_RGBA_ASTC_6x5(76),
  TEXTUREFORMAT_RGBA_ASTC_6x6(77),
  TEXTUREFORMAT_RGBA_ASTC_8x5(78),
  TEXTUREFORMAT_RGBA_ASTC_8x6(79),
  TEXTUREFORMAT_RGBA_ASTC_8x8(80),
  TEXTUREFORMAT_RGBA_ASTC_10x5(81),
  TEXTUREFORMAT_RGBA_ASTC_10x6(82),
  TEXTUREFORMAT_RGBA_ASTC_10x8(83),
  TEXTUREFORMAT_RGBA_ASTC_10x10(84),
  TEXTUREFORMAT_RGBA_ASTC_12x10(85),
  TEXTUREFORMAT_RGBA_ASTC_12x12(86),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_4x4(87),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x4(88),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x5(89),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x5(90),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x6(91),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x5(92),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x6(93),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x8(94),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x5(95),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x6(96),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x8(97),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x10(98),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x10(99),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x12(100),
  TEXTUREFORMAT_RED_RGTC1(101),
  TEXTUREFORMAT_SIGNED_RED_RGTC1(102),
  TEXTUREFORMAT_RED_GREEN_RGTC2(103),
  TEXTUREFORMAT_SIGNED_RED_GREEN_RGTC2(104),
  TEXTUREFORMAT_RGB_BPTC_SIGNED_FLOAT(105),
  TEXTUREFORMAT_RGB_BPTC_UNSIGNED_FLOAT(106),
  TEXTUREFORMAT_RGBA_BPTC_UNORM(107),
  TEXTUREFORMAT_SRGB_ALPHA_BPTC_UNORM(108);

  final int value;
  const TTextureFormat(this.value);

  static TTextureFormat fromValue(int value) => switch (value) {
        0 => TEXTUREFORMAT_R8,
        1 => TEXTUREFORMAT_R8_SNORM,
        2 => TEXTUREFORMAT_R8UI,
        3 => TEXTUREFORMAT_R8I,
        4 => TEXTUREFORMAT_STENCIL8,
        5 => TEXTUREFORMAT_R16F,
        6 => TEXTUREFORMAT_R16UI,
        7 => TEXTUREFORMAT_R16I,
        8 => TEXTUREFORMAT_RG8,
        9 => TEXTUREFORMAT_RG8_SNORM,
        10 => TEXTUREFORMAT_RG8UI,
        11 => TEXTUREFORMAT_RG8I,
        12 => TEXTUREFORMAT_RGB565,
        13 => TEXTUREFORMAT_RGB9_E5,
        14 => TEXTUREFORMAT_RGB5_A1,
        15 => TEXTUREFORMAT_RGBA4,
        16 => TEXTUREFORMAT_DEPTH16,
        17 => TEXTUREFORMAT_RGB8,
        18 => TEXTUREFORMAT_SRGB8,
        19 => TEXTUREFORMAT_RGB8_SNORM,
        20 => TEXTUREFORMAT_RGB8UI,
        21 => TEXTUREFORMAT_RGB8I,
        22 => TEXTUREFORMAT_DEPTH24,
        23 => TEXTUREFORMAT_R32F,
        24 => TEXTUREFORMAT_R32UI,
        25 => TEXTUREFORMAT_R32I,
        26 => TEXTUREFORMAT_RG16F,
        27 => TEXTUREFORMAT_RG16UI,
        28 => TEXTUREFORMAT_RG16I,
        29 => TEXTUREFORMAT_R11F_G11F_B10F,
        30 => TEXTUREFORMAT_RGBA8,
        31 => TEXTUREFORMAT_SRGB8_A8,
        32 => TEXTUREFORMAT_RGBA8_SNORM,
        33 => TEXTUREFORMAT_UNUSED,
        34 => TEXTUREFORMAT_RGB10_A2,
        35 => TEXTUREFORMAT_RGBA8UI,
        36 => TEXTUREFORMAT_RGBA8I,
        37 => TEXTUREFORMAT_DEPTH32F,
        38 => TEXTUREFORMAT_DEPTH24_STENCIL8,
        39 => TEXTUREFORMAT_DEPTH32F_STENCIL8,
        40 => TEXTUREFORMAT_RGB16F,
        41 => TEXTUREFORMAT_RGB16UI,
        42 => TEXTUREFORMAT_RGB16I,
        43 => TEXTUREFORMAT_RG32F,
        44 => TEXTUREFORMAT_RG32UI,
        45 => TEXTUREFORMAT_RG32I,
        46 => TEXTUREFORMAT_RGBA16F,
        47 => TEXTUREFORMAT_RGBA16UI,
        48 => TEXTUREFORMAT_RGBA16I,
        49 => TEXTUREFORMAT_RGB32F,
        50 => TEXTUREFORMAT_RGB32UI,
        51 => TEXTUREFORMAT_RGB32I,
        52 => TEXTUREFORMAT_RGBA32F,
        53 => TEXTUREFORMAT_RGBA32UI,
        54 => TEXTUREFORMAT_RGBA32I,
        55 => TEXTUREFORMAT_EAC_R11,
        56 => TEXTUREFORMAT_EAC_R11_SIGNED,
        57 => TEXTUREFORMAT_EAC_RG11,
        58 => TEXTUREFORMAT_EAC_RG11_SIGNED,
        59 => TEXTUREFORMAT_ETC2_RGB8,
        60 => TEXTUREFORMAT_ETC2_SRGB8,
        61 => TEXTUREFORMAT_ETC2_RGB8_A1,
        62 => TEXTUREFORMAT_ETC2_SRGB8_A1,
        63 => TEXTUREFORMAT_ETC2_EAC_RGBA8,
        64 => TEXTUREFORMAT_ETC2_EAC_SRGBA8,
        65 => TEXTUREFORMAT_DXT1_RGB,
        66 => TEXTUREFORMAT_DXT1_RGBA,
        67 => TEXTUREFORMAT_DXT3_RGBA,
        68 => TEXTUREFORMAT_DXT5_RGBA,
        69 => TEXTUREFORMAT_DXT1_SRGB,
        70 => TEXTUREFORMAT_DXT1_SRGBA,
        71 => TEXTUREFORMAT_DXT3_SRGBA,
        72 => TEXTUREFORMAT_DXT5_SRGBA,
        73 => TEXTUREFORMAT_RGBA_ASTC_4x4,
        74 => TEXTUREFORMAT_RGBA_ASTC_5x4,
        75 => TEXTUREFORMAT_RGBA_ASTC_5x5,
        76 => TEXTUREFORMAT_RGBA_ASTC_6x5,
        77 => TEXTUREFORMAT_RGBA_ASTC_6x6,
        78 => TEXTUREFORMAT_RGBA_ASTC_8x5,
        79 => TEXTUREFORMAT_RGBA_ASTC_8x6,
        80 => TEXTUREFORMAT_RGBA_ASTC_8x8,
        81 => TEXTUREFORMAT_RGBA_ASTC_10x5,
        82 => TEXTUREFORMAT_RGBA_ASTC_10x6,
        83 => TEXTUREFORMAT_RGBA_ASTC_10x8,
        84 => TEXTUREFORMAT_RGBA_ASTC_10x10,
        85 => TEXTUREFORMAT_RGBA_ASTC_12x10,
        86 => TEXTUREFORMAT_RGBA_ASTC_12x12,
        87 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_4x4,
        88 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x4,
        89 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x5,
        90 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x5,
        91 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x6,
        92 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x5,
        93 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x6,
        94 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x8,
        95 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x5,
        96 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x6,
        97 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x8,
        98 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x10,
        99 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x10,
        100 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x12,
        101 => TEXTUREFORMAT_RED_RGTC1,
        102 => TEXTUREFORMAT_SIGNED_RED_RGTC1,
        103 => TEXTUREFORMAT_RED_GREEN_RGTC2,
        104 => TEXTUREFORMAT_SIGNED_RED_GREEN_RGTC2,
        105 => TEXTUREFORMAT_RGB_BPTC_SIGNED_FLOAT,
        106 => TEXTUREFORMAT_RGB_BPTC_UNSIGNED_FLOAT,
        107 => TEXTUREFORMAT_RGBA_BPTC_UNORM,
        108 => TEXTUREFORMAT_SRGB_ALPHA_BPTC_UNORM,
        _ => throw ArgumentError("Unknown value for TTextureFormat: $value"),
      };
}

extension type TLinearImage(Struct addr) implements Struct {
  static Pointer<TLinearImage> stackAlloc() {
    return _lib._stackAlloc<TLinearImage>(0);
  }
}

extension TLinearImageExt on Pointer<TLinearImage> {
  DartTLinearImage toDart() {
    return DartTLinearImage();
  }

  void setFrom(DartTLinearImage dartType) {}
}

final class DartTLinearImage extends self.DartStruct {
  DartTLinearImage();
}

/// ! Pixel Data Format
enum TPixelDataFormat {
  /// !< One Red channel, float
  PIXELDATAFORMAT_R(0),

  /// !< One Red channel, integer
  PIXELDATAFORMAT_R_INTEGER(1),

  /// !< Two Red and Green channels, float
  PIXELDATAFORMAT_RG(2),

  /// !< Two Red and Green channels, integer
  PIXELDATAFORMAT_RG_INTEGER(3),

  /// !< Three Red, Green and Blue channels, float
  PIXELDATAFORMAT_RGB(4),

  /// !< Three Red, Green and Blue channels, integer
  PIXELDATAFORMAT_RGB_INTEGER(5),

  /// !< Four Red, Green, Blue and Alpha channels, float
  PIXELDATAFORMAT_RGBA(6),

  /// !< Four Red, Green, Blue and Alpha channels, integer
  PIXELDATAFORMAT_RGBA_INTEGER(7),
  PIXELDATAFORMAT_UNUSED(8),

  /// !< Depth, 16-bit or 24-bits usually
  PIXELDATAFORMAT_DEPTH_COMPONENT(9),

  /// !< Two Depth (24-bits) + Stencil (8-bits) channels
  PIXELDATAFORMAT_DEPTH_STENCIL(10),
  PIXELDATAFORMAT_ALPHA(11);

  final int value;
  const TPixelDataFormat(this.value);

  static TPixelDataFormat fromValue(int value) => switch (value) {
        0 => PIXELDATAFORMAT_R,
        1 => PIXELDATAFORMAT_R_INTEGER,
        2 => PIXELDATAFORMAT_RG,
        3 => PIXELDATAFORMAT_RG_INTEGER,
        4 => PIXELDATAFORMAT_RGB,
        5 => PIXELDATAFORMAT_RGB_INTEGER,
        6 => PIXELDATAFORMAT_RGBA,
        7 => PIXELDATAFORMAT_RGBA_INTEGER,
        8 => PIXELDATAFORMAT_UNUSED,
        9 => PIXELDATAFORMAT_DEPTH_COMPONENT,
        10 => PIXELDATAFORMAT_DEPTH_STENCIL,
        11 => PIXELDATAFORMAT_ALPHA,
        _ => throw ArgumentError("Unknown value for TPixelDataFormat: $value"),
      };
}

enum TPixelDataType {
  /// !< unsigned byte
  PIXELDATATYPE_UBYTE(0),

  /// !< signed byte
  PIXELDATATYPE_BYTE(1),

  /// !< unsigned short (16-bit)
  PIXELDATATYPE_USHORT(2),

  /// !< signed short (16-bit)
  PIXELDATATYPE_SHORT(3),

  /// !< unsigned int (32-bit)
  PIXELDATATYPE_UINT(4),

  /// !< signed int (32-bit)
  PIXELDATATYPE_INT(5),

  /// !< half-float (16-bit float)
  PIXELDATATYPE_HALF(6),

  /// !< float (32-bits float)
  PIXELDATATYPE_FLOAT(7),

  /// !< compressed pixels, @see CompressedPixelDataType
  PIXELDATATYPE_COMPRESSED(8),

  /// !< three low precision floating-point numbers
  PIXELDATATYPE_UINT_10F_11F_11F_REV(9),

  /// !< unsigned int (16-bit), encodes 3 RGB channels
  PIXELDATATYPE_USHORT_565(10),

  /// !< unsigned normalized 10 bits RGB, 2 bits alpha
  PIXELDATATYPE_UINT_2_10_10_10_REV(11);

  final int value;
  const TPixelDataType(this.value);

  static TPixelDataType fromValue(int value) => switch (value) {
        0 => PIXELDATATYPE_UBYTE,
        1 => PIXELDATATYPE_BYTE,
        2 => PIXELDATATYPE_USHORT,
        3 => PIXELDATATYPE_SHORT,
        4 => PIXELDATATYPE_UINT,
        5 => PIXELDATATYPE_INT,
        6 => PIXELDATATYPE_HALF,
        7 => PIXELDATATYPE_FLOAT,
        8 => PIXELDATATYPE_COMPRESSED,
        9 => PIXELDATATYPE_UINT_10F_11F_11F_REV,
        10 => PIXELDATATYPE_USHORT_565,
        11 => PIXELDATATYPE_UINT_2_10_10_10_REV,
        _ => throw ArgumentError("Unknown value for TPixelDataType: $value"),
      };
}

enum TTextureUsage {
  TEXTURE_USAGE_NONE(0),

  /// !< Texture can be used as a color attachment
  TEXTURE_USAGE_COLOR_ATTACHMENT(1),

  /// !< Texture can be used as a depth attachment
  TEXTURE_USAGE_DEPTH_ATTACHMENT(2),

  /// !< Texture can be used as a stencil attachment
  TEXTURE_USAGE_STENCIL_ATTACHMENT(4),

  /// !< Data can be uploaded into this texture (default)
  TEXTURE_USAGE_UPLOADABLE(8),

  /// !< Texture can be sampled (default)
  TEXTURE_USAGE_SAMPLEABLE(16),

  /// !< Texture can be used as a subpass input
  TEXTURE_USAGE_SUBPASS_INPUT(32),

  /// !< Texture can be used the source of a blit()
  TEXTURE_USAGE_BLIT_SRC(64),

  /// !< Texture can be used the destination of a blit()
  TEXTURE_USAGE_BLIT_DST(128),

  /// !< Texture can be used the destination of a blit()
  TEXTURE_USAGE_PROTECTED(256),

  /// !< Default texture usage
  TEXTURE_USAGE_DEFAULT(24);

  final int value;
  const TTextureUsage(this.value);

  static TTextureUsage fromValue(int value) => switch (value) {
        0 => TEXTURE_USAGE_NONE,
        1 => TEXTURE_USAGE_COLOR_ATTACHMENT,
        2 => TEXTURE_USAGE_DEPTH_ATTACHMENT,
        4 => TEXTURE_USAGE_STENCIL_ATTACHMENT,
        8 => TEXTURE_USAGE_UPLOADABLE,
        16 => TEXTURE_USAGE_SAMPLEABLE,
        32 => TEXTURE_USAGE_SUBPASS_INPUT,
        64 => TEXTURE_USAGE_BLIT_SRC,
        128 => TEXTURE_USAGE_BLIT_DST,
        256 => TEXTURE_USAGE_PROTECTED,
        24 => TEXTURE_USAGE_DEFAULT,
        _ => throw ArgumentError("Unknown value for TTextureUsage: $value"),
      };
}

enum TSamplerMinFilter {
  FILTER_NEAREST(0),
  FILTER_LINEAR(1),
  FILTER_NEAREST_MIPMAP_NEAREST(2),
  FILTER_LINEAR_MIPMAP_NEAREST(3),
  FILTER_NEAREST_MIPMAP_LINEAR(4),
  FILTER_LINEAR_MIPMAP_LINEAR(5);

  final int value;
  const TSamplerMinFilter(this.value);

  static TSamplerMinFilter fromValue(int value) => switch (value) {
        0 => FILTER_NEAREST,
        1 => FILTER_LINEAR,
        2 => FILTER_NEAREST_MIPMAP_NEAREST,
        3 => FILTER_LINEAR_MIPMAP_NEAREST,
        4 => FILTER_NEAREST_MIPMAP_LINEAR,
        5 => FILTER_LINEAR_MIPMAP_LINEAR,
        _ => throw ArgumentError("Unknown value for TSamplerMinFilter: $value"),
      };
}

enum TSamplerMagFilter {
  MAG_FILTER_NEAREST(0),
  MAG_FILTER_LINEAR(1);

  final int value;
  const TSamplerMagFilter(this.value);

  static TSamplerMagFilter fromValue(int value) => switch (value) {
        0 => MAG_FILTER_NEAREST,
        1 => MAG_FILTER_LINEAR,
        _ => throw ArgumentError("Unknown value for TSamplerMagFilter: $value"),
      };
}

enum TSamplerWrapMode {
  WRAP_CLAMP_TO_EDGE(0),
  WRAP_REPEAT(1),
  WRAP_MIRRORED_REPEAT(2);

  final int value;
  const TSamplerWrapMode(this.value);

  static TSamplerWrapMode fromValue(int value) => switch (value) {
        0 => WRAP_CLAMP_TO_EDGE,
        1 => WRAP_REPEAT,
        2 => WRAP_MIRRORED_REPEAT,
        _ => throw ArgumentError("Unknown value for TSamplerWrapMode: $value"),
      };
}

enum TSamplerCompareMode {
  COMPARE_MODE_NONE(0),
  COMPARE_MODE_COMPARE_TO_TEXTURE(1);

  final int value;
  const TSamplerCompareMode(this.value);

  static TSamplerCompareMode fromValue(int value) => switch (value) {
        0 => COMPARE_MODE_NONE,
        1 => COMPARE_MODE_COMPARE_TO_TEXTURE,
        _ =>
          throw ArgumentError("Unknown value for TSamplerCompareMode: $value"),
      };
}

extension type TGizmo(Struct addr) implements Struct {
  static Pointer<TGizmo> stackAlloc() {
    return _lib._stackAlloc<TGizmo>(0);
  }
}

extension TGizmoExt on Pointer<TGizmo> {
  DartTGizmo toDart() {
    return DartTGizmo();
  }

  void setFrom(DartTGizmo dartType) {}
}

final class DartTGizmo extends self.DartStruct {
  DartTGizmo();
}

extension type TGltfResourceLoader(Struct addr) implements Struct {
  static Pointer<TGltfResourceLoader> stackAlloc() {
    return _lib._stackAlloc<TGltfResourceLoader>(0);
  }
}

extension TGltfResourceLoaderExt on Pointer<TGltfResourceLoader> {
  DartTGltfResourceLoader toDart() {
    return DartTGltfResourceLoader();
  }

  void setFrom(DartTGltfResourceLoader dartType) {}
}

final class DartTGltfResourceLoader extends self.DartStruct {
  DartTGltfResourceLoader();
}

enum TGizmoType {
  GIZMO_TYPE_TRANSLATION(0),
  GIZMO_TYPE_ROTATION(1);

  final int value;
  const TGizmoType(this.value);

  static TGizmoType fromValue(int value) => switch (value) {
        0 => GIZMO_TYPE_TRANSLATION,
        1 => GIZMO_TYPE_ROTATION,
        _ => throw ArgumentError("Unknown value for TGizmoType: $value"),
      };
}

typedef GizmoPickCallback
    = Pointer<self.NativeFunction<GizmoPickCallbackFunction>>;
typedef DartGizmoPickCallback
    = self.Pointer<self.NativeFunction<GizmoPickCallbackFunction>>;
typedef GizmoPickCallbackFunction = void Function(
    int resultType, double x, double y, double z);
typedef DartGizmoPickCallbackFunction = void Function(
    TGizmoPickResultType resultType, double x, double y, double z);

enum TGizmoPickResultType {
  AxisX(0),
  AxisY(1),
  AxisZ(2),
  Parent(3),
  None(4);

  final int value;
  const TGizmoPickResultType(this.value);

  static TGizmoPickResultType fromValue(int value) => switch (value) {
        0 => AxisX,
        1 => AxisY,
        2 => AxisZ,
        3 => Parent,
        4 => None,
        _ =>
          throw ArgumentError("Unknown value for TGizmoPickResultType: $value"),
      };
}

enum TGizmoAxis {
  X(0),
  Y(1),
  Z(2);

  final int value;
  const TGizmoAxis(this.value);

  static TGizmoAxis fromValue(int value) => switch (value) {
        0 => X,
        1 => Y,
        2 => Z,
        _ => throw ArgumentError("Unknown value for TGizmoAxis: $value"),
      };
}

extension type TMaterialKey(Struct addr) implements Struct {
  static Pointer<TMaterialKey> stackAlloc() {
    return _lib._stackAlloc<TMaterialKey>(0);
  }
}

extension TMaterialKeyExt on Pointer<TMaterialKey> {
  DartTMaterialKey toDart() {
    return DartTMaterialKey();
  }

  void setFrom(DartTMaterialKey dartType) {}
}

final class DartTMaterialKey extends self.DartStruct {
  DartTMaterialKey();
}

extension type TSkybox(Struct addr) implements Struct {
  static Pointer<TSkybox> stackAlloc() {
    return _lib._stackAlloc<TSkybox>(0);
  }
}

extension TSkyboxExt on Pointer<TSkybox> {
  DartTSkybox toDart() {
    return DartTSkybox();
  }

  void setFrom(DartTSkybox dartType) {}
}

final class DartTSkybox extends self.DartStruct {
  DartTSkybox();
}

extension type double4x4(Struct addr) implements Struct {
  static Pointer<double4x4> stackAlloc() {
    return _lib._stackAlloc<double4x4>(128);
  }
}

extension double4x4Ext on Pointer<double4x4> {
  Dartdouble4x4 toDart() {
    var col1 =
        Array<Float64>._((addr: (addr as Pointer).cast(), numElements: 4));
    var col2 =
        Array<Float64>._((addr: (addr as Pointer).cast(), numElements: 4));
    var col3 =
        Array<Float64>._((addr: (addr as Pointer).cast(), numElements: 4));
    var col4 =
        Array<Float64>._((addr: (addr as Pointer).cast(), numElements: 4));
    return Dartdouble4x4(col1.cast(), col2.cast(), col3.cast(), col4.cast());
  }

  void setFrom(Dartdouble4x4 dartType) {
    _lib.setValue((addr as Pointer) + 0, dartType.col1._.addr.addr.toJS, "*");
    _lib.setValue((addr as Pointer) + 32, dartType.col2._.addr.addr.toJS, "*");
    _lib.setValue((addr as Pointer) + 64, dartType.col3._.addr.addr.toJS, "*");
    _lib.setValue((addr as Pointer) + 96, dartType.col4._.addr.addr.toJS, "*");
  }
}

final class Dartdouble4x4 extends self.DartStruct {
  Array<Float64> col1;

  Array<Float64> col2;

  Array<Float64> col3;

  Array<Float64> col4;

  Dartdouble4x4(this.col1, this.col2, this.col3, this.col4);
}

extension type double3(Struct addr) implements Struct {
  static Pointer<double3> stackAlloc() {
    return _lib._stackAlloc<double3>(24);
  }
}

extension double3Ext on Pointer<double3> {
  Dartdouble3 toDart() {
    var x = _lib.getValue((addr as Pointer) + 0, "double").toDartDouble;
    var y = _lib.getValue((addr as Pointer) + 8, "double").toDartDouble;
    var z = _lib.getValue((addr as Pointer) + 16, "double").toDartDouble;
    return Dartdouble3(x, y, z);
  }

  void setFrom(Dartdouble3 dartType) {
    _lib.setValue((addr as Pointer) + 0, dartType.x.toJS, "double");
    _lib.setValue((addr as Pointer) + 8, dartType.y.toJS, "double");
    _lib.setValue((addr as Pointer) + 16, dartType.z.toJS, "double");
  }
}

final class Dartdouble3 extends self.DartStruct {
  final double x;

  final double y;

  final double z;

  Dartdouble3(this.x, this.y, this.z);
}

enum TProjection {
  Perspective(0),
  Orthographic(1);

  final int value;
  const TProjection(this.value);

  static TProjection fromValue(int value) => switch (value) {
        0 => Perspective,
        1 => Orthographic,
        _ => throw ArgumentError("Unknown value for TProjection: $value"),
      };
}

extension type TTransformManager(Struct addr) implements Struct {
  static Pointer<TTransformManager> stackAlloc() {
    return _lib._stackAlloc<TTransformManager>(0);
  }
}

extension TTransformManagerExt on Pointer<TTransformManager> {
  DartTTransformManager toDart() {
    return DartTTransformManager();
  }

  void setFrom(DartTTransformManager dartType) {}
}

final class DartTTransformManager extends self.DartStruct {
  DartTTransformManager();
}

extension type Aabb3(Struct addr) implements Struct {
  static Pointer<Aabb3> stackAlloc() {
    return _lib._stackAlloc<Aabb3>(24);
  }
}

extension Aabb3Ext on Pointer<Aabb3> {
  DartAabb3 toDart() {
    var centerX = _lib.getValue((addr as Pointer) + 0, "float").toDartDouble;
    var centerY = _lib.getValue((addr as Pointer) + 4, "float").toDartDouble;
    var centerZ = _lib.getValue((addr as Pointer) + 8, "float").toDartDouble;
    var halfExtentX =
        _lib.getValue((addr as Pointer) + 12, "float").toDartDouble;
    var halfExtentY =
        _lib.getValue((addr as Pointer) + 16, "float").toDartDouble;
    var halfExtentZ =
        _lib.getValue((addr as Pointer) + 20, "float").toDartDouble;
    return DartAabb3(
        centerX, centerY, centerZ, halfExtentX, halfExtentY, halfExtentZ);
  }

  void setFrom(DartAabb3 dartType) {
    _lib.setValue((addr as Pointer) + 0, dartType.centerX.toJS, "float");
    _lib.setValue((addr as Pointer) + 4, dartType.centerY.toJS, "float");
    _lib.setValue((addr as Pointer) + 8, dartType.centerZ.toJS, "float");
    _lib.setValue((addr as Pointer) + 12, dartType.halfExtentX.toJS, "float");
    _lib.setValue((addr as Pointer) + 16, dartType.halfExtentY.toJS, "float");
    _lib.setValue((addr as Pointer) + 20, dartType.halfExtentZ.toJS, "float");
  }
}

final class DartAabb3 extends self.DartStruct {
  final double centerX;

  final double centerY;

  final double centerZ;

  final double halfExtentX;

  final double halfExtentY;

  final double halfExtentZ;

  DartAabb3(this.centerX, this.centerY, this.centerZ, this.halfExtentX,
      this.halfExtentY, this.halfExtentZ);
}

extension type TRenderer(Struct addr) implements Struct {
  static Pointer<TRenderer> stackAlloc() {
    return _lib._stackAlloc<TRenderer>(0);
  }
}

extension TRendererExt on Pointer<TRenderer> {
  DartTRenderer toDart() {
    return DartTRenderer();
  }

  void setFrom(DartTRenderer dartType) {}
}

final class DartTRenderer extends self.DartStruct {
  DartTRenderer();
}

extension type TSwapChain(Struct addr) implements Struct {
  static Pointer<TSwapChain> stackAlloc() {
    return _lib._stackAlloc<TSwapChain>(0);
  }
}

extension TSwapChainExt on Pointer<TSwapChain> {
  DartTSwapChain toDart() {
    return DartTSwapChain();
  }

  void setFrom(DartTSwapChain dartType) {}
}

final class DartTSwapChain extends self.DartStruct {
  DartTSwapChain();
}

extension type TRenderTicker(Struct addr) implements Struct {
  static Pointer<TRenderTicker> stackAlloc() {
    return _lib._stackAlloc<TRenderTicker>(0);
  }
}

extension TRenderTickerExt on Pointer<TRenderTicker> {
  DartTRenderTicker toDart() {
    return DartTRenderTicker();
  }

  void setFrom(DartTRenderTicker dartType) {}
}

final class DartTRenderTicker extends self.DartStruct {
  DartTRenderTicker();
}

extension type TAnimationManager(Struct addr) implements Struct {
  static Pointer<TAnimationManager> stackAlloc() {
    return _lib._stackAlloc<TAnimationManager>(0);
  }
}

extension TAnimationManagerExt on Pointer<TAnimationManager> {
  DartTAnimationManager toDart() {
    return DartTAnimationManager();
  }

  void setFrom(DartTAnimationManager dartType) {}
}

final class DartTAnimationManager extends self.DartStruct {
  DartTAnimationManager();
}

extension type TFence(Struct addr) implements Struct {
  static Pointer<TFence> stackAlloc() {
    return _lib._stackAlloc<TFence>(0);
  }
}

extension TFenceExt on Pointer<TFence> {
  DartTFence toDart() {
    return DartTFence();
  }

  void setFrom(DartTFence dartType) {}
}

final class DartTFence extends self.DartStruct {
  DartTFence();
}

typedef FilamentRenderCallback
    = Pointer<self.NativeFunction<FilamentRenderCallbackFunction>>;
typedef DartFilamentRenderCallback
    = self.Pointer<self.NativeFunction<FilamentRenderCallbackFunction>>;
typedef FilamentRenderCallbackFunction = void Function(Pointer<Void> owner);
typedef DartFilamentRenderCallbackFunction = void Function(
    self.Pointer<Void> owner);
extension type TSceneAsset(Struct addr) implements Struct {
  static Pointer<TSceneAsset> stackAlloc() {
    return _lib._stackAlloc<TSceneAsset>(0);
  }
}

extension TSceneAssetExt on Pointer<TSceneAsset> {
  DartTSceneAsset toDart() {
    return DartTSceneAsset();
  }

  void setFrom(DartTSceneAsset dartType) {}
}

final class DartTSceneAsset extends self.DartStruct {
  DartTSceneAsset();
}

enum TPrimitiveType {
  /// !< points
  PRIMITIVETYPE_POINTS(0),

  /// !< lines
  PRIMITIVETYPE_LINES(1),

  /// !< line strip
  PRIMITIVETYPE_LINE_STRIP(3),

  /// !< triangles
  PRIMITIVETYPE_TRIANGLES(4),

  /// !< triangle strip
  PRIMITIVETYPE_TRIANGLE_STRIP(5);

  final int value;
  const TPrimitiveType(this.value);

  static TPrimitiveType fromValue(int value) => switch (value) {
        0 => PRIMITIVETYPE_POINTS,
        1 => PRIMITIVETYPE_LINES,
        3 => PRIMITIVETYPE_LINE_STRIP,
        4 => PRIMITIVETYPE_TRIANGLES,
        5 => PRIMITIVETYPE_TRIANGLE_STRIP,
        _ => throw ArgumentError("Unknown value for TPrimitiveType: $value"),
      };
}

enum TBackend {
  /// !< Automatically selects an appropriate driver for the platform.
  BACKEND_DEFAULT(0),

  /// !< Selects the OpenGL/ES driver (default on Android)
  BACKEND_OPENGL(1),

  /// !< Selects the Vulkan driver if the platform supports it (default on Linux/Windows)
  BACKEND_VULKAN(2),

  /// !< Selects the Metal driver if the platform supports it (default on MacOS/iOS).
  BACKEND_METAL(3),

  /// !< Selects the no-op driver for testing purposes.
  BACKEND_NOOP(4);

  final int value;
  const TBackend(this.value);

  static TBackend fromValue(int value) => switch (value) {
        0 => BACKEND_DEFAULT,
        1 => BACKEND_OPENGL,
        2 => BACKEND_VULKAN,
        3 => BACKEND_METAL,
        4 => BACKEND_NOOP,
        _ => throw ArgumentError("Unknown value for TBackend: $value"),
      };
}

extension type TEntityManager(Struct addr) implements Struct {
  static Pointer<TEntityManager> stackAlloc() {
    return _lib._stackAlloc<TEntityManager>(0);
  }
}

extension TEntityManagerExt on Pointer<TEntityManager> {
  DartTEntityManager toDart() {
    return DartTEntityManager();
  }

  void setFrom(DartTEntityManager dartType) {}
}

final class DartTEntityManager extends self.DartStruct {
  DartTEntityManager();
}

extension type Foo(Struct addr) implements Struct {
  static Pointer<Foo> stackAlloc() {
    return _lib._stackAlloc<Foo>(8);
  }
}

extension FooExt on Pointer<Foo> {
  DartFoo toDart() {
    var a = _lib.getValue((addr as Pointer) + 0, "i32").toDartInt;
    var b = _lib.getValue((addr as Pointer) + 4, "i32").toDartInt;
    return DartFoo(a, b);
  }

  void setFrom(DartFoo dartType) {
    _lib.setValue((addr as Pointer) + 0, dartType.a.toJS, "i32");
    _lib.setValue((addr as Pointer) + 4, dartType.b.toJS, "i32");
  }
}

final class DartFoo extends self.DartStruct {
  final int a;

  final int b;

  DartFoo(this.a, this.b);
}

const int __bool_true_false_are_defined = 1;
