// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('package:thermion_dart/thermion_dart.dart')
library;

import 'dart:ffi' as ffi;

@ffi.Native<ffi.Uint64>()
external int TSWAP_CHAIN_CONFIG_TRANSPARENT;

@ffi.Native<ffi.Uint64>()
external int TSWAP_CHAIN_CONFIG_READABLE;

@ffi.Native<ffi.Uint64>()
external int TSWAP_CHAIN_CONFIG_APPLE_CVPIXELBUFFER;

@ffi.Native<ffi.Uint64>()
external int TSWAP_CHAIN_CONFIG_HAS_STENCIL_BUFFER;

@ffi.Native<ffi.Pointer<TMaterialInstance> Function(ffi.Pointer<TMaterial>)>(
    isLeaf: true)
external ffi.Pointer<TMaterialInstance> Material_createInstance(
  ffi.Pointer<TMaterial> tMaterial,
);

@ffi.Native<ffi.Pointer<TMaterial> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TMaterial> Material_createImageMaterial(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Pointer<TMaterial> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TMaterial> Material_createGridMaterial(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Pointer<TMaterial> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TMaterial> Material_createGizmoMaterial(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TMaterial>, ffi.Pointer<ffi.Char>)>(
    isLeaf: true)
external bool Material_hasParameter(
  ffi.Pointer<TMaterial> tMaterial,
  ffi.Pointer<ffi.Char> propertyName,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external bool MaterialInstance_isStencilWriteEnabled(
  ffi.Pointer<TMaterialInstance> materialInstance,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setStencilWrite(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt)>(
    isLeaf: true)
external void MaterialInstance_setCullingMode(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int culling,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setDepthWrite(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setDepthCulling(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  double value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat2(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  double x,
  double y,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double, ffi.Double, ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat3(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Double>, ffi.Uint32)>(isLeaf: true)
external void MaterialInstance_setParameterFloat3Array(
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  ffi.Pointer<ffi.Double> raw,
  int length,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double, ffi.Double, ffi.Double, ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat4(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  double x,
  double y,
  double w,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Double>)>(isLeaf: true)
external void MaterialInstance_setParameterMat4(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  ffi.Pointer<ffi.Double> matrix,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Int)>(isLeaf: true)
external void MaterialInstance_setParameterInt(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  int value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Bool)>(isLeaf: true)
external void MaterialInstance_setParameterBool(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  bool value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<TTexture>, ffi.Pointer<TTextureSampler>)>(isLeaf: true)
external void MaterialInstance_setParameterTexture(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  ffi.Pointer<TTexture> texture,
  ffi.Pointer<TTextureSampler> sampler,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt)>(
    isLeaf: true)
external void MaterialInstance_setDepthFunc(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int depthFunc,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt,
        ffi.UnsignedInt)>(isLeaf: true)
external void MaterialInstance_setStencilOpStencilFail(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int op,
  int face,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt,
        ffi.UnsignedInt)>(isLeaf: true)
external void MaterialInstance_setStencilOpDepthFail(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int op,
  int face,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt,
        ffi.UnsignedInt)>(isLeaf: true)
external void MaterialInstance_setStencilOpDepthStencilPass(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int op,
  int face,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt,
        ffi.UnsignedInt)>(isLeaf: true)
external void MaterialInstance_setStencilCompareFunction(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int func,
  int face,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Uint8,
        ffi.UnsignedInt)>(isLeaf: true)
external void MaterialInstance_setStencilReferenceValue(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int value,
  int face,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Uint8)>(
    isLeaf: true)
external void MaterialInstance_setStencilReadMask(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int mask,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Uint8)>(
    isLeaf: true)
external void MaterialInstance_setStencilWriteMask(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int mask,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt)>(
    isLeaf: true)
external void MaterialInstance_setTransparencyMode(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int transparencyMode,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Double,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void LightManager_setPosition(
  ffi.Pointer<TLightManager> tLightManager,
  int light,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Double,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void LightManager_setDirection(
  ffi.Pointer<TLightManager> tLightManager,
  int light,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TEngine>, ffi.Pointer<TLightManager>,
        ffi.UnsignedInt)>(isLeaf: true)
external int LightManager_createLight(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TLightManager> tLightManager,
  int tLightTtype,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLightManager>, EntityId)>(
    isLeaf: true)
external void LightManager_destroyLight(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Float)>(
    isLeaf: true)
external void LightManager_setColor(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double colorTemperature,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TLightManager>, EntityId, ffi.Double)>(isLeaf: true)
external void LightManager_setIntensity(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double intensity,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TLightManager>, EntityId, ffi.Double)>(isLeaf: true)
external void LightManager_setFalloff(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double falloff,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Double,
        ffi.Double)>(isLeaf: true)
external void LightManager_setSpotLightCone(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double inner,
  double outer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Bool)>(
    isLeaf: true)
external void LightManager_setShadowCaster(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  bool enabled,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external int FilamentAsset_getEntityCount(
  ffi.Pointer<TFilamentAsset> filamentAsset,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TFilamentAsset>, ffi.Pointer<EntityId>)>(isLeaf: true)
external void FilamentAsset_getEntities(
  ffi.Pointer<TFilamentAsset> filamentAsset,
  ffi.Pointer<EntityId> out,
);

@ffi.Native<
    ffi.Pointer<TGltfAssetLoader> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TMaterialProvider>)>(isLeaf: true)
external ffi.Pointer<TGltfAssetLoader> GltfAssetLoader_create(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterialProvider> tMaterialProvider,
);

@ffi.Native<
    ffi.Pointer<TFilamentAsset> Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TGltfAssetLoader>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Uint8)>(isLeaf: true)
external ffi.Pointer<TFilamentAsset> GltfAssetLoader_load(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  int numInstances,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(ffi.Pointer<TRenderableManager>,
        ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> GltfAssetLoader_getMaterialInstance(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  ffi.Pointer<TFilamentAsset> tAsset,
);

@ffi.Native<
    ffi.Pointer<TMaterialProvider> Function(
        ffi.Pointer<TGltfAssetLoader>)>(isLeaf: true)
external ffi.Pointer<TMaterialProvider> GltfAssetLoader_getMaterialProvider(
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external int FilamentAsset_getResourceUriCount(
  ffi.Pointer<TFilamentAsset> tFilamentAsset,
);

@ffi.Native<
    ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
        ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external ffi.Pointer<ffi.Pointer<ffi.Char>> FilamentAsset_getResourceUris(
  ffi.Pointer<TFilamentAsset> tFilamentAsset,
);

@ffi.Native<TViewport Function(ffi.Pointer<TView>)>(isLeaf: true)
external TViewport View_getViewport(
  ffi.Pointer<TView> view,
);

@ffi.Native<
    ffi.Pointer<TColorGrading> Function(
        ffi.Pointer<TEngine>, ffi.UnsignedInt)>(isLeaf: true)
external ffi.Pointer<TColorGrading> ColorGrading_create(
  ffi.Pointer<TEngine> tEngine,
  int toneMapping,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TColorGrading>)>(
    isLeaf: true)
external void View_setColorGrading(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TColorGrading> tColorGrading,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.UnsignedInt)>(
    isLeaf: true)
external void View_setBlendMode(
  ffi.Pointer<TView> view,
  int blendMode,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Uint32, ffi.Uint32)>(
    isLeaf: true)
external void View_setViewport(
  ffi.Pointer<TView> view,
  int width,
  int height,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TRenderTarget>)>(
    isLeaf: true)
external void View_setRenderTarget(
  ffi.Pointer<TView> view,
  ffi.Pointer<TRenderTarget> renderTarget,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setFrustumCullingEnabled(
  ffi.Pointer<TView> view,
  bool enabled,
);

@ffi.Native<ffi.Pointer<TRenderTarget> Function(ffi.Pointer<TView>)>(
    isLeaf: true)
external ffi.Pointer<TRenderTarget> View_getRenderTarget(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setPostProcessing(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setShadowsEnabled(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Int)>(isLeaf: true)
external void View_setShadowType(
  ffi.Pointer<TView> tView,
  int shadowType,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Float, ffi.Float)>(
    isLeaf: true)
external void View_setSoftShadowOptions(
  ffi.Pointer<TView> tView,
  double penumbraScale,
  double penumbraRatioScale,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool, ffi.Float)>(
    isLeaf: true)
external void View_setBloom(
  ffi.Pointer<TView> tView,
  bool enabled,
  double strength,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.UnsignedInt)>(
    isLeaf: true)
external void View_setRenderQuality(
  ffi.Pointer<TView> tView,
  int qualityLevel,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TView>, ffi.Bool, ffi.Bool, ffi.Bool)>(isLeaf: true)
external void View_setAntiAliasing(
  ffi.Pointer<TView> tView,
  bool msaa,
  bool fxaa,
  bool taa,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Int, ffi.Bool)>(
    isLeaf: true)
external void View_setLayerEnabled(
  ffi.Pointer<TView> tView,
  int layer,
  bool visible,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TCamera>)>(
    isLeaf: true)
external void View_setCamera(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TCamera> tCamera,
);

@ffi.Native<ffi.Pointer<TScene> Function(ffi.Pointer<TView>)>(isLeaf: true)
external ffi.Pointer<TScene> View_getScene(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TView>)>(isLeaf: true)
external ffi.Pointer<TCamera> View_getCamera(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setStencilBufferEnabled(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TView>)>(isLeaf: true)
external bool View_isStencilBufferEnabled(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setDitheringEnabled(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TView>)>(isLeaf: true)
external bool View_isDitheringEnabled(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TScene>)>(
    isLeaf: true)
external void View_setScene(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setFrontFaceWindingInverted(
  ffi.Pointer<TView> tView,
  bool inverted,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TView>, ffi.Uint32, ffi.Uint32, ffi.Uint32,
        PickCallback)>(isLeaf: true)
external void View_pick(
  ffi.Pointer<TView> tView,
  int requestId,
  int x,
  int y,
  PickCallback callback,
);

@ffi.Native<ffi.Pointer<TNameComponentManager> Function()>(isLeaf: true)
external ffi.Pointer<TNameComponentManager> NameComponentManager_create();

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TNameComponentManager>, EntityId)>(isLeaf: true)
external ffi.Pointer<ffi.Char> NameComponentManager_getName(
  ffi.Pointer<TNameComponentManager> tNameComponentManager,
  int entity,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TIndirectLight>, ffi.Pointer<ffi.Double>)>(isLeaf: true)
external void IndirectLight_setRotation(
  ffi.Pointer<TIndirectLight> tIndirectLight,
  ffi.Pointer<ffi.Double> rotation,
);

@ffi.Native<
    ffi.Pointer<TTexture> Function(
        ffi.Pointer<TEngine>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint8,
        ffi.Uint16,
        ffi.IntPtr,
        ffi.UnsignedInt,
        ffi.UnsignedInt)>(isLeaf: true)
external ffi.Pointer<TTexture> Texture_build(
  ffi.Pointer<TEngine> engine,
  int width,
  int height,
  int depth,
  int levels,
  int tUsage,
  int import$,
  int sampler,
  int format,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TTexture>,
        ffi.Pointer<TLinearImage>,
        ffi.UnsignedInt,
        ffi.UnsignedInt)>(isLeaf: true)
external bool Texture_loadImage(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  ffi.Pointer<TLinearImage> tImage,
  int bufferFormat,
  int pixelDataType,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TTexture>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32)>(isLeaf: true)
external bool Texture_setImage(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  int level,
  ffi.Pointer<ffi.Uint8> data,
  int size,
  int width,
  int height,
  int channels,
  int bufferFormat,
  int pixelDataType,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TTexture>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32)>(isLeaf: true)
external bool Texture_setImageWithDepth(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  int level,
  ffi.Pointer<ffi.Uint8> data,
  int size,
  int x_offset,
  int y_offset,
  int z_offset,
  int width,
  int height,
  int channels,
  int depth,
  int bufferFormat,
  int pixelDataType,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TTexture>, ffi.Uint32)>(
    isLeaf: true)
external int Texture_getWidth(
  ffi.Pointer<TTexture> tTexture,
  int level,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TTexture>, ffi.Uint32)>(
    isLeaf: true)
external int Texture_getHeight(
  ffi.Pointer<TTexture> tTexture,
  int level,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TTexture>, ffi.Uint32)>(
    isLeaf: true)
external int Texture_getDepth(
  ffi.Pointer<TTexture> tTexture,
  int level,
);

@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<TTexture>, ffi.Uint32)>(
    isLeaf: true)
external int Texture_getUsage(
  ffi.Pointer<TTexture> tTexture,
  int level,
);

@ffi.Native<
    ffi.Pointer<TLinearImage> Function(
        ffi.Uint32, ffi.Uint32, ffi.Uint32)>(isLeaf: true)
external ffi.Pointer<TLinearImage> Image_createEmpty(
  int width,
  int height,
  int channel,
);

@ffi.Native<
    ffi.Pointer<TLinearImage> Function(
        ffi.Pointer<ffi.Uint8>, ffi.Size, ffi.Pointer<ffi.Char>)>(isLeaf: true)
external ffi.Pointer<TLinearImage> Image_decode(
  ffi.Pointer<ffi.Uint8> data,
  int length,
  ffi.Pointer<ffi.Char> name,
);

@ffi.Native<ffi.Pointer<ffi.Float> Function(ffi.Pointer<TLinearImage>)>(
    isLeaf: true)
external ffi.Pointer<ffi.Float> Image_getBytes(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external void Image_destroy(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external int Image_getWidth(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external int Image_getHeight(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external int Image_getChannels(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Pointer<TTexture> Function(ffi.Pointer<TRenderTarget>)>(
    isLeaf: true)
external ffi.Pointer<TTexture> RenderTarget_getColorTexture(
  ffi.Pointer<TRenderTarget> tRenderTarget,
);

@ffi.Native<ffi.Pointer<TTexture> Function(ffi.Pointer<TRenderTarget>)>(
    isLeaf: true)
external ffi.Pointer<TTexture> RenderTarget_getDepthTexture(
  ffi.Pointer<TRenderTarget> tRenderTarget,
);

@ffi.Native<ffi.Pointer<TTextureSampler> Function()>(isLeaf: true)
external ffi.Pointer<TTextureSampler> TextureSampler_create();

@ffi.Native<
    ffi.Pointer<TTextureSampler> Function(ffi.UnsignedInt, ffi.UnsignedInt,
        ffi.UnsignedInt, ffi.UnsignedInt, ffi.UnsignedInt)>(isLeaf: true)
external ffi.Pointer<TTextureSampler> TextureSampler_createWithFiltering(
  int minFilter,
  int magFilter,
  int wrapS,
  int wrapT,
  int wrapR,
);

@ffi.Native<
    ffi.Pointer<TTextureSampler> Function(
        ffi.UnsignedInt, ffi.UnsignedInt)>(isLeaf: true)
external ffi.Pointer<TTextureSampler> TextureSampler_createWithComparison(
  int compareMode,
  int compareFunc,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    isLeaf: true)
external void TextureSampler_setMinFilter(
  ffi.Pointer<TTextureSampler> sampler,
  int filter,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    isLeaf: true)
external void TextureSampler_setMagFilter(
  ffi.Pointer<TTextureSampler> sampler,
  int filter,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    isLeaf: true)
external void TextureSampler_setWrapModeS(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    isLeaf: true)
external void TextureSampler_setWrapModeT(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    isLeaf: true)
external void TextureSampler_setWrapModeR(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.Double)>(
    isLeaf: true)
external void TextureSampler_setAnisotropy(
  ffi.Pointer<TTextureSampler> sampler,
  double anisotropy,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
        ffi.UnsignedInt)>(isLeaf: true)
external void TextureSampler_setCompareMode(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  int func,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>)>(isLeaf: true)
external void TextureSampler_destroy(
  ffi.Pointer<TTextureSampler> sampler,
);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>(isLeaf: true)
external void Gizmo_dummy(
  int t,
);

@ffi.Native<
    ffi.Pointer<TGizmo> Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TGltfAssetLoader>,
        ffi.Pointer<TGltfResourceLoader>,
        ffi.Pointer<TNameComponentManager>,
        ffi.Pointer<TView>,
        ffi.Pointer<TMaterial>,
        ffi.UnsignedInt)>(isLeaf: true)
external ffi.Pointer<TGizmo> Gizmo_create(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TGltfAssetLoader> assetLoader,
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  ffi.Pointer<TNameComponentManager> tNameComponentManager,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TMaterial> tMaterial,
  int tGizmoType,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TGizmo>, ffi.Uint32, ffi.Uint32,
        GizmoPickCallback)>(isLeaf: true)
external void Gizmo_pick(
  ffi.Pointer<TGizmo> tGizmo,
  int x,
  int y,
  GizmoPickCallback callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TGizmo>, ffi.UnsignedInt)>(
    isLeaf: true)
external void Gizmo_highlight(
  ffi.Pointer<TGizmo> tGizmo,
  int axis,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TGizmo>)>(isLeaf: true)
external void Gizmo_unhighlight(
  ffi.Pointer<TGizmo> tGizmo,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(ffi.Pointer<TMaterialProvider>,
        ffi.Pointer<TMaterialKey>)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> MaterialProvider_createMaterialInstance(
  ffi.Pointer<TMaterialProvider> provider,
  ffi.Pointer<TMaterialKey> key,
);

@ffi.Native<
    ffi.Pointer<TRenderTarget> Function(ffi.Pointer<TEngine>, ffi.Uint32,
        ffi.Uint32, ffi.Pointer<TTexture>, ffi.Pointer<TTexture>)>(isLeaf: true)
external ffi.Pointer<TRenderTarget> RenderTarget_create(
  ffi.Pointer<TEngine> tEngine,
  int width,
  int height,
  ffi.Pointer<TTexture> color,
  ffi.Pointer<TTexture> depth,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TRenderTarget>)>(isLeaf: true)
external void RenderTarget_destroy(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TRenderTarget> tRenderTarget,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TScene>, EntityId)>(isLeaf: true)
external void Scene_addEntity(
  ffi.Pointer<TScene> tScene,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TScene>, EntityId)>(isLeaf: true)
external void Scene_removeEntity(
  ffi.Pointer<TScene> tScene,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TScene>, ffi.Pointer<TSkybox>)>(
    isLeaf: true)
external void Scene_setSkybox(
  ffi.Pointer<TScene> tScene,
  ffi.Pointer<TSkybox> skybox,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TScene>, ffi.Pointer<TIndirectLight>)>(isLeaf: true)
external void Scene_setIndirectLight(
  ffi.Pointer<TScene> tScene,
  ffi.Pointer<TIndirectLight> tIndirectLight,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TScene>, ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external void Scene_addFilamentAsset(
  ffi.Pointer<TScene> tScene,
  ffi.Pointer<TFilamentAsset> asset,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void Camera_setExposure(
  ffi.Pointer<TCamera> camera,
  double aperture,
  double shutterSpeed,
  double sensitivity,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getModelMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getViewMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getProjectionMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getCullingProjectionMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, ffi.Pointer<ffi.Double>)>(
    isLeaf: true)
external void Camera_getFrustum(
  ffi.Pointer<TCamera> camera,
  ffi.Pointer<ffi.Double> out,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Pointer<ffi.Double>, ffi.Double,
        ffi.Double)>(isLeaf: true)
external void Camera_setProjectionMatrix(
  ffi.Pointer<TCamera> camera,
  ffi.Pointer<ffi.Double> matrix,
  double near,
  double far,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Double, ffi.Double, ffi.Double,
        ffi.Double, ffi.Bool)>(isLeaf: true)
external void Camera_setProjectionFromFov(
  ffi.Pointer<TCamera> camera,
  double fovInDegrees,
  double aspect,
  double near,
  double far,
  bool horizontal,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getFocalLength(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, double3, double3, double3)>(
    isLeaf: true)
external void Camera_lookAt(
  ffi.Pointer<TCamera> camera,
  double3 eye,
  double3 focus,
  double3 up,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getNear(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getCullingFar(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Float Function(ffi.Pointer<TCamera>, ffi.Bool)>(isLeaf: true)
external double Camera_getFov(
  ffi.Pointer<TCamera> camera,
  bool horizontal,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getFocusDistance(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, ffi.Float)>(isLeaf: true)
external void Camera_setFocusDistance(
  ffi.Pointer<TCamera> camera,
  double focusDistance,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, double4x4, ffi.Double, ffi.Double)>(isLeaf: true)
external void Camera_setCustomProjectionWithCulling(
  ffi.Pointer<TCamera> camera,
  double4x4 projectionMatrix,
  double near,
  double far,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, ffi.Pointer<ffi.Double>)>(
    isLeaf: true)
external void Camera_setModelMatrix(
  ffi.Pointer<TCamera> camera,
  ffi.Pointer<ffi.Double> tModelMatrix,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Double, ffi.Double, ffi.Double,
        ffi.Double)>(isLeaf: true)
external void Camera_setLensProjection(
  ffi.Pointer<TCamera> camera,
  double near,
  double far,
  double aspect,
  double focalLength,
);

@ffi.Native<EntityId Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external int Camera_getEntity(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>,
        ffi.UnsignedInt,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double)>(isLeaf: true)
external void Camera_setProjection(
  ffi.Pointer<TCamera> tCamera,
  int projection,
  double left,
  double right,
  double bottom,
  double top,
  double near,
  double far,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external double4x4 TransformManager_getLocalTransform(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external double4x4 TransformManager_getWorldTransform(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TTransformManager>, EntityId, double4x4)>(isLeaf: true)
external void TransformManager_setTransform(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
  double4x4 transform,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TTransformManager>, EntityId, Aabb3)>(
    isLeaf: true)
external bool TransformManager_transformToUnitCube(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
  Aabb3 boundingBox,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTransformManager>, EntityId, EntityId,
        ffi.Bool)>(isLeaf: true)
external void TransformManager_setParent(
  ffi.Pointer<TTransformManager> tTransformManager,
  int child,
  int parent,
  bool preserveScaling,
);

@ffi.Native<EntityId Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external int TransformManager_getParent(
  ffi.Pointer<TTransformManager> tTransformManager,
  int child,
);

@ffi.Native<EntityId Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external int TransformManager_getAncestor(
  ffi.Pointer<TTransformManager> tTransformManager,
  int childEntityId,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderer>, ffi.Double, ffi.Double,
        ffi.Double, ffi.Double, ffi.Uint8, ffi.Bool, ffi.Bool)>(isLeaf: true)
external void Renderer_setClearOptions(
  ffi.Pointer<TRenderer> tRenderer,
  double clearR,
  double clearG,
  double clearB,
  double clearA,
  int clearStencil,
  bool clear,
  bool discard,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TRenderer>, ffi.Pointer<TSwapChain>,
        ffi.Uint64)>(isLeaf: true)
external bool Renderer_beginFrame(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TSwapChain> tSwapChain,
  int frameTimeInNanos,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderer>)>(isLeaf: true)
external void Renderer_endFrame(
  ffi.Pointer<TRenderer> tRenderer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderer>, ffi.Pointer<TView>)>(
    isLeaf: true)
external void Renderer_render(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderer>, ffi.Pointer<TView>)>(
    isLeaf: true)
external void Renderer_renderStandaloneView(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TRenderTarget>,
        ffi.UnsignedInt,
        ffi.UnsignedInt,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size)>(isLeaf: true)
external void Renderer_readPixels(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TRenderTarget> tRenderTarget,
  int tPixelBufferFormat,
  int tPixelDataType,
  ffi.Pointer<ffi.Uint8> out,
  int outLength,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderer>, ffi.Float, ffi.Float, ffi.Uint8,
        ffi.Uint8)>(isLeaf: true)
external void Renderer_setFrameInterval(
  ffi.Pointer<TRenderer> tRenderer,
  double headRoomRatio,
  double scaleRate,
  int history,
  int interval,
);

@ffi.Native<
    ffi.Pointer<TRenderTicker> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TRenderer>)>(isLeaf: true)
external ffi.Pointer<TRenderTicker> RenderTicker_create(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TRenderer> tRenderer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderTicker>)>(isLeaf: true)
external void RenderTicker_destroy(
  ffi.Pointer<TRenderTicker> tRenderTicker,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderTicker>,
        ffi.Pointer<TAnimationManager>)>(isLeaf: true)
external void RenderTicker_addAnimationManager(
  ffi.Pointer<TRenderTicker> tRenderTicker,
  ffi.Pointer<TAnimationManager> tAnimationManager,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderTicker>,
        ffi.Pointer<TAnimationManager>)>(isLeaf: true)
external void RenderTicker_removeAnimationManager(
  ffi.Pointer<TRenderTicker> tRenderTicker,
  ffi.Pointer<TAnimationManager> tAnimationManager,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderTicker>, ffi.Uint64)>(
    isLeaf: true)
external void RenderTicker_render(
  ffi.Pointer<TRenderTicker> tRenderTicker,
  int frameTimeInNanos,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderTicker>, ffi.Pointer<TSwapChain>,
        ffi.Pointer<ffi.Pointer<TView>>, ffi.Uint8)>(isLeaf: true)
external void RenderTicker_setRenderable(
  ffi.Pointer<TRenderTicker> tRenderTicker,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<ffi.Pointer<TView>> views,
  int numViews,
);

@ffi.Native<
    ffi.Pointer<TEngine> Function(ffi.UnsignedInt, ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Void>, ffi.Uint8, ffi.Bool)>(isLeaf: true)
external ffi.Pointer<TEngine> Engine_create(
  int backend,
  ffi.Pointer<ffi.Void> platform,
  ffi.Pointer<ffi.Void> sharedContext,
  int stereoscopicEyeCount,
  bool disableHandleUseAfterFreeCheck,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external void Engine_destroy(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Pointer<TRenderer> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TRenderer> Engine_createRenderer(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<
    ffi.Pointer<TSwapChain> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<ffi.Void>, ffi.Uint64)>(isLeaf: true)
external ffi.Pointer<TSwapChain> Engine_createSwapChain(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Void> window,
  int flags,
);

@ffi.Native<
    ffi.Pointer<TSwapChain> Function(
        ffi.Pointer<TEngine>, ffi.Uint32, ffi.Uint32, ffi.Uint64)>(isLeaf: true)
external ffi.Pointer<TSwapChain> Engine_createHeadlessSwapChain(
  ffi.Pointer<TEngine> tEngine,
  int width,
  int height,
  int flags,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TSwapChain>)>(
    isLeaf: true)
external void Engine_destroySwapChain(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TSwapChain> tSwapChain,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TView>)>(
    isLeaf: true)
external void Engine_destroyView(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TScene>)>(
    isLeaf: true)
external void Engine_destroyScene(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TColorGrading>)>(isLeaf: true)
external void Engine_destroyColorGrading(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TColorGrading> tColorGrading,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TCamera> Engine_createCamera(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TCamera>)>(
    isLeaf: true)
external void Engine_destroyCamera(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TCamera> tCamera,
);

@ffi.Native<ffi.Pointer<TView> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TView> Engine_createView(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TEngine>, EntityId)>(
    isLeaf: true)
external ffi.Pointer<TCamera> Engine_getCameraComponent(
  ffi.Pointer<TEngine> tEngine,
  int entityId,
);

@ffi.Native<ffi.Pointer<TTransformManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TTransformManager> Engine_getTransformManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TRenderableManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TRenderableManager> Engine_getRenderableManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TLightManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TLightManager> Engine_getLightManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TEntityManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TEntityManager> Engine_getEntityManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TTexture>)>(
    isLeaf: true)
external void Engine_destroyTexture(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
);

@ffi.Native<ffi.Pointer<TFence> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TFence> Engine_createFence(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TFence>)>(
    isLeaf: true)
external void Engine_destroyFence(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TFence> tFence,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external void Engine_flushAndWait(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external void Engine_execute(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<
    ffi.Pointer<TMaterial> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<ffi.Uint8>, ffi.Size)>(isLeaf: true)
external ffi.Pointer<TMaterial> Engine_buildMaterial(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> materialData,
  int length,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TMaterial>)>(
    isLeaf: true)
external void Engine_destroyMaterial(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterial> tMaterial,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external void Engine_destroyMaterialInstance(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
);

@ffi.Native<ffi.Pointer<TScene> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TScene> Engine_createScene(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<
    ffi.Pointer<TSkybox> Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external ffi.Pointer<TSkybox> Engine_buildSkybox(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> ktxData,
  int length,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onTextureUploadComplete,
);

@ffi.Native<
    ffi.Pointer<TIndirectLight> Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Float,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external ffi.Pointer<TIndirectLight> Engine_buildIndirectLight(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> ktxData,
  int length,
  double intensity,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onTextureUploadComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TSkybox>)>(
    isLeaf: true)
external void Engine_destroySkybox(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TSkybox> tSkybox,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TIndirectLight>)>(isLeaf: true)
external void Engine_destroyIndirectLight(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TIndirectLight> tIndirectLight,
);

@ffi.Native<ffi.Void Function()>(isLeaf: true)
external void RenderThread_create();

@ffi.Native<ffi.Void Function()>(isLeaf: true)
external void RenderThread_destroy();

@ffi.Native<ffi.Void Function()>(isLeaf: true)
external void RenderThread_requestFrameAsync();

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderTicker>)>(isLeaf: true)
external void RenderThread_setRenderTicker(
  ffi.Pointer<TRenderTicker> tRenderTicker,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void RenderThread_addTask(
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> task,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderTicker>, ffi.Uint64, VoidCallback)>(isLeaf: true)
external void RenderTicker_renderRenderThread(
  ffi.Pointer<TRenderTicker> tRenderTicker,
  int frameTimeInNanos,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TScene>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TAnimationManager>)>>)>(isLeaf: true)
external void AnimationManager_createRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TScene> tScene,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TAnimationManager>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.UnsignedInt,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Uint8,
            ffi.Bool,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TEngine>)>>)>(
    isLeaf: true)
external void Engine_createRenderThread(
  int backend,
  ffi.Pointer<ffi.Void> platform,
  ffi.Pointer<ffi.Void> sharedContext,
  int stereoscopicEyeCount,
  bool disableHandleUseAfterFreeCheck,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TEngine>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TRenderer>)>>)>(
    isLeaf: true)
external void Engine_createRendererRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TRenderer>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<ffi.Void>,
            ffi.Uint64,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>)>(
    isLeaf: true)
external void Engine_createSwapChainRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Void> window,
  int flags,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint64,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>)>(
    isLeaf: true)
external void Engine_createHeadlessSwapChainRenderThread(
  ffi.Pointer<TEngine> tEngine,
  int width,
  int height,
  int flags,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TCamera>)>>)>(
    isLeaf: true)
external void Engine_createCameraRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TCamera>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TView>)>>)>(
    isLeaf: true)
external void Engine_createViewRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TView>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>)>(
    isLeaf: true)
external void Engine_buildMaterialRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> materialData,
  int length,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>
      onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, VoidCallback)>(isLeaf: true)
external void Engine_destroyRenderThread(
  ffi.Pointer<TEngine> tEngine,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TSwapChain>,
        VoidCallback)>(isLeaf: true)
external void Engine_destroySwapChainRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TSwapChain> tSwapChain,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TView>, VoidCallback)>(isLeaf: true)
external void Engine_destroyViewRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TView> tView,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TScene>, VoidCallback)>(isLeaf: true)
external void Engine_destroySceneRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TScene> tScene,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TColorGrading>,
        VoidCallback)>(isLeaf: true)
external void Engine_destroyColorGradingRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TColorGrading> tColorGrading,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TMaterial>,
        VoidCallback)>(isLeaf: true)
external void Engine_destroyMaterialRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterial> tMaterial,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TMaterialInstance>,
        VoidCallback)>(isLeaf: true)
external void Engine_destroyMaterialInstanceRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TSkybox>, VoidCallback)>(isLeaf: true)
external void Engine_destroySkyboxRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TSkybox> tSkybox,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TIndirectLight>,
        VoidCallback)>(isLeaf: true)
external void Engine_destroyIndirectLightRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TIndirectLight> tIndirectLight,
  VoidCallback onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint8,
            ffi.Uint16,
            ffi.IntPtr,
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>)>(
    isLeaf: true)
external void Texture_buildRenderThread(
  ffi.Pointer<TEngine> engine,
  int width,
  int height,
  int depth,
  int levels,
  int tUsage,
  int import$,
  int sampler,
  int format,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TTexture>,
        VoidCallback)>(isLeaf: true)
external void Engine_destroyTextureRenderThread(
  ffi.Pointer<TEngine> engine,
  ffi.Pointer<TTexture> tTexture,
  VoidCallback onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TFence>)>>)>(
    isLeaf: true)
external void Engine_createFenceRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TFence>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TFence>, VoidCallback)>(isLeaf: true)
external void Engine_destroyFenceRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TFence> tFence,
  VoidCallback onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, VoidCallback)>(isLeaf: true)
external void Engine_flushAndWaitRenderThread(
  ffi.Pointer<TEngine> tEngine,
  VoidCallback onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, VoidCallback)>(isLeaf: true)
external void Engine_executeRenderThread(
  ffi.Pointer<TEngine> tEngine,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Pointer<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSkybox>)>>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_buildSkyboxRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> skyboxData,
  int length,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSkybox>)>>
      onComplete,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onTextureUploadComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Float,
        ffi.Pointer<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TIndirectLight>)>>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_buildIndirectLightRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> iblData,
  int length,
  double intensity,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TIndirectLight>)>>
      onComplete,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onTextureUploadComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderer>,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Uint8,
        ffi.Bool,
        ffi.Bool,
        VoidCallback)>(isLeaf: true)
external void Renderer_setClearOptionsRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  double clearR,
  double clearG,
  double clearB,
  double clearA,
  int clearStencil,
  bool clear,
  bool discard,
  VoidCallback onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TRenderer>,
            ffi.Pointer<TSwapChain>,
            ffi.Uint64,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void Renderer_beginFrameRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TSwapChain> tSwapChain,
  int frameTimeInNanos,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderer>, VoidCallback)>(
    isLeaf: true)
external void Renderer_endFrameRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderer>, ffi.Pointer<TView>, VoidCallback)>(isLeaf: true)
external void Renderer_renderRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderer>, ffi.Pointer<TView>, VoidCallback)>(isLeaf: true)
external void Renderer_renderStandaloneViewRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TRenderTarget>,
        ffi.UnsignedInt,
        ffi.UnsignedInt,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        VoidCallback)>(isLeaf: true)
external void Renderer_readPixelsRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TRenderTarget> tRenderTarget,
  int tPixelBufferFormat,
  int tPixelDataType,
  ffi.Pointer<ffi.Uint8> out,
  int outLength,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TMaterial>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TMaterialInstance>)>>)>(isLeaf: true)
external void Material_createInstanceRenderThread(
  ffi.Pointer<TMaterial> tMaterial,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterialInstance>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>)>(
    isLeaf: true)
external void Material_createImageMaterialRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>)>(
    isLeaf: true)
external void Material_createGizmoMaterialRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.UnsignedInt,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TColorGrading>)>>)>(isLeaf: true)
external void ColorGrading_createRenderThread(
  ffi.Pointer<TEngine> tEngine,
  int toneMapping,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TColorGrading>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TColorGrading>,
        VoidCallback)>(isLeaf: true)
external void View_setColorGradingRenderThread(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TColorGrading> tColorGrading,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TView>, ffi.Bool, ffi.Double, VoidCallback)>(isLeaf: true)
external void View_setBloomRenderThread(
  ffi.Pointer<TView> tView,
  bool enabled,
  double strength,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TView>, ffi.Pointer<TCamera>, VoidCallback)>(isLeaf: true)
external void View_setCameraRenderThread(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TCamera> tCamera,
  VoidCallback onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>, VoidCallback)>(
    isLeaf: true)
external void SceneAsset_destroyRenderThread(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  VoidCallback onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<TGltfAssetLoader>,
            ffi.Pointer<TNameComponentManager>,
            ffi.Pointer<TFilamentAsset>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneAsset_createFromFilamentAssetRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
  ffi.Pointer<TNameComponentManager> tNameComponentManager,
  ffi.Pointer<TFilamentAsset> tFilamentAsset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneAsset>,
            ffi.Pointer<ffi.Pointer<TMaterialInstance>>,
            ffi.Int,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneAsset_createInstanceRenderThread(
  ffi.Pointer<TSceneAsset> asset,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> tMaterialInstances,
  int materialInstanceCount,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<ffi.Float>,
            ffi.Uint32,
            ffi.Pointer<ffi.Float>,
            ffi.Uint32,
            ffi.Pointer<ffi.Float>,
            ffi.Uint32,
            ffi.Pointer<ffi.Uint16>,
            ffi.Uint32,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.Pointer<TMaterialInstance>>,
            ffi.Int,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneAsset_createGeometryRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Float> vertices,
  int numVertices,
  ffi.Pointer<ffi.Float> normals,
  int numNormals,
  ffi.Pointer<ffi.Float> uvs,
  int numUvs,
  ffi.Pointer<ffi.Uint16> indices,
  int numIndices,
  int tPrimitiveType,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TMaterialProvider>,
        ffi.Pointer<TMaterialKey>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TMaterialInstance>)>>)>(isLeaf: true)
external void MaterialProvider_createMaterialInstanceRenderThread(
  ffi.Pointer<TMaterialProvider> tMaterialProvider,
  ffi.Pointer<TMaterialKey> tKey,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterialInstance>)>>
      callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TAnimationManager>,
            ffi.Pointer<TSceneAsset>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void AnimationManager_updateBoneMatricesRenderThread(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TAnimationManager>,
            EntityId,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void AnimationManager_setMorphTargetWeightsRenderThread(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  ffi.Pointer<ffi.Float> morphData,
  int numWeights,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TLinearImage>)>>)>(isLeaf: true)
external void Image_createEmptyRenderThread(
  int width,
  int height,
  int channel,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TLinearImage>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TLinearImage>)>>)>(isLeaf: true)
external void Image_decodeRenderThread(
  ffi.Pointer<ffi.Uint8> data,
  int length,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TLinearImage>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TLinearImage>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>)>(
    isLeaf: true)
external void Image_getBytesRenderThread(
  ffi.Pointer<TLinearImage> tLinearImage,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>
      onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLinearImage>, VoidCallback)>(
    isLeaf: true)
external void Image_destroyRenderThread(
  ffi.Pointer<TLinearImage> tLinearImage,
  VoidCallback onComplete,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TLinearImage>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>)>(
    isLeaf: true)
external void Image_getWidthRenderThread(
  ffi.Pointer<TLinearImage> tLinearImage,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TLinearImage>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>)>(
    isLeaf: true)
external void Image_getHeightRenderThread(
  ffi.Pointer<TLinearImage> tLinearImage,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TLinearImage>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>)>(
    isLeaf: true)
external void Image_getChannelsRenderThread(
  ffi.Pointer<TLinearImage> tLinearImage,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<TTexture>,
            ffi.Pointer<TLinearImage>,
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void Texture_loadImageRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  ffi.Pointer<TLinearImage> tImage,
  int bufferFormat,
  int pixelDataType,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<TTexture>,
            ffi.Uint32,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void Texture_setImageRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  int level,
  ffi.Pointer<ffi.Uint8> data,
  int size,
  int width,
  int height,
  int channels,
  int bufferFormat,
  int pixelDataType,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<TTexture>,
            ffi.Uint32,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void Texture_setImageWithDepthRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  int level,
  ffi.Pointer<ffi.Uint8> data,
  int size,
  int x_offset,
  int y_offset,
  int z_offset,
  int width,
  int height,
  int channels,
  int depth,
  int bufferFormat,
  int pixelDataType,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TRenderTarget>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>)>(
    isLeaf: true)
external void RenderTarget_getColorTextureRenderThread(
  ffi.Pointer<TRenderTarget> tRenderTarget,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<TTexture>,
        ffi.Pointer<TTexture>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TRenderTarget>)>>)>(isLeaf: true)
external void RenderTarget_createRenderThread(
  ffi.Pointer<TEngine> tEngine,
  int width,
  int height,
  ffi.Pointer<TTexture> color,
  ffi.Pointer<TTexture> depth,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TRenderTarget>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TRenderTarget>,
        VoidCallback)>(isLeaf: true)
external void RenderTarget_destroyRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TRenderTarget> tRenderTarget,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TTextureSampler>)>>)>(isLeaf: true)
external void TextureSampler_createRenderThread(
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTextureSampler>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.UnsignedInt,
        ffi.UnsignedInt,
        ffi.UnsignedInt,
        ffi.UnsignedInt,
        ffi.UnsignedInt,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TTextureSampler>)>>)>(isLeaf: true)
external void TextureSampler_createWithFilteringRenderThread(
  int minFilter,
  int magFilter,
  int wrapS,
  int wrapT,
  int wrapR,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTextureSampler>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.UnsignedInt,
        ffi.UnsignedInt,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TTextureSampler>)>>)>(isLeaf: true)
external void TextureSampler_createWithComparisonRenderThread(
  int compareMode,
  int compareFunc,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTextureSampler>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
        VoidCallback)>(isLeaf: true)
external void TextureSampler_setMinFilterRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int filter,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
        VoidCallback)>(isLeaf: true)
external void TextureSampler_setMagFilterRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int filter,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
        VoidCallback)>(isLeaf: true)
external void TextureSampler_setWrapModeSRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
        VoidCallback)>(isLeaf: true)
external void TextureSampler_setWrapModeTRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
        VoidCallback)>(isLeaf: true)
external void TextureSampler_setWrapModeRRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TTextureSampler>, ffi.Double, VoidCallback)>(isLeaf: true)
external void TextureSampler_setAnisotropyRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  double anisotropy,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
        ffi.UnsignedInt, VoidCallback)>(isLeaf: true)
external void TextureSampler_setCompareModeRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  int func,
  VoidCallback onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, VoidCallback)>(
    isLeaf: true)
external void TextureSampler_destroyRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  VoidCallback onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TAnimationManager>,
            EntityId,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void AnimationManager_setBoneTransformRenderThread(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int asset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> transform,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TAnimationManager>, EntityId, VoidCallback)>(isLeaf: true)
external void AnimationManager_resetToRestPoseRenderThread(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  VoidCallback onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TMaterialProvider>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TGltfAssetLoader>)>>)>(isLeaf: true)
external void GltfAssetLoader_createRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterialProvider> tMaterialProvider,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TGltfAssetLoader>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TGltfResourceLoader>)>>)>(isLeaf: true)
external void GltfResourceLoader_createRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Char> relativeResourcePath,
  ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<TGltfResourceLoader>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TGltfResourceLoader>,
        VoidCallback)>(isLeaf: true)
external void GltfResourceLoader_destroyRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TGltfResourceLoader> tResourceLoader,
  VoidCallback onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TGltfResourceLoader>,
            ffi.Pointer<TFilamentAsset>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void GltfResourceLoader_loadResourcesRenderThread(
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  ffi.Pointer<TFilamentAsset> tFilamentAsset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TGltfResourceLoader>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Uint8>, ffi.Size, VoidCallback)>(isLeaf: true)
external void GltfResourceLoader_addResourceDataRenderThread(
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  ffi.Pointer<ffi.Char> uri,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  VoidCallback onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TGltfResourceLoader>,
            ffi.Pointer<TFilamentAsset>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void GltfResourceLoader_asyncBeginLoadRenderThread(
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  ffi.Pointer<TFilamentAsset> tFilamentAsset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TGltfResourceLoader>)>(isLeaf: true)
external void GltfResourceLoader_asyncUpdateLoadRenderThread(
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TGltfResourceLoader>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Float)>>)>(
    isLeaf: true)
external void GltfResourceLoader_asyncGetLoadProgressRenderThread(
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Float)>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TGltfAssetLoader>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Uint8,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TFilamentAsset>)>>)>(isLeaf: true)
external void GltfAssetLoader_loadRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  int numInstances,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TFilamentAsset>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TScene>, ffi.Pointer<TFilamentAsset>,
        VoidCallback)>(isLeaf: true)
external void Scene_addFilamentAssetRenderThread(
  ffi.Pointer<TScene> tScene,
  ffi.Pointer<TFilamentAsset> tAsset,
  VoidCallback onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<TGltfAssetLoader>,
            ffi.Pointer<TGltfResourceLoader>,
            ffi.Pointer<TNameComponentManager>,
            ffi.Pointer<TView>,
            ffi.Pointer<TMaterial>,
            ffi.UnsignedInt,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TGizmo>)>>)>(
    isLeaf: true)
external void Gizmo_createRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  ffi.Pointer<TNameComponentManager> tNameComponentManager,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TMaterial> tMaterial,
  int tGizmoType,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TGizmo>)>>
      callback,
);

@ffi.Native<
    ffi.Pointer<TGltfResourceLoader> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<ffi.Char>)>(isLeaf: true)
external ffi.Pointer<TGltfResourceLoader> GltfResourceLoader_create(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Char> relativeResourcePath,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TGltfResourceLoader>)>(isLeaf: true)
external void GltfResourceLoader_destroy(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TGltfResourceLoader>,
        ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external bool GltfResourceLoader_asyncBeginLoad(
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  ffi.Pointer<TFilamentAsset> tFilamentAsset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TGltfResourceLoader>)>(isLeaf: true)
external void GltfResourceLoader_asyncUpdateLoad(
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
);

@ffi.Native<ffi.Float Function(ffi.Pointer<TGltfResourceLoader>)>(isLeaf: true)
external double GltfResourceLoader_asyncGetLoadProgress(
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TGltfResourceLoader>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Uint8>, ffi.Size)>(isLeaf: true)
external void GltfResourceLoader_addResourceData(
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  ffi.Pointer<ffi.Char> uri,
  ffi.Pointer<ffi.Uint8> data,
  int length,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TGltfResourceLoader>,
        ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external bool GltfResourceLoader_loadResources(
  ffi.Pointer<TGltfResourceLoader> tGltfResourceLoader,
  ffi.Pointer<TFilamentAsset> tFilamentAsset,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderableManager>, EntityId, ffi.Int,
        ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external void RenderableManager_setMaterialInstanceAt(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int primitiveIndex,
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> RenderableManager_getMaterialInstanceAt(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int primitiveIndex,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_isRenderable(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_hasComponent(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>)>(isLeaf: true)
external bool RenderableManager_empty(
  ffi.Pointer<TRenderableManager> tRenderableManager,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId,
        ffi.UnsignedInt)>(isLeaf: true)
external bool RenderableManager_getLightChannel(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int channel,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_isShadowCaster(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Bool)>(isLeaf: true)
external void RenderableManager_setCastShadows(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  bool castShadows,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Bool)>(isLeaf: true)
external void RenderableManager_setReceiveShadows(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  bool receiveShadows,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_isShadowReceiver(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_getFogEnabled(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<Aabb3 Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external Aabb3 RenderableManager_getAabb(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Uint8)>(isLeaf: true)
external void RenderableManager_setVisibilityLayer(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int layer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Uint8)>(isLeaf: true)
external void RenderableManager_setPriority(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int priority,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Float>,
        ffi.Uint32,
        ffi.Pointer<ffi.Float>,
        ffi.Uint32,
        ffi.Pointer<ffi.Float>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint16>,
        ffi.Uint32,
        ffi.UnsignedInt,
        ffi.Pointer<ffi.Pointer<TMaterialInstance>>,
        ffi.Int)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_createGeometry(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Float> vertices,
  int numVertices,
  ffi.Pointer<ffi.Float> normals,
  int numNormals,
  ffi.Pointer<ffi.Float> uvs,
  int numUvs,
  ffi.Pointer<ffi.Uint16> indices,
  int numIndices,
  int tPrimitiveType,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TGltfAssetLoader>,
        ffi.Pointer<TNameComponentManager>,
        ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_createFromFilamentAsset(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
  ffi.Pointer<TNameComponentManager> tNameComponentManager,
  ffi.Pointer<TFilamentAsset> tFilamentAsset,
);

@ffi.Native<ffi.Pointer<TFilamentAsset> Function(ffi.Pointer<TSceneAsset>)>(
    isLeaf: true)
external ffi.Pointer<TFilamentAsset> SceneAsset_getFilamentAsset(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TMaterial>)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_createGrid(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterial> tMaterial,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external void SceneAsset_destroy(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>, ffi.Pointer<TScene>)>(
    isLeaf: true)
external void SceneAsset_addToScene(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>, ffi.Pointer<TScene>)>(
    isLeaf: true)
external void SceneAsset_removeFromScene(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<EntityId Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getEntity(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getChildEntityCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>, ffi.Pointer<EntityId>)>(
    isLeaf: true)
external void SceneAsset_getChildEntities(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  ffi.Pointer<EntityId> out,
);

@ffi.Native<ffi.Pointer<EntityId> Function(ffi.Pointer<TSceneAsset>)>(
    isLeaf: true)
external ffi.Pointer<EntityId> SceneAsset_getCameraEntities(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getCameraEntityCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Pointer<EntityId> Function(ffi.Pointer<TSceneAsset>)>(
    isLeaf: true)
external ffi.Pointer<EntityId> SceneAsset_getLightEntities(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getLightEntityCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TSceneAsset>, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_getInstance(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  int index,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getInstanceCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.Pointer<TMaterialInstance>>, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_createInstance(
  ffi.Pointer<TSceneAsset> asset,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
);

@ffi.Native<Aabb3 Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external Aabb3 SceneAsset_getBoundingBox(
  ffi.Pointer<TSceneAsset> asset,
);

@ffi.Native<
    ffi.Pointer<TAnimationManager> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TScene>)>(isLeaf: true)
external ffi.Pointer<TAnimationManager> AnimationManager_create(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Uint64)>(
    isLeaf: true)
external void AnimationManager_update(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int frameTimeInNanos,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external bool AnimationManager_addGltfAnimationComponent(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external bool AnimationManager_removeGltfAnimationComponent(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TAnimationManager>, EntityId)>(
    isLeaf: true)
external void AnimationManager_addMorphAnimationComponent(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TAnimationManager>, EntityId)>(
    isLeaf: true)
external void AnimationManager_removeMorphAnimationComponent(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external bool AnimationManager_addBoneAnimationComponent(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external bool AnimationManager_removeBoneAnimationComponent(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>,
        EntityId,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Uint32>,
        ffi.Int,
        ffi.Int,
        ffi.Float)>(isLeaf: true)
external bool AnimationManager_setMorphAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  ffi.Pointer<ffi.Float> morphData,
  ffi.Pointer<ffi.Uint32> morphIndices,
  int numMorphTargets,
  int numFrames,
  double frameLengthInMs,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TAnimationManager>, EntityId)>(
    isLeaf: true)
external bool AnimationManager_clearMorphAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external void AnimationManager_resetToRestPose(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>,
        ffi.Pointer<TSceneAsset>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float)>(isLeaf: true)
external bool AnimationManager_addBoneAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> frameData,
  int numFrames,
  double frameLengthInMs,
  double fadeOutInSecs,
  double fadeInInSecs,
  double maxDelta,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Int)>(isLeaf: true)
external int AnimationManager_getBone(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  int boneIndex,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getRestLocalTransforms(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  ffi.Pointer<ffi.Float> out,
  int numBones,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Int, ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void AnimationManager_getInverseBindMatrix(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> out,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>,
        ffi.Pointer<TSceneAsset>,
        ffi.Int,
        ffi.Bool,
        ffi.Bool,
        ffi.Bool,
        ffi.Float,
        ffi.Float)>(isLeaf: true)
external bool AnimationManager_playGltfAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
  int index,
  bool loop,
  bool reverse,
  bool replaceActive,
  double crossfade,
  double startOffset,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int)>(isLeaf: true)
external bool AnimationManager_stopGltfAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int index,
);

@ffi.Native<
    ffi.Float Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int)>(isLeaf: true)
external double AnimationManager_getGltfAnimationDuration(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int animationIndex,
);

@ffi.Native<
    ffi.Int Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int AnimationManager_getGltfAnimationCount(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getGltfAnimationName(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int)>(isLeaf: true)
external int AnimationManager_getBoneCount(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getBoneNames(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  ffi.Pointer<ffi.Pointer<ffi.Char>> out,
  int skinIndex,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        EntityId)>(isLeaf: true)
external int AnimationManager_getMorphTargetNameCount(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int childEntity,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        EntityId, ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getMorphTargetName(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int childEntity,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external bool AnimationManager_updateBoneMatrices(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TAnimationManager>, EntityId,
        ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external bool AnimationManager_setMorphTargetWeights(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  ffi.Pointer<ffi.Float> morphData,
  int numWeights,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Int)>(isLeaf: true)
external void AnimationManager_setGltfAnimationFrame(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
  int animationIndex,
  int frame,
);

typedef EntityId = ffi.Int32;
typedef DartEntityId = int;

final class TCamera extends ffi.Opaque {}

final class TEngine extends ffi.Opaque {}

final class TEntityManager extends ffi.Opaque {}

final class TViewer extends ffi.Opaque {}

final class TSceneManager extends ffi.Opaque {}

final class TLightManager extends ffi.Opaque {}

final class TRenderer extends ffi.Opaque {}

final class TRenderTicker extends ffi.Opaque {}

final class TFence extends ffi.Opaque {}

final class TRenderTarget extends ffi.Opaque {}

final class TSwapChain extends ffi.Opaque {}

final class TView extends ffi.Opaque {}

final class TGizmo extends ffi.Opaque {}

final class TScene extends ffi.Opaque {}

final class TSkybox extends ffi.Opaque {}

final class TIndirectLight extends ffi.Opaque {}

final class TTransformManager extends ffi.Opaque {}

final class TAnimationManager extends ffi.Opaque {}

final class TCollisionComponentManager extends ffi.Opaque {}

final class TSceneAsset extends ffi.Opaque {}

final class TNameComponentManager extends ffi.Opaque {}

final class TMaterial extends ffi.Opaque {}

final class TMaterialInstance extends ffi.Opaque {}

final class TMaterialProvider extends ffi.Opaque {}

final class TRenderableManager extends ffi.Opaque {}

final class TRenderableInstance extends ffi.Opaque {}

final class TTexture extends ffi.Opaque {}

final class TTextureSampler extends ffi.Opaque {}

final class TLinearImage extends ffi.Opaque {}

final class TGltfAssetLoader extends ffi.Opaque {}

final class TGltfResourceLoader extends ffi.Opaque {}

final class TFilamentAsset extends ffi.Opaque {}

final class TColorGrading extends ffi.Opaque {}

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.Bool()
  external bool hasMetallicRoughnessTexture;

  @ffi.Uint8()
  external int metallicRoughnessUV;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.Bool()
  external bool hasSpecularGlossinessTexture;

  @ffi.Uint8()
  external int specularGlossinessUV;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 unnamed;

  external UnnamedStruct2 unnamed$1;
}

final class TMaterialKey extends ffi.Struct {
  @ffi.Bool()
  external bool doubleSided;

  @ffi.Bool()
  external bool unlit;

  @ffi.Bool()
  external bool hasVertexColors;

  @ffi.Bool()
  external bool hasBaseColorTexture;

  @ffi.Bool()
  external bool hasNormalTexture;

  @ffi.Bool()
  external bool hasOcclusionTexture;

  @ffi.Bool()
  external bool hasEmissiveTexture;

  @ffi.Bool()
  external bool useSpecularGlossiness;

  @ffi.Int()
  external int alphaMode;

  @ffi.Bool()
  external bool enableDiagnostics;

  external UnnamedUnion1 unnamed;

  @ffi.Uint8()
  external int baseColorUV;

  @ffi.Bool()
  external bool hasClearCoatTexture;

  @ffi.Uint8()
  external int clearCoatUV;

  @ffi.Bool()
  external bool hasClearCoatRoughnessTexture;

  @ffi.Uint8()
  external int clearCoatRoughnessUV;

  @ffi.Bool()
  external bool hasClearCoatNormalTexture;

  @ffi.Uint8()
  external int clearCoatNormalUV;

  @ffi.Bool()
  external bool hasClearCoat;

  @ffi.Bool()
  external bool hasTransmission;

  @ffi.Bool()
  external bool hasTextureTransforms;

  @ffi.Uint8()
  external int emissiveUV;

  @ffi.Uint8()
  external int aoUV;

  @ffi.Uint8()
  external int normalUV;

  @ffi.Bool()
  external bool hasTransmissionTexture;

  @ffi.Uint8()
  external int transmissionUV;

  @ffi.Bool()
  external bool hasSheenColorTexture;

  @ffi.Uint8()
  external int sheenColorUV;

  @ffi.Bool()
  external bool hasSheenRoughnessTexture;

  @ffi.Uint8()
  external int sheenRoughnessUV;

  @ffi.Bool()
  external bool hasVolumeThicknessTexture;

  @ffi.Uint8()
  external int volumeThicknessUV;

  @ffi.Bool()
  external bool hasSheen;

  @ffi.Bool()
  external bool hasIOR;

  @ffi.Bool()
  external bool hasVolume;
}

final class double3 extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;

  @ffi.Double()
  external double z;
}

final class double3x3 extends ffi.Struct {
  external double3 col1;

  external double3 col2;

  external double3 col3;
}

final class double4 extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;

  @ffi.Double()
  external double z;

  @ffi.Double()
  external double w;
}

final class double4x4 extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col1;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col2;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col3;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col4;
}

final class Aabb2 extends ffi.Struct {
  @ffi.Float()
  external double minX;

  @ffi.Float()
  external double minY;

  @ffi.Float()
  external double maxX;

  @ffi.Float()
  external double maxY;
}

final class Aabb3 extends ffi.Struct {
  @ffi.Float()
  external double centerX;

  @ffi.Float()
  external double centerY;

  @ffi.Float()
  external double centerZ;

  @ffi.Float()
  external double halfExtentX;

  @ffi.Float()
  external double halfExtentY;

  @ffi.Float()
  external double halfExtentZ;
}

sealed class TGizmoType {
  static const GIZMO_TYPE_TRANSLATION = 0;
  static const GIZMO_TYPE_ROTATION = 1;
}

sealed class TPrimitiveType {
  /// !< points
  static const PRIMITIVETYPE_POINTS = 0;

  /// !< lines
  static const PRIMITIVETYPE_LINES = 1;

  /// !< line strip
  static const PRIMITIVETYPE_LINE_STRIP = 3;

  /// !< triangles
  static const PRIMITIVETYPE_TRIANGLES = 4;

  /// !< triangle strip
  static const PRIMITIVETYPE_TRIANGLE_STRIP = 5;
}

sealed class TSamplerCompareFunc {
  /// !< Less or equal
  static const LE = 0;

  /// !< Greater or equal
  static const GE = 1;

  /// !< Strictly less than
  static const L = 2;

  /// !< Strictly greater than
  static const G = 3;

  /// !< Equal
  static const E = 4;

  /// !< Not equal
  static const NE = 5;

  /// !< Always. Depth / stencil testing is deactivated.
  static const A = 6;

  /// !< Never. The depth / stencil test always fails.
  static const N = 7;
}

sealed class TStencilOperation {
  static const KEEP = 0;
  static const ZERO = 1;
  static const REPLACE = 2;
  static const INCR = 3;
  static const INCR_WRAP = 4;
  static const DECR = 5;
  static const DECR_WRAP = 6;
  static const INVERT = 7;
}

sealed class TStencilFace {
  static const STENCIL_FACE_FRONT = 1;
  static const STENCIL_FACE_BACK = 2;
  static const STENCIL_FACE_FRONT_AND_BACK = 3;
}

sealed class TCullingMode {
  static const CULLING_MODE_NONE = 0;
  static const CULLING_MODE_FRONT = 1;
  static const CULLING_MODE_BACK = 2;
  static const CULLING_MODE_FRONT_AND_BACK = 3;
}

sealed class TTransparencyMode {
  /// ! the transparent object is drawn honoring the raster state
  static const DEFAULT = 0;

  /// the transparent object is first drawn in the depth buffer,
  /// then in the color buffer, honoring the culling mode, but ignoring the depth test function
  static const TWO_PASSES_ONE_SIDE = 1;

  /// the transparent object is drawn twice in the color buffer,
  /// first with back faces only, then with front faces; the culling
  /// mode is ignored. Can be combined with two-sided lighting
  static const TWO_PASSES_TWO_SIDES = 2;
}

sealed class TLightType {
  static const LIGHT_TYPE_SUN = 0;
  static const LIGHT_TYPE_DIRECTIONAL = 1;
  static const LIGHT_TYPE_POINT = 2;
  static const LIGHT_TYPE_FOCUSED_SPOT = 3;
  static const LIGHT_TYPE_SPOT = 4;
}

final class TViewport extends ffi.Struct {
  @ffi.Int32()
  external int left;

  @ffi.Int32()
  external int bottom;

  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;
}

sealed class TToneMapping {
  static const ACES = 0;
  static const FILMIC = 1;
  static const LINEAR = 2;
}

sealed class TQualityLevel {
  static const LOW = 0;
  static const MEDIUM = 1;
  static const HIGH = 2;
  static const ULTRA = 3;
}

sealed class TBlendMode {
  static const OPAQUE = 0;
  static const TRANSLUCENT = 1;
}

typedef PickCallbackFunction = ffi.Void Function(
    ffi.Uint32 requestId,
    EntityId entityId,
    ffi.Float depth,
    ffi.Float fragX,
    ffi.Float fragY,
    ffi.Float fragZ);
typedef DartPickCallbackFunction = void Function(
    int requestId,
    DartEntityId entityId,
    double depth,
    double fragX,
    double fragY,
    double fragZ);
typedef PickCallback = ffi.Pointer<ffi.NativeFunction<PickCallbackFunction>>;

sealed class TTextureSamplerType {
  static const SAMPLER_2D = 0;
  static const SAMPLER_2D_ARRAY = 1;
  static const SAMPLER_CUBEMAP = 2;
  static const SAMPLER_EXTERNAL = 3;
  static const SAMPLER_3D = 4;
  static const SAMPLER_CUBEMAP_ARRAY = 5;
}

sealed class TTextureFormat {
  static const TEXTUREFORMAT_R8 = 0;
  static const TEXTUREFORMAT_R8_SNORM = 1;
  static const TEXTUREFORMAT_R8UI = 2;
  static const TEXTUREFORMAT_R8I = 3;
  static const TEXTUREFORMAT_STENCIL8 = 4;
  static const TEXTUREFORMAT_R16F = 5;
  static const TEXTUREFORMAT_R16UI = 6;
  static const TEXTUREFORMAT_R16I = 7;
  static const TEXTUREFORMAT_RG8 = 8;
  static const TEXTUREFORMAT_RG8_SNORM = 9;
  static const TEXTUREFORMAT_RG8UI = 10;
  static const TEXTUREFORMAT_RG8I = 11;
  static const TEXTUREFORMAT_RGB565 = 12;
  static const TEXTUREFORMAT_RGB9_E5 = 13;
  static const TEXTUREFORMAT_RGB5_A1 = 14;
  static const TEXTUREFORMAT_RGBA4 = 15;
  static const TEXTUREFORMAT_DEPTH16 = 16;
  static const TEXTUREFORMAT_RGB8 = 17;
  static const TEXTUREFORMAT_SRGB8 = 18;
  static const TEXTUREFORMAT_RGB8_SNORM = 19;
  static const TEXTUREFORMAT_RGB8UI = 20;
  static const TEXTUREFORMAT_RGB8I = 21;
  static const TEXTUREFORMAT_DEPTH24 = 22;
  static const TEXTUREFORMAT_R32F = 23;
  static const TEXTUREFORMAT_R32UI = 24;
  static const TEXTUREFORMAT_R32I = 25;
  static const TEXTUREFORMAT_RG16F = 26;
  static const TEXTUREFORMAT_RG16UI = 27;
  static const TEXTUREFORMAT_RG16I = 28;
  static const TEXTUREFORMAT_R11F_G11F_B10F = 29;
  static const TEXTUREFORMAT_RGBA8 = 30;
  static const TEXTUREFORMAT_SRGB8_A8 = 31;
  static const TEXTUREFORMAT_RGBA8_SNORM = 32;
  static const TEXTUREFORMAT_UNUSED = 33;
  static const TEXTUREFORMAT_RGB10_A2 = 34;
  static const TEXTUREFORMAT_RGBA8UI = 35;
  static const TEXTUREFORMAT_RGBA8I = 36;
  static const TEXTUREFORMAT_DEPTH32F = 37;
  static const TEXTUREFORMAT_DEPTH24_STENCIL8 = 38;
  static const TEXTUREFORMAT_DEPTH32F_STENCIL8 = 39;
  static const TEXTUREFORMAT_RGB16F = 40;
  static const TEXTUREFORMAT_RGB16UI = 41;
  static const TEXTUREFORMAT_RGB16I = 42;
  static const TEXTUREFORMAT_RG32F = 43;
  static const TEXTUREFORMAT_RG32UI = 44;
  static const TEXTUREFORMAT_RG32I = 45;
  static const TEXTUREFORMAT_RGBA16F = 46;
  static const TEXTUREFORMAT_RGBA16UI = 47;
  static const TEXTUREFORMAT_RGBA16I = 48;
  static const TEXTUREFORMAT_RGB32F = 49;
  static const TEXTUREFORMAT_RGB32UI = 50;
  static const TEXTUREFORMAT_RGB32I = 51;
  static const TEXTUREFORMAT_RGBA32F = 52;
  static const TEXTUREFORMAT_RGBA32UI = 53;
  static const TEXTUREFORMAT_RGBA32I = 54;
  static const TEXTUREFORMAT_EAC_R11 = 55;
  static const TEXTUREFORMAT_EAC_R11_SIGNED = 56;
  static const TEXTUREFORMAT_EAC_RG11 = 57;
  static const TEXTUREFORMAT_EAC_RG11_SIGNED = 58;
  static const TEXTUREFORMAT_ETC2_RGB8 = 59;
  static const TEXTUREFORMAT_ETC2_SRGB8 = 60;
  static const TEXTUREFORMAT_ETC2_RGB8_A1 = 61;
  static const TEXTUREFORMAT_ETC2_SRGB8_A1 = 62;
  static const TEXTUREFORMAT_ETC2_EAC_RGBA8 = 63;
  static const TEXTUREFORMAT_ETC2_EAC_SRGBA8 = 64;
  static const TEXTUREFORMAT_DXT1_RGB = 65;
  static const TEXTUREFORMAT_DXT1_RGBA = 66;
  static const TEXTUREFORMAT_DXT3_RGBA = 67;
  static const TEXTUREFORMAT_DXT5_RGBA = 68;
  static const TEXTUREFORMAT_DXT1_SRGB = 69;
  static const TEXTUREFORMAT_DXT1_SRGBA = 70;
  static const TEXTUREFORMAT_DXT3_SRGBA = 71;
  static const TEXTUREFORMAT_DXT5_SRGBA = 72;
  static const TEXTUREFORMAT_RGBA_ASTC_4x4 = 73;
  static const TEXTUREFORMAT_RGBA_ASTC_5x4 = 74;
  static const TEXTUREFORMAT_RGBA_ASTC_5x5 = 75;
  static const TEXTUREFORMAT_RGBA_ASTC_6x5 = 76;
  static const TEXTUREFORMAT_RGBA_ASTC_6x6 = 77;
  static const TEXTUREFORMAT_RGBA_ASTC_8x5 = 78;
  static const TEXTUREFORMAT_RGBA_ASTC_8x6 = 79;
  static const TEXTUREFORMAT_RGBA_ASTC_8x8 = 80;
  static const TEXTUREFORMAT_RGBA_ASTC_10x5 = 81;
  static const TEXTUREFORMAT_RGBA_ASTC_10x6 = 82;
  static const TEXTUREFORMAT_RGBA_ASTC_10x8 = 83;
  static const TEXTUREFORMAT_RGBA_ASTC_10x10 = 84;
  static const TEXTUREFORMAT_RGBA_ASTC_12x10 = 85;
  static const TEXTUREFORMAT_RGBA_ASTC_12x12 = 86;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_4x4 = 87;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x4 = 88;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x5 = 89;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x5 = 90;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x6 = 91;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x5 = 92;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x6 = 93;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x8 = 94;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x5 = 95;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x6 = 96;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x8 = 97;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x10 = 98;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x10 = 99;
  static const TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x12 = 100;
  static const TEXTUREFORMAT_RED_RGTC1 = 101;
  static const TEXTUREFORMAT_SIGNED_RED_RGTC1 = 102;
  static const TEXTUREFORMAT_RED_GREEN_RGTC2 = 103;
  static const TEXTUREFORMAT_SIGNED_RED_GREEN_RGTC2 = 104;
  static const TEXTUREFORMAT_RGB_BPTC_SIGNED_FLOAT = 105;
  static const TEXTUREFORMAT_RGB_BPTC_UNSIGNED_FLOAT = 106;
  static const TEXTUREFORMAT_RGBA_BPTC_UNORM = 107;
  static const TEXTUREFORMAT_SRGB_ALPHA_BPTC_UNORM = 108;
}

/// ! Pixel Data Format
sealed class TPixelDataFormat {
  /// !< One Red channel, float
  static const PIXELDATAFORMAT_R = 0;

  /// !< One Red channel, integer
  static const PIXELDATAFORMAT_R_INTEGER = 1;

  /// !< Two Red and Green channels, float
  static const PIXELDATAFORMAT_RG = 2;

  /// !< Two Red and Green channels, integer
  static const PIXELDATAFORMAT_RG_INTEGER = 3;

  /// !< Three Red, Green and Blue channels, float
  static const PIXELDATAFORMAT_RGB = 4;

  /// !< Three Red, Green and Blue channels, integer
  static const PIXELDATAFORMAT_RGB_INTEGER = 5;

  /// !< Four Red, Green, Blue and Alpha channels, float
  static const PIXELDATAFORMAT_RGBA = 6;

  /// !< Four Red, Green, Blue and Alpha channels, integer
  static const PIXELDATAFORMAT_RGBA_INTEGER = 7;
  static const PIXELDATAFORMAT_UNUSED = 8;

  /// !< Depth, 16-bit or 24-bits usually
  static const PIXELDATAFORMAT_DEPTH_COMPONENT = 9;

  /// !< Two Depth (24-bits) + Stencil (8-bits) channels
  static const PIXELDATAFORMAT_DEPTH_STENCIL = 10;
  static const PIXELDATAFORMAT_ALPHA = 11;
}

sealed class TPixelDataType {
  /// !< unsigned byte
  static const PIXELDATATYPE_UBYTE = 0;

  /// !< signed byte
  static const PIXELDATATYPE_BYTE = 1;

  /// !< unsigned short (16-bit)
  static const PIXELDATATYPE_USHORT = 2;

  /// !< signed short (16-bit)
  static const PIXELDATATYPE_SHORT = 3;

  /// !< unsigned int (32-bit)
  static const PIXELDATATYPE_UINT = 4;

  /// !< signed int (32-bit)
  static const PIXELDATATYPE_INT = 5;

  /// !< half-float (16-bit float)
  static const PIXELDATATYPE_HALF = 6;

  /// !< float (32-bits float)
  static const PIXELDATATYPE_FLOAT = 7;

  /// !< compressed pixels, @see CompressedPixelDataType
  static const PIXELDATATYPE_COMPRESSED = 8;

  /// !< three low precision floating-point numbers
  static const PIXELDATATYPE_UINT_10F_11F_11F_REV = 9;

  /// !< unsigned int (16-bit), encodes 3 RGB channels
  static const PIXELDATATYPE_USHORT_565 = 10;

  /// !< unsigned normalized 10 bits RGB, 2 bits alpha
  static const PIXELDATATYPE_UINT_2_10_10_10_REV = 11;
}

sealed class TTextureUsage {
  static const TEXTURE_USAGE_NONE = 0;

  /// !< Texture can be used as a color attachment
  static const TEXTURE_USAGE_COLOR_ATTACHMENT = 1;

  /// !< Texture can be used as a depth attachment
  static const TEXTURE_USAGE_DEPTH_ATTACHMENT = 2;

  /// !< Texture can be used as a stencil attachment
  static const TEXTURE_USAGE_STENCIL_ATTACHMENT = 4;

  /// !< Data can be uploaded into this texture (default)
  static const TEXTURE_USAGE_UPLOADABLE = 8;

  /// !< Texture can be sampled (default)
  static const TEXTURE_USAGE_SAMPLEABLE = 16;

  /// !< Texture can be used as a subpass input
  static const TEXTURE_USAGE_SUBPASS_INPUT = 32;

  /// !< Texture can be used the source of a blit()
  static const TEXTURE_USAGE_BLIT_SRC = 64;

  /// !< Texture can be used the destination of a blit()
  static const TEXTURE_USAGE_BLIT_DST = 128;

  /// !< Texture can be used the destination of a blit()
  static const TEXTURE_USAGE_PROTECTED = 256;

  /// !< Default texture usage
  static const TEXTURE_USAGE_DEFAULT = 24;
}

sealed class TSamplerWrapMode {
  static const WRAP_CLAMP_TO_EDGE = 0;
  static const WRAP_REPEAT = 1;
  static const WRAP_MIRRORED_REPEAT = 2;
}

sealed class TSamplerMinFilter {
  static const FILTER_NEAREST = 0;
  static const FILTER_LINEAR = 1;
  static const FILTER_NEAREST_MIPMAP_NEAREST = 2;
  static const FILTER_LINEAR_MIPMAP_NEAREST = 3;
  static const FILTER_NEAREST_MIPMAP_LINEAR = 4;
  static const FILTER_LINEAR_MIPMAP_LINEAR = 5;
}

sealed class TSamplerMagFilter {
  static const MAG_FILTER_NEAREST = 0;
  static const MAG_FILTER_LINEAR = 1;
}

sealed class TSamplerCompareMode {
  static const COMPARE_MODE_NONE = 0;
  static const COMPARE_MODE_COMPARE_TO_TEXTURE = 1;
}

sealed class TGizmoAxis {
  static const X = 0;
  static const Y = 1;
  static const Z = 2;
}

sealed class TGizmoPickResultType {
  static const AxisX = 0;
  static const AxisY = 1;
  static const AxisZ = 2;
  static const Parent = 3;
  static const None = 4;
}

typedef GizmoPickCallbackFunction = ffi.Void Function(
    ffi.UnsignedInt resultType, ffi.Float x, ffi.Float y, ffi.Float z);
typedef DartGizmoPickCallbackFunction = void Function(
    int resultType, double x, double y, double z);
typedef GizmoPickCallback
    = ffi.Pointer<ffi.NativeFunction<GizmoPickCallbackFunction>>;

sealed class TProjection {
  static const Perspective = 0;
  static const Orthographic = 1;
}

sealed class TBackend {
  /// !< Automatically selects an appropriate driver for the platform.
  static const BACKEND_DEFAULT = 0;

  /// !< Selects the OpenGL/ES driver (default on Android)
  static const BACKEND_OPENGL = 1;

  /// !< Selects the Vulkan driver if the platform supports it (default on Linux/Windows)
  static const BACKEND_VULKAN = 2;

  /// !< Selects the Metal driver if the platform supports it (default on MacOS/iOS).
  static const BACKEND_METAL = 3;

  /// !< Selects the no-op driver for testing purposes.
  static const BACKEND_NOOP = 4;
}

typedef VoidCallbackFunction = ffi.Void Function();
typedef DartVoidCallbackFunction = void Function();
typedef VoidCallback = ffi.Pointer<ffi.NativeFunction<VoidCallbackFunction>>;
typedef FilamentRenderCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> owner);
typedef DartFilamentRenderCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> owner);
typedef FilamentRenderCallback
    = ffi.Pointer<ffi.NativeFunction<FilamentRenderCallbackFunction>>;

const int __bool_true_false_are_defined = 1;

const int true$ = 1;

const int false$ = 0;
