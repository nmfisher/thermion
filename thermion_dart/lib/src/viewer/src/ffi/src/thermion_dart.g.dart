// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('package:thermion_dart/thermion_dart.dart')
library;

import 'dart:ffi' as ffi;

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(LoadFilamentResourceFromOwner,
        FreeFilamentResourceFromOwner, ffi.Pointer<ffi.Void>)>(isLeaf: true)
external ffi.Pointer<ffi.Void> make_resource_loader(
  LoadFilamentResourceFromOwner loadFn,
  FreeFilamentResourceFromOwner freeFn,
  ffi.Pointer<ffi.Void> owner,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void destroy_filament_viewer(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Pointer<TSceneManager> Function(ffi.Pointer<TViewer>)>(
    isLeaf: true)
external ffi.Pointer<TSceneManager> Viewer_getSceneManager(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Pointer<TRenderTarget> Function(
        ffi.Pointer<TViewer>, ffi.IntPtr, ffi.Uint32, ffi.Uint32)>(isLeaf: true)
external ffi.Pointer<TRenderTarget> Viewer_createRenderTarget(
  ffi.Pointer<TViewer> viewer,
  int texture,
  int width,
  int height,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Pointer<TRenderTarget>)>(isLeaf: true)
external void Viewer_destroyRenderTarget(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TRenderTarget> tRenderTarget,
);

@ffi.Native<
    ffi.Pointer<TSwapChain> Function(
        ffi.Pointer<TViewer>, ffi.Pointer<ffi.Void>)>(isLeaf: true)
external ffi.Pointer<TSwapChain> Viewer_createSwapChain(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Void> window,
);

@ffi.Native<
    ffi.Pointer<TSwapChain> Function(
        ffi.Pointer<TViewer>, ffi.Uint32, ffi.Uint32)>(isLeaf: true)
external ffi.Pointer<TSwapChain> Viewer_createHeadlessSwapChain(
  ffi.Pointer<TViewer> viewer,
  int width,
  int height,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TSwapChain>)>(
    isLeaf: true)
external void Viewer_destroySwapChain(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TSwapChain> swapChain,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void Viewer_render(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TSwapChain>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_capture(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> view,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<ffi.Uint8> pixelBuffer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TSwapChain>,
        ffi.Pointer<TRenderTarget>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_captureRenderTarget(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> view,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<TRenderTarget> renderTarget,
  ffi.Pointer<ffi.Uint8> pixelBuffer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<ffi.Pointer<TView> Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external ffi.Pointer<TView> Viewer_createView(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Pointer<TView> Function(ffi.Pointer<TViewer>, ffi.Int)>(
    isLeaf: true)
external ffi.Pointer<TView> Viewer_getViewAt(
  ffi.Pointer<TViewer> viewer,
  int index,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TView>)>(
    isLeaf: true)
external void Viewer_setMainCamera(
  ffi.Pointer<TViewer> tViewer,
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Pointer<TSwapChain> Function(ffi.Pointer<TViewer>, ffi.Int)>(
    isLeaf: true)
external ffi.Pointer<TSwapChain> Viewer_getSwapChainAt(
  ffi.Pointer<TViewer> tViewer,
  int index,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TSwapChain>,
        ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void Viewer_setViewRenderable(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<TView> view,
  bool renderable,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Pointer<TView>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(EntityId entityId, ffi.Int x, ffi.Int y,
                    ffi.Pointer<TView> tView)>>)>(isLeaf: true)
external void Viewer_pick(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> tView,
  int x,
  int y,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(EntityId entityId, ffi.Int x, ffi.Int y,
                  ffi.Pointer<TView> tView)>>
      callback,
);

@ffi.Native<ffi.Pointer<TEngine> Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external ffi.Pointer<TEngine> Viewer_getEngine(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TEngine>, EntityId)>(
    isLeaf: true)
external ffi.Pointer<TCamera> Engine_getCameraComponent(
  ffi.Pointer<TEngine> tEngine,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, EntityId, double4x4)>(
    isLeaf: true)
external void Engine_setTransform(
  ffi.Pointer<TEngine> tEngine,
  int entity,
  double4x4 transform,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_background_image(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Bool)>(isLeaf: true)
external void set_background_image(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> path,
  bool fillHeight,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Bool)>(isLeaf: true)
external void set_background_image_position(
  ffi.Pointer<TViewer> viewer,
  double x,
  double y,
  bool clamp,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void set_background_color(
  ffi.Pointer<TViewer> viewer,
  double r,
  double g,
  double b,
  double a,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>)>(
    isLeaf: true)
external void load_skybox(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> skyboxPath,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Float)>(isLeaf: true)
external void load_ibl(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> iblPath,
  double intensity,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void create_ibl(
  ffi.Pointer<TViewer> viewer,
  double r,
  double g,
  double b,
  double intensity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Float>)>(
    isLeaf: true)
external void rotate_ibl(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Float> rotationMatrix,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void remove_skybox(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void remove_ibl(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    EntityId Function(
        ffi.Pointer<TViewer>,
        ffi.Uint8,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Bool)>(isLeaf: true)
external int add_light(
  ffi.Pointer<TViewer> viewer,
  int type,
  double colour,
  double intensity,
  double posX,
  double posY,
  double posZ,
  double dirX,
  double dirY,
  double dirZ,
  double falloffRadius,
  double spotLightConeInner,
  double spotLightConeOuter,
  double sunAngularRadius,
  double sunHaloSize,
  double sunHaloFallof,
  bool shadows,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, EntityId)>(isLeaf: true)
external void remove_light(
  ffi.Pointer<TViewer> viewer,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_lights(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, EntityId, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void set_light_position(
  ffi.Pointer<TViewer> viewer,
  int light,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, EntityId, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void set_light_direction(
  ffi.Pointer<TViewer> viewer,
  int light,
  double x,
  double y,
  double z,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TSceneManager>, ffi.Pointer<ffi.Char>,
        ffi.Int, ffi.Bool)>(isLeaf: true)
external int load_glb(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  int numInstances,
  bool keepData,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TSceneManager>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>, ffi.Bool)>(isLeaf: true)
external int load_gltf(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  ffi.Pointer<ffi.Char> relativePath,
  bool keepData,
);

@ffi.Native<EntityId Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int create_instance(
  ffi.Pointer<TSceneManager> sceneManager,
  int id,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int get_instance_count(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<EntityId>)>(isLeaf: true)
external void get_instances(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<EntityId> out,
);

@ffi.Native<EntityId Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external int get_main_camera(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float)>(isLeaf: true)
external void set_frame_interval(
  ffi.Pointer<TViewer> viewer,
  double interval,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external void apply_weights(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Char> entityName,
  ffi.Pointer<ffi.Float> weights,
  int count,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external bool set_morph_target_weights(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Float> morphData,
  int numWeights,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TSceneManager>, TMaterialKey)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> create_material_instance(
  ffi.Pointer<TSceneManager> sceneManager,
  TMaterialKey materialConfig,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TSceneManager>)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> create_unlit_material_instance(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>,
        ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external void destroy_material_instance(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TMaterialInstance> instance,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void clear_morph_animation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void reset_to_rest_pose(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float)>(isLeaf: true)
external void add_bone_animation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> frameData,
  int numFrames,
  double frameLengthInMs,
  double fadeOutInSecs,
  double fadeInInSecs,
  double maxDelta,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void get_local_transform(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.Float> arg2,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int,
        ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external void get_rest_local_transforms(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  int skinIndex,
  ffi.Pointer<ffi.Float> out,
  int numBones,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void get_world_transform(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.Float> arg2,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Int,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void get_inverse_bind_matrix(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> arg4,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Int,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external bool set_bone_transform(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> transform,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Bool,
        ffi.Bool, ffi.Bool, ffi.Float, ffi.Float)>(isLeaf: true)
external void play_animation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int index,
  bool loop,
  bool reverse,
  bool replaceActive,
  double crossfade,
  double startOffset,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Int)>(isLeaf: true)
external void set_animation_frame(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int animationIndex,
  int animationFrame,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external void stop_animation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int index,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int get_animation_count(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void get_animation_name(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
);

@ffi.Native<ffi.Float Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external double get_animation_duration(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int index,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external int get_bone_count(
  ffi.Pointer<TSceneManager> sceneManager,
  int assetEntity,
  int skinIndex,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>(isLeaf: true)
external void get_bone_names(
  ffi.Pointer<TSceneManager> sceneManager,
  int assetEntity,
  ffi.Pointer<ffi.Pointer<ffi.Char>> outPtr,
  int skinIndex,
);

@ffi.Native<
    EntityId Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Int)>(isLeaf: true)
external int get_bone(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  int skinIndex,
  int boneIndex,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Double>)>(isLeaf: true)
external bool SceneManager_setTransform(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.Double> transform,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, ffi.Pointer<EntityId>,
        ffi.Pointer<ffi.Double>, ffi.Int)>(isLeaf: true)
external void SceneManager_queueTransformUpdates(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<EntityId> entities,
  ffi.Pointer<ffi.Double> transforms,
  int numEntities,
);

@ffi.Native<
    ffi.Pointer<TCamera> Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>)>(isLeaf: true)
external ffi.Pointer<TCamera> SceneManager_findCameraByName(
  ffi.Pointer<TSceneManager> tSceneManager,
  int entity,
  ffi.Pointer<ffi.Char> name,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external void SceneManager_setVisibilityLayer(
  ffi.Pointer<TSceneManager> tSceneManager,
  int entity,
  int layer,
);

@ffi.Native<ffi.Pointer<TScene> Function(ffi.Pointer<TSceneManager>)>(
    isLeaf: true)
external ffi.Pointer<TScene> SceneManager_getScene(
  ffi.Pointer<TSceneManager> tSceneManager,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TSceneManager>, ffi.Pointer<ffi.Uint8>,
        ffi.Size, ffi.Bool, ffi.Int, ffi.Int, ffi.Bool)>(isLeaf: true)
external int SceneManager_loadGlbFromBuffer(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Uint8> arg1,
  int length,
  bool keepData,
  int priority,
  int layer,
  bool loadResourcesAsync,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Uint32>,
        ffi.Int,
        ffi.Int,
        ffi.Float)>(isLeaf: true)
external bool SceneManager_setMorphAnimation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Float> morphData,
  ffi.Pointer<ffi.Uint32> morphIndices,
  int numMorphTargets,
  int numFrames,
  double frameLengthInMs,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external bool update_bone_matrices(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, EntityId,
        ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void get_morph_target_name(
  ffi.Pointer<TSceneManager> sceneManager,
  int assetEntity,
  int childEntity,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId, EntityId)>(
    isLeaf: true)
external int get_morph_target_name_count(
  ffi.Pointer<TSceneManager> sceneManager,
  int assetEntity,
  int childEntity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, EntityId)>(isLeaf: true)
external void remove_entity(
  ffi.Pointer<TViewer> viewer,
  int asset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_entities(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Pointer<ffi.Char>,
        ffi.Int,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float)>(isLeaf: true)
external bool set_material_color(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Char> meshName,
  int materialIndex,
  double r,
  double g,
  double b,
  double a,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void transform_to_unit_cube(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void queue_relative_position_update_world_axis(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double viewportX,
  double viewportY,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, ffi.Pointer<TView>, EntityId,
        ffi.Float, ffi.Float)>(isLeaf: true)
external void queue_position_update_from_viewport_coords(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TView> view,
  int entity,
  double viewportX,
  double viewportY,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float)>(isLeaf: true)
external void set_position(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void set_rotation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double rads,
  double x,
  double y,
  double z,
  double w,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float)>(
    isLeaf: true)
external void set_scale(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double scale,
);

@ffi.Native<ffi.Pointer<TEntityManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TEntityManager> Engine_getEntityManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TSceneManager>)>(
    isLeaf: true)
external ffi.Pointer<TCamera> SceneManager_createCamera(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<TCamera>)>(isLeaf: true)
external void SceneManager_destroyCamera(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneManager>)>(isLeaf: true)
external int SceneManager_getCameraCount(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Pointer<TCamera> Function(
        ffi.Pointer<TSceneManager>, ffi.Size)>(isLeaf: true)
external ffi.Pointer<TCamera> SceneManager_getCameraAt(
  ffi.Pointer<TSceneManager> sceneManager,
  int index,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>)>(isLeaf: true)
external int hide_mesh(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Char> meshName,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>)>(isLeaf: true)
external int reveal_mesh(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Char> meshName,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TSceneManager>, EntityId)>(isLeaf: true)
external ffi.Pointer<ffi.Char> get_name_for_entity(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>)>(isLeaf: true)
external int find_child_entity_by_name(
  ffi.Pointer<TSceneManager> sceneManager,
  int parent,
  ffi.Pointer<ffi.Char> name,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Bool)>(
    isLeaf: true)
external int get_entity_count(
  ffi.Pointer<TSceneManager> sceneManager,
  int target,
  bool renderableOnly,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Bool,
        ffi.Pointer<EntityId>)>(isLeaf: true)
external void get_entities(
  ffi.Pointer<TSceneManager> sceneManager,
  int target,
  bool renderableOnly,
  ffi.Pointer<EntityId> out,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Bool)>(isLeaf: true)
external ffi.Pointer<ffi.Char> get_entity_name_at(
  ffi.Pointer<TSceneManager> sceneManager,
  int target,
  int index,
  bool renderableOnly,
);

@ffi.Native<ffi.Void Function()>(isLeaf: true)
external void ios_dummy();

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(isLeaf: true)
external void thermion_flutter_free(
  ffi.Pointer<ffi.Void> ptr,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(EntityId entityId1, EntityId entityId2)>>,
        ffi.Bool)>(isLeaf: true)
external void add_collision_component(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(EntityId entityId1, EntityId entityId2)>>
      callback,
  bool affectsCollidingTransform,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void remove_collision_component(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external bool add_animation_component(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void remove_animation_component(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<
    EntityId Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.Uint16>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<TMaterialInstance>,
        ffi.Bool)>(isLeaf: true)
external int create_geometry(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Float> vertices,
  int numVertices,
  ffi.Pointer<ffi.Float> normals,
  int numNormals,
  ffi.Pointer<ffi.Float> uvs,
  int numUvs,
  ffi.Pointer<ffi.Uint16> indices,
  int numIndices,
  int primitiveType,
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool keepData,
);

@ffi.Native<EntityId Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int get_parent(
  ffi.Pointer<TSceneManager> sceneManager,
  int child,
);

@ffi.Native<EntityId Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int get_ancestor(
  ffi.Pointer<TSceneManager> sceneManager,
  int child,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, EntityId, EntityId, ffi.Bool)>(isLeaf: true)
external void set_parent(
  ffi.Pointer<TSceneManager> sceneManager,
  int child,
  int parent,
  bool preserveScaling,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void test_collisions(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external void set_priority(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  int priority,
);

@ffi.Native<
    Aabb2 Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<TView>, EntityId)>(isLeaf: true)
external Aabb2 get_bounding_box(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TView> view,
  int entity,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<TView>,
        EntityId,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void get_bounding_box_to_out(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TView> view,
  int entity,
  ffi.Pointer<ffi.Float> minX,
  ffi.Pointer<ffi.Float> minY,
  ffi.Pointer<ffi.Float> maxX,
  ffi.Pointer<ffi.Float> maxY,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float)>(isLeaf: true)
external void set_stencil_highlight(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double r,
  double g,
  double b,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void remove_stencil_highlight(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int,
        ffi.Pointer<ffi.Char>, ffi.Float)>(isLeaf: true)
external void set_material_property_float(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int materialIndex,
  ffi.Pointer<ffi.Char> property,
  double value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int,
        ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void set_material_property_int(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int materialIndex,
  ffi.Pointer<ffi.Char> property,
  int value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int,
        ffi.Pointer<ffi.Char>, double4)>(isLeaf: true)
external void set_material_property_float4(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int materialIndex,
  ffi.Pointer<ffi.Char> property,
  double4 value,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Bool)>(isLeaf: true)
external void set_material_depth_write(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int materialIndex,
  bool enabled,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        EntityId,
        ffi.Pointer<ffi.Uint8>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint8>,
        ffi.Uint32,
        ffi.Uint32)>(isLeaf: true)
external void unproject_texture(
  ffi.Pointer<TViewer> viewer,
  int entity,
  ffi.Pointer<ffi.Uint8> input,
  int inputWidth,
  int inputHeight,
  ffi.Pointer<ffi.Uint8> out,
  int outWidth,
  int outHeight,
);

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.Uint8>, ffi.Size)>(isLeaf: true)
external ffi.Pointer<ffi.Void> create_texture(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Uint8> data,
  int length,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<ffi.Void>)>(isLeaf: true)
external void destroy_texture(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Void> texture,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void apply_texture_to_material(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Void> texture,
  ffi.Pointer<ffi.Char> parameterName,
  int materialIndex,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> get_material_instance_at(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int materialIndex,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setDepthWrite(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setDepthCulling(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat2(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> name,
  double x,
  double y,
);

@ffi.Native<TViewport Function(ffi.Pointer<TView>)>(isLeaf: true)
external TViewport View_getViewport(
  ffi.Pointer<TView> view,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Uint32, ffi.Uint32)>(
    isLeaf: true)
external void View_updateViewport(
  ffi.Pointer<TView> view,
  int width,
  int height,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TRenderTarget>)>(
    isLeaf: true)
external void View_setRenderTarget(
  ffi.Pointer<TView> view,
  ffi.Pointer<TRenderTarget> renderTarget,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setFrustumCullingEnabled(
  ffi.Pointer<TView> view,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setPostProcessing(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setShadowsEnabled(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Int)>(isLeaf: true)
external void View_setShadowType(
  ffi.Pointer<TView> tView,
  int shadowType,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Float, ffi.Float)>(
    isLeaf: true)
external void View_setSoftShadowOptions(
  ffi.Pointer<TView> tView,
  double penumbraScale,
  double penumbraRatioScale,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Float)>(isLeaf: true)
external void View_setBloom(
  ffi.Pointer<TView> tView,
  double strength,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TEngine>,
        ffi.UnsignedInt)>(symbol: "View_setToneMapping", isLeaf: true)
external void _View_setToneMapping(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TEngine> tEngine,
  int toneMapping,
);

void View_setToneMapping(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TEngine> tEngine,
  ToneMapping toneMapping,
) =>
    _View_setToneMapping(
      tView,
      tEngine,
      toneMapping.value,
    );

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TView>, ffi.Bool, ffi.Bool, ffi.Bool)>(isLeaf: true)
external void View_setAntiAliasing(
  ffi.Pointer<TView> tView,
  bool msaa,
  bool fxaa,
  bool taa,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Int, ffi.Bool)>(
    isLeaf: true)
external void View_setLayerEnabled(
  ffi.Pointer<TView> tView,
  int layer,
  bool visible,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TCamera>)>(
    isLeaf: true)
external void View_setCamera(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TCamera> tCamera,
);

@ffi.Native<ffi.Pointer<TScene> Function(ffi.Pointer<TView>)>(isLeaf: true)
external ffi.Pointer<TScene> View_getScene(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TView>)>(isLeaf: true)
external ffi.Pointer<TCamera> View_getCamera(
  ffi.Pointer<TView> tView,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> renderCallbackOwner)>>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TViewer> viewer)>>)>(isLeaf: true)
external void Viewer_createOnRenderThread(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<ffi.Void> platform,
  ffi.Pointer<ffi.Char> uberArchivePath,
  ffi.Pointer<ffi.Void> loader,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> renderCallbackOwner)>>
      renderCallback,
  ffi.Pointer<ffi.Void> renderCallbackOwner,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TViewer> viewer)>>
      callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TViewer>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>)>(
    isLeaf: true)
external void Viewer_createSwapChainRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Void> surface,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TViewer>,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>)>(
    isLeaf: true)
external void Viewer_createHeadlessSwapChainRenderThread(
  ffi.Pointer<TViewer> viewer,
  int width,
  int height,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TSwapChain>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_destroySwapChainRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TView>,
        ffi.Pointer<TSwapChain>)>(isLeaf: true)
external void Viewer_renderRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> view,
  ffi.Pointer<TSwapChain> swapChain,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TSwapChain>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_captureRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> view,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TSwapChain>,
        ffi.Pointer<TRenderTarget>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_captureRenderTargetRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> view,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<TRenderTarget> renderTarget,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_requestFrameRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TView>, ffi.Pointer<TEngine>, ffi.Int)>(isLeaf: true)
external void View_setToneMappingRenderThread(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TEngine> tEngine,
  int thermion,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Double)>(isLeaf: true)
external void View_setBloomRenderThread(
  ffi.Pointer<TView> tView,
  double bloom,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void destroy_filament_viewer_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<FilamentRenderCallback Function(FilamentRenderCallback)>(
    isLeaf: true)
external FilamentRenderCallback make_render_callback_fn_pointer(
  FilamentRenderCallback arg0,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Bool,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void set_rendering_render_thread(
  ffi.Pointer<TViewer> viewer,
  bool rendering,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float)>(isLeaf: true)
external void set_frame_interval_render_thread(
  ffi.Pointer<TViewer> viewer,
  double frameInterval,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void set_background_color_render_thread(
  ffi.Pointer<TViewer> viewer,
  double r,
  double g,
  double b,
  double a,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_background_image_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Bool,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void set_background_image_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> path,
  bool fillHeight,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Bool)>(isLeaf: true)
external void set_background_image_position_render_thread(
  ffi.Pointer<TViewer> viewer,
  double x,
  double y,
  bool clamp,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void load_skybox_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> skyboxPath,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void remove_skybox_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Int,
            ffi.Bool,
            ffi.Int,
            ffi.Int,
            ffi.Bool,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void SceneManager_loadGlbFromBufferRenderThread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  int numInstances,
  bool keepData,
  int priority,
  int layer,
  bool loadResourcesAsync,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Char>,
            ffi.Int,
            ffi.Bool,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void load_glb_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  int numInstances,
  bool keepData,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Bool,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void load_gltf_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  ffi.Pointer<ffi.Char> relativePath,
  bool keepData,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void create_instance_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, EntityId,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void remove_entity_render_thread(
  ffi.Pointer<TViewer> viewer,
  int asset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void clear_entities_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external void apply_weights_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.Char> entityName,
  ffi.Pointer<ffi.Float> weights,
  int count,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Int)>(isLeaf: true)
external void set_animation_frame_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  int animationIndex,
  int animationFrame,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external void stop_animation_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  int index,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>(
    isLeaf: true)
external void get_animation_count_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Pointer<ffi.Char>,
        ffi.Int,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void get_animation_name_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        EntityId,
        ffi.Pointer<ffi.Char>,
        ffi.Int,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void get_morph_target_name_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int assetEntity,
  int childEntity,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, EntityId,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>)>(
    isLeaf: true)
external void get_morph_target_name_count_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  int childEntity,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            EntityId,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void set_morph_target_weights_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.Float> morphData,
  int numWeights,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void update_bone_matrices_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            EntityId,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void set_bone_transform_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> transform,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Bool)>(isLeaf: true)
external void set_post_processing_render_thread(
  ffi.Pointer<TViewer> viewer,
  bool enabled,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void reset_to_rest_pose_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.Uint16>,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<TMaterialInstance>,
            ffi.Bool,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void create_geometry_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Float> vertices,
  int numVertices,
  ffi.Pointer<ffi.Float> normals,
  int numNormals,
  ffi.Pointer<ffi.Float> uvs,
  int numUvs,
  ffi.Pointer<ffi.Uint16> indices,
  int numIndices,
  int primitiveType,
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool keepData,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        EntityId,
        ffi.Pointer<ffi.Uint8>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint8>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void unproject_texture_render_thread(
  ffi.Pointer<TViewer> viewer,
  int entity,
  ffi.Pointer<ffi.Uint8> input,
  int inputWidth,
  int inputHeight,
  ffi.Pointer<ffi.Uint8> out,
  int outWidth,
  int outHeight,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void set_camera_exposure(
  ffi.Pointer<TCamera> camera,
  double aperture,
  double shutterSpeed,
  double sensitivity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, double4x4)>(isLeaf: true)
external void set_camera_model_matrix(
  ffi.Pointer<TCamera> camera,
  double4x4 matrix,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TViewer>, EntityId)>(
    isLeaf: true)
external ffi.Pointer<TCamera> get_camera(
  ffi.Pointer<TViewer> viewer,
  int entity,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_model_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_view_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_projection_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_culling_projection_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Pointer<ffi.Double> Function(ffi.Pointer<TCamera>)>(
    isLeaf: true)
external ffi.Pointer<ffi.Double> get_camera_frustum(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, double4x4, ffi.Double, ffi.Double)>(isLeaf: true)
external void set_camera_projection_matrix(
  ffi.Pointer<TCamera> camera,
  double4x4 matrix,
  double near,
  double far,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Double, ffi.Double, ffi.Double,
        ffi.Double, ffi.Bool)>(isLeaf: true)
external void set_camera_projection_from_fov(
  ffi.Pointer<TCamera> camera,
  double fovInDegrees,
  double aspect,
  double near,
  double far,
  bool horizontal,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double get_camera_focal_length(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getFocalLength(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getNear(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getCullingFar(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getViewMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getModelMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double get_camera_near(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double get_camera_culling_far(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Float Function(ffi.Pointer<TCamera>, ffi.Bool)>(isLeaf: true)
external double get_camera_fov(
  ffi.Pointer<TCamera> camera,
  bool horizontal,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, ffi.Float)>(isLeaf: true)
external void set_camera_focus_distance(
  ffi.Pointer<TCamera> camera,
  double focusDistance,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, double4x4, ffi.Double, ffi.Double)>(isLeaf: true)
external void Camera_setCustomProjectionWithCulling(
  ffi.Pointer<TCamera> camera,
  double4x4 projectionMatrix,
  double near,
  double far,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, double4x4)>(isLeaf: true)
external void Camera_setModelMatrix(
  ffi.Pointer<TCamera> camera,
  double4x4 modelMatrix,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Double, ffi.Double, ffi.Double,
        ffi.Double)>(isLeaf: true)
external void Camera_setLensProjection(
  ffi.Pointer<TCamera> camera,
  double near,
  double far,
  double aspect,
  double focalLength,
);

@ffi.Native<EntityId Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external int Camera_getEntity(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>,
        ffi.UnsignedInt,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double)>(symbol: "Camera_setProjection", isLeaf: true)
external void _Camera_setProjection(
  ffi.Pointer<TCamera> tCamera,
  int projection,
  double left,
  double right,
  double bottom,
  double top,
  double near,
  double far,
);

void Camera_setProjection(
  ffi.Pointer<TCamera> tCamera,
  Projection projection,
  double left,
  double right,
  double bottom,
  double top,
  double near,
  double far,
) =>
    _Camera_setProjection(
      tCamera,
      projection.value,
      left,
      right,
      bottom,
      top,
      near,
      far,
    );

@ffi.Native<
    ffi.Pointer<TGizmo> Function(ffi.Pointer<TEngine>, ffi.Pointer<TView>,
        ffi.Pointer<TScene>)>(isLeaf: true)
external ffi.Pointer<TGizmo> Gizmo_new(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TGizmo>, ffi.Uint32, ffi.Uint32,
        GizmoPickCallback)>(isLeaf: true)
external void Gizmo_pick(
  ffi.Pointer<TGizmo> tGizmo,
  int x,
  int y,
  GizmoPickCallback callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TGizmo>, ffi.Bool)>(isLeaf: true)
external void Gizmo_setVisibility(
  ffi.Pointer<TGizmo> tGizmo,
  bool visible,
);

final class TCamera extends ffi.Opaque {}

final class TMaterialInstance extends ffi.Opaque {}

final class TEngine extends ffi.Opaque {}

final class TEntityManager extends ffi.Opaque {}

final class TViewer extends ffi.Opaque {}

final class TSceneManager extends ffi.Opaque {}

final class TRenderTarget extends ffi.Opaque {}

final class TSwapChain extends ffi.Opaque {}

final class TView extends ffi.Opaque {}

final class TGizmo extends ffi.Opaque {}

final class TScene extends ffi.Opaque {}

final class TMaterialKey extends ffi.Struct {
  @ffi.Bool()
  external bool doubleSided;

  @ffi.Bool()
  external bool unlit;

  @ffi.Bool()
  external bool hasVertexColors;

  @ffi.Bool()
  external bool hasBaseColorTexture;

  @ffi.Bool()
  external bool hasNormalTexture;

  @ffi.Bool()
  external bool hasOcclusionTexture;

  @ffi.Bool()
  external bool hasEmissiveTexture;

  @ffi.Bool()
  external bool useSpecularGlossiness;

  @ffi.Int()
  external int alphaMode;

  @ffi.Bool()
  external bool enableDiagnostics;

  external UnnamedUnion1 unnamed;

  @ffi.Uint8()
  external int baseColorUV;

  @ffi.Bool()
  external bool hasClearCoatTexture;

  @ffi.Uint8()
  external int clearCoatUV;

  @ffi.Bool()
  external bool hasClearCoatRoughnessTexture;

  @ffi.Uint8()
  external int clearCoatRoughnessUV;

  @ffi.Bool()
  external bool hasClearCoatNormalTexture;

  @ffi.Uint8()
  external int clearCoatNormalUV;

  @ffi.Bool()
  external bool hasClearCoat;

  @ffi.Bool()
  external bool hasTransmission;

  @ffi.Bool()
  external bool hasTextureTransforms;

  @ffi.Uint8()
  external int emissiveUV;

  @ffi.Uint8()
  external int aoUV;

  @ffi.Uint8()
  external int normalUV;

  @ffi.Bool()
  external bool hasTransmissionTexture;

  @ffi.Uint8()
  external int transmissionUV;

  @ffi.Bool()
  external bool hasSheenColorTexture;

  @ffi.Uint8()
  external int sheenColorUV;

  @ffi.Bool()
  external bool hasSheenRoughnessTexture;

  @ffi.Uint8()
  external int sheenRoughnessUV;

  @ffi.Bool()
  external bool hasVolumeThicknessTexture;

  @ffi.Uint8()
  external int volumeThicknessUV;

  @ffi.Bool()
  external bool hasSheen;

  @ffi.Bool()
  external bool hasIOR;

  @ffi.Bool()
  external bool hasVolume;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 unnamed;

  external UnnamedStruct2 unnamed1;
}

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.Bool()
  external bool hasMetallicRoughnessTexture;

  @ffi.Uint8()
  external int metallicRoughnessUV;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.Bool()
  external bool hasSpecularGlossinessTexture;

  @ffi.Uint8()
  external int specularGlossinessUV;
}

final class double4 extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;

  @ffi.Double()
  external double z;

  @ffi.Double()
  external double w;
}

final class double4x4 extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col1;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col2;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col3;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col4;
}

final class Aabb2 extends ffi.Struct {
  @ffi.Float()
  external double minX;

  @ffi.Float()
  external double minY;

  @ffi.Float()
  external double maxX;

  @ffi.Float()
  external double maxY;
}

final class ResourceBuffer extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @ffi.Int32()
  external int size;

  @ffi.Int32()
  external int id;
}

final class ResourceLoaderWrapper extends ffi.Struct {
  external LoadFilamentResource loadResource;

  external FreeFilamentResource freeResource;

  external LoadFilamentResourceFromOwner loadFromOwner;

  external FreeFilamentResourceFromOwner freeFromOwner;

  external ffi.Pointer<ffi.Void> owner;

  external LoadFilamentResourceIntoOutPointer loadToOut;
}

typedef LoadFilamentResource
    = ffi.Pointer<ffi.NativeFunction<LoadFilamentResourceFunction>>;
typedef LoadFilamentResourceFunction = ResourceBuffer Function(
    ffi.Pointer<ffi.Char> uri);
typedef FreeFilamentResource
    = ffi.Pointer<ffi.NativeFunction<FreeFilamentResourceFunction>>;
typedef FreeFilamentResourceFunction = ffi.Void Function(ResourceBuffer);
typedef DartFreeFilamentResourceFunction = void Function(ResourceBuffer);
typedef LoadFilamentResourceFromOwner
    = ffi.Pointer<ffi.NativeFunction<LoadFilamentResourceFromOwnerFunction>>;
typedef LoadFilamentResourceFromOwnerFunction = ResourceBuffer Function(
    ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>);
typedef FreeFilamentResourceFromOwner
    = ffi.Pointer<ffi.NativeFunction<FreeFilamentResourceFromOwnerFunction>>;
typedef FreeFilamentResourceFromOwnerFunction = ffi.Void Function(
    ResourceBuffer, ffi.Pointer<ffi.Void>);
typedef DartFreeFilamentResourceFromOwnerFunction = void Function(
    ResourceBuffer, ffi.Pointer<ffi.Void>);
typedef LoadFilamentResourceIntoOutPointer = ffi
    .Pointer<ffi.NativeFunction<LoadFilamentResourceIntoOutPointerFunction>>;
typedef LoadFilamentResourceIntoOutPointerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Char> uri, ffi.Pointer<ResourceBuffer> out);
typedef DartLoadFilamentResourceIntoOutPointerFunction = void Function(
    ffi.Pointer<ffi.Char> uri, ffi.Pointer<ResourceBuffer> out);

/// This header replicates most of the methods in ThermionDartApi.h.
/// It represents the interface for:
/// - invoking those methods that must be called on the main Filament engine thread
/// - setting up a render loop
typedef EntityId = ffi.Int32;
typedef DartEntityId = int;

final class TViewport extends ffi.Struct {
  @ffi.Int32()
  external int left;

  @ffi.Int32()
  external int bottom;

  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;
}

enum ToneMapping {
  ACES(0),
  FILMIC(1),
  LINEAR(2);

  final int value;
  const ToneMapping(this.value);

  static ToneMapping fromValue(int value) => switch (value) {
        0 => ACES,
        1 => FILMIC,
        2 => LINEAR,
        _ => throw ArgumentError("Unknown value for ToneMapping: $value"),
      };
}

typedef FilamentRenderCallback
    = ffi.Pointer<ffi.NativeFunction<FilamentRenderCallbackFunction>>;
typedef FilamentRenderCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> owner);
typedef DartFilamentRenderCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> owner);

enum Projection {
  Perspective(0),
  Orthographic(1);

  final int value;
  const Projection(this.value);

  static Projection fromValue(int value) => switch (value) {
        0 => Perspective,
        1 => Orthographic,
        _ => throw ArgumentError("Unknown value for Projection: $value"),
      };
}

typedef GizmoPickCallback
    = ffi.Pointer<ffi.NativeFunction<GizmoPickCallbackFunction>>;
typedef GizmoPickCallbackFunction = ffi.Void Function(
    EntityId entityId, ffi.Uint32 x, ffi.Uint32 y, ffi.Pointer<TView> view);
typedef DartGizmoPickCallbackFunction = void Function(
    DartEntityId entityId, int x, int y, ffi.Pointer<TView> view);

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;
