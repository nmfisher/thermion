// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('package:thermion_dart/thermion_dart.dart')
library;

import 'dart:ffi' as ffi;

@ffi.Native<ffi.Uint64>()
external int TSWAP_CHAIN_CONFIG_TRANSPARENT;

@ffi.Native<ffi.Uint64>()
external int TSWAP_CHAIN_CONFIG_READABLE;

@ffi.Native<ffi.Uint64>()
external int TSWAP_CHAIN_CONFIG_APPLE_CVPIXELBUFFER;

@ffi.Native<ffi.Uint64>()
external int TSWAP_CHAIN_CONFIG_HAS_STENCIL_BUFFER;

@ffi.Native<ffi.Pointer<TMaterialInstance> Function(ffi.Pointer<TMaterial>)>(
    isLeaf: true)
external ffi.Pointer<TMaterialInstance> Material_createInstance(
  ffi.Pointer<TMaterial> tMaterial,
);

@ffi.Native<ffi.Pointer<TMaterial> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TMaterial> Material_createImageMaterial(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Pointer<TMaterial> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TMaterial> Material_createGridMaterial(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TMaterial>, ffi.Pointer<ffi.Char>)>(
    isLeaf: true)
external bool Material_hasParameter(
  ffi.Pointer<TMaterial> tMaterial,
  ffi.Pointer<ffi.Char> propertyName,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external bool MaterialInstance_isStencilWriteEnabled(
  ffi.Pointer<TMaterialInstance> materialInstance,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setStencilWrite(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setCullingMode", isLeaf: true)
external void _MaterialInstance_setCullingMode(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int culling,
);

void MaterialInstance_setCullingMode(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TCullingMode culling,
) =>
    _MaterialInstance_setCullingMode(
      materialInstance,
      culling.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setDepthWrite(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setDepthCulling(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  double value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat2(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  double x,
  double y,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double, ffi.Double, ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat3(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Double>, ffi.Uint32)>(isLeaf: true)
external void MaterialInstance_setParameterFloat3Array(
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  ffi.Pointer<ffi.Double> raw,
  int length,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double, ffi.Double, ffi.Double, ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat4(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  double x,
  double y,
  double w,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Double>)>(isLeaf: true)
external void MaterialInstance_setParameterMat4(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  ffi.Pointer<ffi.Double> matrix,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Int)>(isLeaf: true)
external void MaterialInstance_setParameterInt(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  int value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Bool)>(isLeaf: true)
external void MaterialInstance_setParameterBool(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  bool value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<TTexture>, ffi.Pointer<TTextureSampler>)>(isLeaf: true)
external void MaterialInstance_setParameterTexture(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  ffi.Pointer<TTexture> texture,
  ffi.Pointer<TTextureSampler> sampler,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setDepthFunc", isLeaf: true)
external void _MaterialInstance_setDepthFunc(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int depthFunc,
);

void MaterialInstance_setDepthFunc(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TSamplerCompareFunc depthFunc,
) =>
    _MaterialInstance_setDepthFunc(
      materialInstance,
      depthFunc.value,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setStencilOpStencilFail", isLeaf: true)
external void _MaterialInstance_setStencilOpStencilFail(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int op,
  int face,
);

void MaterialInstance_setStencilOpStencilFail(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TStencilOperation op,
  TStencilFace face,
) =>
    _MaterialInstance_setStencilOpStencilFail(
      materialInstance,
      op.value,
      face.value,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setStencilOpDepthFail", isLeaf: true)
external void _MaterialInstance_setStencilOpDepthFail(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int op,
  int face,
);

void MaterialInstance_setStencilOpDepthFail(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TStencilOperation op,
  TStencilFace face,
) =>
    _MaterialInstance_setStencilOpDepthFail(
      materialInstance,
      op.value,
      face.value,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setStencilOpDepthStencilPass", isLeaf: true)
external void _MaterialInstance_setStencilOpDepthStencilPass(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int op,
  int face,
);

void MaterialInstance_setStencilOpDepthStencilPass(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TStencilOperation op,
  TStencilFace face,
) =>
    _MaterialInstance_setStencilOpDepthStencilPass(
      materialInstance,
      op.value,
      face.value,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setStencilCompareFunction", isLeaf: true)
external void _MaterialInstance_setStencilCompareFunction(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int func,
  int face,
);

void MaterialInstance_setStencilCompareFunction(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TSamplerCompareFunc func,
  TStencilFace face,
) =>
    _MaterialInstance_setStencilCompareFunction(
      materialInstance,
      func.value,
      face.value,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TMaterialInstance>, ffi.Uint8, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setStencilReferenceValue", isLeaf: true)
external void _MaterialInstance_setStencilReferenceValue(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int value,
  int face,
);

void MaterialInstance_setStencilReferenceValue(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int value,
  TStencilFace face,
) =>
    _MaterialInstance_setStencilReferenceValue(
      materialInstance,
      value,
      face.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Uint8)>(
    isLeaf: true)
external void MaterialInstance_setStencilReadMask(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int mask,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Uint8)>(
    isLeaf: true)
external void MaterialInstance_setStencilWriteMask(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int mask,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setTransparencyMode", isLeaf: true)
external void _MaterialInstance_setTransparencyMode(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int transparencyMode,
);

void MaterialInstance_setTransparencyMode(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TTransparencyMode transparencyMode,
) =>
    _MaterialInstance_setTransparencyMode(
      materialInstance,
      transparencyMode.value,
    );

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Double,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void LightManager_setPosition(
  ffi.Pointer<TLightManager> tLightManager,
  int light,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Double,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void LightManager_setDirection(
  ffi.Pointer<TLightManager> tLightManager,
  int light,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TEngine>, ffi.Pointer<TLightManager>,
        ffi.UnsignedInt)>(symbol: "LightManager_createLight", isLeaf: true)
external int _LightManager_createLight(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TLightManager> tLightManager,
  int tLightTtype,
);

int LightManager_createLight(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TLightManager> tLightManager,
  TLightType tLightTtype,
) =>
    _LightManager_createLight(
      tEngine,
      tLightManager,
      tLightTtype.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TLightManager>, EntityId)>(
    isLeaf: true)
external void LightManager_destroyLight(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Float)>(
    isLeaf: true)
external void LightManager_setColor(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double colorTemperature,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TLightManager>, EntityId, ffi.Double)>(isLeaf: true)
external void LightManager_setIntensity(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double intensity,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TLightManager>, EntityId, ffi.Double)>(isLeaf: true)
external void LightManager_setFalloff(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double falloff,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Double,
        ffi.Double)>(isLeaf: true)
external void LightManager_setSpotLightCone(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double inner,
  double outer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Bool)>(
    isLeaf: true)
external void LightManager_setShadowCaster(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  bool enabled,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external int FilamentAsset_getEntityCount(
  ffi.Pointer<TFilamentAsset> filamentAsset,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TFilamentAsset>, ffi.Pointer<EntityId>)>(isLeaf: true)
external void FilamentAsset_getEntities(
  ffi.Pointer<TFilamentAsset> filamentAsset,
  ffi.Pointer<EntityId> out,
);

@ffi.Native<
    ffi.Pointer<TTexture> Function(
        ffi.Pointer<TEngine>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint8,
        ffi.Uint16,
        ffi.IntPtr,
        ffi.UnsignedInt,
        ffi.UnsignedInt)>(symbol: "Texture_build", isLeaf: true)
external ffi.Pointer<TTexture> _Texture_build(
  ffi.Pointer<TEngine> engine,
  int width,
  int height,
  int depth,
  int levels,
  int tUsage,
  int import1,
  int sampler,
  int format,
);

ffi.Pointer<TTexture> Texture_build(
  ffi.Pointer<TEngine> engine,
  int width,
  int height,
  int depth,
  int levels,
  int tUsage,
  int import1,
  TTextureSamplerType sampler,
  TTextureFormat format,
) =>
    _Texture_build(
      engine,
      width,
      height,
      depth,
      levels,
      tUsage,
      import1,
      sampler.value,
      format.value,
    );

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TTexture>,
        ffi.Pointer<TLinearImage>,
        ffi.UnsignedInt,
        ffi.UnsignedInt)>(isLeaf: true)
external bool Texture_loadImage(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  ffi.Pointer<TLinearImage> tImage,
  int bufferFormat,
  int pixelDataType,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TTexture>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32)>(isLeaf: true)
external bool Texture_setImage(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  int level,
  ffi.Pointer<ffi.Uint8> data,
  int size,
  int width,
  int height,
  int channels,
  int bufferFormat,
  int pixelDataType,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TTexture>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32)>(isLeaf: true)
external bool Texture_setImageWithDepth(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  int level,
  ffi.Pointer<ffi.Uint8> data,
  int size,
  int x_offset,
  int y_offset,
  int z_offset,
  int width,
  int height,
  int channels,
  int depth,
  int bufferFormat,
  int pixelDataType,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TTexture>, ffi.Uint32)>(
    isLeaf: true)
external int Texture_getWidth(
  ffi.Pointer<TTexture> tTexture,
  int level,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TTexture>, ffi.Uint32)>(
    isLeaf: true)
external int Texture_getHeight(
  ffi.Pointer<TTexture> tTexture,
  int level,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TTexture>, ffi.Uint32)>(
    isLeaf: true)
external int Texture_getDepth(
  ffi.Pointer<TTexture> tTexture,
  int level,
);

@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<TTexture>, ffi.Uint32)>(
    symbol: "Texture_getUsage", isLeaf: true)
external int _Texture_getUsage(
  ffi.Pointer<TTexture> tTexture,
  int level,
);

TTextureUsage Texture_getUsage(
  ffi.Pointer<TTexture> tTexture,
  int level,
) =>
    TTextureUsage.fromValue(_Texture_getUsage(
      tTexture,
      level,
    ));

@ffi.Native<
    ffi.Pointer<TLinearImage> Function(
        ffi.Uint32, ffi.Uint32, ffi.Uint32)>(isLeaf: true)
external ffi.Pointer<TLinearImage> Image_createEmpty(
  int width,
  int height,
  int channel,
);

@ffi.Native<
    ffi.Pointer<TLinearImage> Function(
        ffi.Pointer<ffi.Uint8>, ffi.Size, ffi.Pointer<ffi.Char>)>(isLeaf: true)
external ffi.Pointer<TLinearImage> Image_decode(
  ffi.Pointer<ffi.Uint8> data,
  int length,
  ffi.Pointer<ffi.Char> name,
);

@ffi.Native<ffi.Pointer<ffi.Float> Function(ffi.Pointer<TLinearImage>)>(
    isLeaf: true)
external ffi.Pointer<ffi.Float> Image_getBytes(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external void Image_destroy(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external int Image_getWidth(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external int Image_getHeight(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external int Image_getChannels(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Pointer<TTexture> Function(ffi.Pointer<TRenderTarget>)>(
    isLeaf: true)
external ffi.Pointer<TTexture> RenderTarget_getColorTexture(
  ffi.Pointer<TRenderTarget> tRenderTarget,
);

@ffi.Native<ffi.Pointer<TTexture> Function(ffi.Pointer<TRenderTarget>)>(
    isLeaf: true)
external ffi.Pointer<TTexture> RenderTarget_getDepthTexture(
  ffi.Pointer<TRenderTarget> tRenderTarget,
);

@ffi.Native<ffi.Pointer<TTextureSampler> Function()>(isLeaf: true)
external ffi.Pointer<TTextureSampler> TextureSampler_create();

@ffi.Native<
        ffi.Pointer<TTextureSampler> Function(ffi.UnsignedInt, ffi.UnsignedInt,
            ffi.UnsignedInt, ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "TextureSampler_createWithFiltering", isLeaf: true)
external ffi.Pointer<TTextureSampler> _TextureSampler_createWithFiltering(
  int minFilter,
  int magFilter,
  int wrapS,
  int wrapT,
  int wrapR,
);

ffi.Pointer<TTextureSampler> TextureSampler_createWithFiltering(
  TSamplerMinFilter minFilter,
  TSamplerMagFilter magFilter,
  TSamplerWrapMode wrapS,
  TSamplerWrapMode wrapT,
  TSamplerWrapMode wrapR,
) =>
    _TextureSampler_createWithFiltering(
      minFilter.value,
      magFilter.value,
      wrapS.value,
      wrapT.value,
      wrapR.value,
    );

@ffi.Native<
        ffi.Pointer<TTextureSampler> Function(
            ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "TextureSampler_createWithComparison", isLeaf: true)
external ffi.Pointer<TTextureSampler> _TextureSampler_createWithComparison(
  int compareMode,
  int compareFunc,
);

ffi.Pointer<TTextureSampler> TextureSampler_createWithComparison(
  TSamplerCompareMode compareMode,
  TSamplerCompareFunc compareFunc,
) =>
    _TextureSampler_createWithComparison(
      compareMode.value,
      compareFunc.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    symbol: "TextureSampler_setMinFilter", isLeaf: true)
external void _TextureSampler_setMinFilter(
  ffi.Pointer<TTextureSampler> sampler,
  int filter,
);

void TextureSampler_setMinFilter(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerMinFilter filter,
) =>
    _TextureSampler_setMinFilter(
      sampler,
      filter.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    symbol: "TextureSampler_setMagFilter", isLeaf: true)
external void _TextureSampler_setMagFilter(
  ffi.Pointer<TTextureSampler> sampler,
  int filter,
);

void TextureSampler_setMagFilter(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerMagFilter filter,
) =>
    _TextureSampler_setMagFilter(
      sampler,
      filter.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    symbol: "TextureSampler_setWrapModeS", isLeaf: true)
external void _TextureSampler_setWrapModeS(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
);

void TextureSampler_setWrapModeS(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
) =>
    _TextureSampler_setWrapModeS(
      sampler,
      mode.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    symbol: "TextureSampler_setWrapModeT", isLeaf: true)
external void _TextureSampler_setWrapModeT(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
);

void TextureSampler_setWrapModeT(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
) =>
    _TextureSampler_setWrapModeT(
      sampler,
      mode.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    symbol: "TextureSampler_setWrapModeR", isLeaf: true)
external void _TextureSampler_setWrapModeR(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
);

void TextureSampler_setWrapModeR(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
) =>
    _TextureSampler_setWrapModeR(
      sampler,
      mode.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.Double)>(
    isLeaf: true)
external void TextureSampler_setAnisotropy(
  ffi.Pointer<TTextureSampler> sampler,
  double anisotropy,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
        ffi.UnsignedInt)>(symbol: "TextureSampler_setCompareMode", isLeaf: true)
external void _TextureSampler_setCompareMode(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  int func,
);

void TextureSampler_setCompareMode(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerCompareMode mode,
  TSamplerCompareFunc func,
) =>
    _TextureSampler_setCompareMode(
      sampler,
      mode.value,
      func.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>)>(isLeaf: true)
external void TextureSampler_destroy(
  ffi.Pointer<TTextureSampler> sampler,
);

@ffi.Native<
    ffi.Pointer<TGltfAssetLoader> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TMaterialProvider>)>(isLeaf: true)
external ffi.Pointer<TGltfAssetLoader> GltfAssetLoader_create(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterialProvider> tMaterialProvider,
);

@ffi.Native<ffi.Pointer<TGltfResourceLoader> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TGltfResourceLoader> GltfResourceLoader_create(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<
    ffi.Pointer<TFilamentAsset> Function(
        ffi.Pointer<TGltfAssetLoader>,
        ffi.Pointer<TGltfResourceLoader>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Uint8)>(isLeaf: true)
external ffi.Pointer<TFilamentAsset> GltfAssetLoader_load(
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
  ffi.Pointer<TGltfResourceLoader> tResourceLoader,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  int numInstances,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(ffi.Pointer<TRenderableManager>,
        ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> GltfAssetLoader_getMaterialInstance(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  ffi.Pointer<TFilamentAsset> tAsset,
);

@ffi.Native<
    ffi.Pointer<TMaterialProvider> Function(
        ffi.Pointer<TGltfAssetLoader>)>(isLeaf: true)
external ffi.Pointer<TMaterialProvider> GltfAssetLoader_getMaterialProvider(
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
);

@ffi.Native<TViewport Function(ffi.Pointer<TView>)>(isLeaf: true)
external TViewport View_getViewport(
  ffi.Pointer<TView> view,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Uint32, ffi.Uint32)>(
    isLeaf: true)
external void View_setViewport(
  ffi.Pointer<TView> view,
  int width,
  int height,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TRenderTarget>)>(
    isLeaf: true)
external void View_setRenderTarget(
  ffi.Pointer<TView> view,
  ffi.Pointer<TRenderTarget> renderTarget,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setFrustumCullingEnabled(
  ffi.Pointer<TView> view,
  bool enabled,
);

@ffi.Native<ffi.Pointer<TRenderTarget> Function(ffi.Pointer<TView>)>(
    isLeaf: true)
external ffi.Pointer<TRenderTarget> View_getRenderTarget(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setPostProcessing(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setShadowsEnabled(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Int)>(isLeaf: true)
external void View_setShadowType(
  ffi.Pointer<TView> tView,
  int shadowType,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Float, ffi.Float)>(
    isLeaf: true)
external void View_setSoftShadowOptions(
  ffi.Pointer<TView> tView,
  double penumbraScale,
  double penumbraRatioScale,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool, ffi.Float)>(
    isLeaf: true)
external void View_setBloom(
  ffi.Pointer<TView> tView,
  bool enabled,
  double strength,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.UnsignedInt)>(
    symbol: "View_setRenderQuality", isLeaf: true)
external void _View_setRenderQuality(
  ffi.Pointer<TView> tView,
  int qualityLevel,
);

void View_setRenderQuality(
  ffi.Pointer<TView> tView,
  TQualityLevel qualityLevel,
) =>
    _View_setRenderQuality(
      tView,
      qualityLevel.value,
    );

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TEngine>,
        ffi.UnsignedInt)>(symbol: "View_setToneMapping", isLeaf: true)
external void _View_setToneMapping(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TEngine> tEngine,
  int toneMapping,
);

void View_setToneMapping(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TEngine> tEngine,
  TToneMapping toneMapping,
) =>
    _View_setToneMapping(
      tView,
      tEngine,
      toneMapping.value,
    );

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TView>, ffi.Bool, ffi.Bool, ffi.Bool)>(isLeaf: true)
external void View_setAntiAliasing(
  ffi.Pointer<TView> tView,
  bool msaa,
  bool fxaa,
  bool taa,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Int, ffi.Bool)>(
    isLeaf: true)
external void View_setLayerEnabled(
  ffi.Pointer<TView> tView,
  int layer,
  bool visible,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TCamera>)>(
    isLeaf: true)
external void View_setCamera(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TCamera> tCamera,
);

@ffi.Native<ffi.Pointer<TScene> Function(ffi.Pointer<TView>)>(isLeaf: true)
external ffi.Pointer<TScene> View_getScene(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TView>)>(isLeaf: true)
external ffi.Pointer<TCamera> View_getCamera(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setStencilBufferEnabled(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TView>)>(isLeaf: true)
external bool View_isStencilBufferEnabled(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setDitheringEnabled(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TView>)>(isLeaf: true)
external bool View_isDitheringEnabled(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TScene>)>(
    isLeaf: true)
external void View_setScene(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TView>, ffi.Uint32, ffi.Uint32, ffi.Uint32,
        PickCallback)>(isLeaf: true)
external void View_pick(
  ffi.Pointer<TView> tView,
  int requestId,
  int x,
  int y,
  PickCallback callback,
);

@ffi.Native<ffi.Pointer<TNameComponentManager> Function()>(isLeaf: true)
external ffi.Pointer<TNameComponentManager> NameComponentManager_create();

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TNameComponentManager>, EntityId)>(isLeaf: true)
external ffi.Pointer<ffi.Char> NameComponentManager_getName(
  ffi.Pointer<TNameComponentManager> tNameComponentManager,
  int entity,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TIndirectLight>, ffi.Pointer<ffi.Double>)>(isLeaf: true)
external void IndirectLight_setRotation(
  ffi.Pointer<TIndirectLight> tIndirectLight,
  ffi.Pointer<ffi.Double> rotation,
);

@ffi.Native<
    ffi.Pointer<TGizmo> Function(ffi.Pointer<TEngine>, ffi.Pointer<TView>,
        ffi.UnsignedInt)>(symbol: "Gizmo_create", isLeaf: true)
external ffi.Pointer<TGizmo> _Gizmo_create(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TView> tView,
  int tGizmoType,
);

ffi.Pointer<TGizmo> Gizmo_create(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TView> tView,
  TGizmoType tGizmoType,
) =>
    _Gizmo_create(
      tEngine,
      tView,
      tGizmoType.value,
    );

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TGizmo>, ffi.Uint32, ffi.Uint32,
        GizmoPickCallback)>(isLeaf: true)
external void Gizmo_pick(
  ffi.Pointer<TGizmo> tGizmo,
  int x,
  int y,
  GizmoPickCallback callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TGizmo>, ffi.UnsignedInt)>(
    symbol: "Gizmo_highlight", isLeaf: true)
external void _Gizmo_highlight(
  ffi.Pointer<TGizmo> tGizmo,
  int axis,
);

void Gizmo_highlight(
  ffi.Pointer<TGizmo> tGizmo,
  TGizmoAxis axis,
) =>
    _Gizmo_highlight(
      tGizmo,
      axis.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TGizmo>)>(isLeaf: true)
external void Gizmo_unhighlight(
  ffi.Pointer<TGizmo> tGizmo,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(ffi.Pointer<TMaterialProvider>,
        ffi.Pointer<TMaterialKey>)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> MaterialProvider_createMaterialInstance(
  ffi.Pointer<TMaterialProvider> provider,
  ffi.Pointer<TMaterialKey> key,
);

@ffi.Native<
    ffi.Pointer<TRenderTarget> Function(ffi.Pointer<TEngine>, ffi.Uint32,
        ffi.Uint32, ffi.Pointer<TTexture>, ffi.Pointer<TTexture>)>(isLeaf: true)
external ffi.Pointer<TRenderTarget> RenderTarget_create(
  ffi.Pointer<TEngine> tEngine,
  int width,
  int height,
  ffi.Pointer<TTexture> color,
  ffi.Pointer<TTexture> depth,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TRenderTarget>)>(isLeaf: true)
external void RenderTarget_destroy(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TRenderTarget> tRenderTarget,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TScene>, EntityId)>(isLeaf: true)
external void Scene_addEntity(
  ffi.Pointer<TScene> tScene,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TScene>, EntityId)>(isLeaf: true)
external void Scene_removeEntity(
  ffi.Pointer<TScene> tScene,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TScene>, ffi.Pointer<TSkybox>)>(
    isLeaf: true)
external void Scene_setSkybox(
  ffi.Pointer<TScene> tScene,
  ffi.Pointer<TSkybox> skybox,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TScene>, ffi.Pointer<TIndirectLight>)>(isLeaf: true)
external void Scene_setIndirectLight(
  ffi.Pointer<TScene> tScene,
  ffi.Pointer<TIndirectLight> tIndirectLight,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TScene>, ffi.Pointer<TFilamentAsset>)>(isLeaf: true)
external void Scene_addFilamentAsset(
  ffi.Pointer<TScene> tScene,
  ffi.Pointer<TFilamentAsset> asset,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void Camera_setExposure(
  ffi.Pointer<TCamera> camera,
  double aperture,
  double shutterSpeed,
  double sensitivity,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getModelMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getViewMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getProjectionMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getCullingProjectionMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, ffi.Pointer<ffi.Double>)>(
    isLeaf: true)
external void Camera_getFrustum(
  ffi.Pointer<TCamera> camera,
  ffi.Pointer<ffi.Double> out,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Pointer<ffi.Double>, ffi.Double,
        ffi.Double)>(isLeaf: true)
external void Camera_setProjectionMatrix(
  ffi.Pointer<TCamera> camera,
  ffi.Pointer<ffi.Double> matrix,
  double near,
  double far,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Double, ffi.Double, ffi.Double,
        ffi.Double, ffi.Bool)>(isLeaf: true)
external void Camera_setProjectionFromFov(
  ffi.Pointer<TCamera> camera,
  double fovInDegrees,
  double aspect,
  double near,
  double far,
  bool horizontal,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getFocalLength(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, double3, double3, double3)>(
    isLeaf: true)
external void Camera_lookAt(
  ffi.Pointer<TCamera> camera,
  double3 eye,
  double3 focus,
  double3 up,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getNear(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getCullingFar(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Float Function(ffi.Pointer<TCamera>, ffi.Bool)>(isLeaf: true)
external double Camera_getFov(
  ffi.Pointer<TCamera> camera,
  bool horizontal,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getFocusDistance(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, ffi.Float)>(isLeaf: true)
external void Camera_setFocusDistance(
  ffi.Pointer<TCamera> camera,
  double focusDistance,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, double4x4, ffi.Double, ffi.Double)>(isLeaf: true)
external void Camera_setCustomProjectionWithCulling(
  ffi.Pointer<TCamera> camera,
  double4x4 projectionMatrix,
  double near,
  double far,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, ffi.Pointer<ffi.Double>)>(
    isLeaf: true)
external void Camera_setModelMatrix(
  ffi.Pointer<TCamera> camera,
  ffi.Pointer<ffi.Double> tModelMatrix,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Double, ffi.Double, ffi.Double,
        ffi.Double)>(isLeaf: true)
external void Camera_setLensProjection(
  ffi.Pointer<TCamera> camera,
  double near,
  double far,
  double aspect,
  double focalLength,
);

@ffi.Native<EntityId Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external int Camera_getEntity(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>,
        ffi.UnsignedInt,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double)>(symbol: "Camera_setProjection", isLeaf: true)
external void _Camera_setProjection(
  ffi.Pointer<TCamera> tCamera,
  int projection,
  double left,
  double right,
  double bottom,
  double top,
  double near,
  double far,
);

void Camera_setProjection(
  ffi.Pointer<TCamera> tCamera,
  TProjection projection,
  double left,
  double right,
  double bottom,
  double top,
  double near,
  double far,
) =>
    _Camera_setProjection(
      tCamera,
      projection.value,
      left,
      right,
      bottom,
      top,
      near,
      far,
    );

@ffi.Native<double4x4 Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external double4x4 TransformManager_getLocalTransform(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external double4x4 TransformManager_getWorldTransform(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TTransformManager>, EntityId, double4x4)>(isLeaf: true)
external void TransformManager_setTransform(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
  double4x4 transform,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TTransformManager>, EntityId, Aabb3)>(
    isLeaf: true)
external void TransformManager_transformToUnitCube(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
  Aabb3 boundingBox,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTransformManager>, EntityId, EntityId,
        ffi.Bool)>(isLeaf: true)
external void TransformManager_setParent(
  ffi.Pointer<TTransformManager> tTransformManager,
  int child,
  int parent,
  bool preserveScaling,
);

@ffi.Native<EntityId Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external int TransformManager_getParent(
  ffi.Pointer<TTransformManager> tTransformManager,
  int child,
);

@ffi.Native<EntityId Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external int TransformManager_getAncestor(
  ffi.Pointer<TTransformManager> tTransformManager,
  int childEntityId,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderer>, ffi.Double, ffi.Double,
        ffi.Double, ffi.Double, ffi.Uint8, ffi.Bool, ffi.Bool)>(isLeaf: true)
external void Renderer_setClearOptions(
  ffi.Pointer<TRenderer> tRenderer,
  double clearR,
  double clearG,
  double clearB,
  double clearA,
  int clearStencil,
  bool clear,
  bool discard,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TRenderer>, ffi.Pointer<TSwapChain>,
        ffi.Uint64)>(isLeaf: true)
external bool Renderer_beginFrame(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TSwapChain> tSwapChain,
  int frameTimeInNanos,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderer>)>(isLeaf: true)
external void Renderer_endFrame(
  ffi.Pointer<TRenderer> tRenderer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderer>, ffi.Pointer<TView>)>(
    isLeaf: true)
external void Renderer_render(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderer>, ffi.Pointer<TView>)>(
    isLeaf: true)
external void Renderer_renderStandaloneView(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TRenderTarget>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<ffi.Uint8>)>(isLeaf: true)
external void Renderer_readPixels(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TRenderTarget> tRenderTarget,
  int tPixelBufferFormat,
  int tPixelDataType,
  ffi.Pointer<ffi.Uint8> out,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderer>, ffi.Float, ffi.Float, ffi.Uint8,
        ffi.Uint8)>(isLeaf: true)
external void Renderer_setFrameInterval(
  ffi.Pointer<TRenderer> tRenderer,
  double headRoomRatio,
  double scaleRate,
  int history,
  int interval,
);

@ffi.Native<ffi.Pointer<TRenderTicker> Function(ffi.Pointer<TRenderer>)>(
    isLeaf: true)
external ffi.Pointer<TRenderTicker> RenderTicker_create(
  ffi.Pointer<TRenderer> tRenderer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderTicker>)>(isLeaf: true)
external void RenderTicker_destroy(
  ffi.Pointer<TRenderTicker> tRenderTicker,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderTicker>,
        ffi.Pointer<TAnimationManager>)>(isLeaf: true)
external void RenderTicker_addAnimationManager(
  ffi.Pointer<TRenderTicker> tRenderTicker,
  ffi.Pointer<TAnimationManager> tAnimationManager,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderTicker>,
        ffi.Pointer<TAnimationManager>)>(isLeaf: true)
external void RenderTicker_removeAnimationManager(
  ffi.Pointer<TRenderTicker> tRenderTicker,
  ffi.Pointer<TAnimationManager> tAnimationManager,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TRenderTicker>, ffi.Uint64)>(
    isLeaf: true)
external void RenderTicker_render(
  ffi.Pointer<TRenderTicker> tRenderTicker,
  int frameTimeInNanos,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderTicker>, ffi.Pointer<TSwapChain>,
        ffi.Pointer<ffi.Pointer<TView>>, ffi.Uint8)>(isLeaf: true)
external void RenderTicker_setRenderable(
  ffi.Pointer<TRenderTicker> tRenderTicker,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<ffi.Pointer<TView>> views,
  int numViews,
);

@ffi.Native<ffi.Void Function()>(isLeaf: true)
external void RenderLoop_create();

@ffi.Native<ffi.Void Function()>(isLeaf: true)
external void RenderLoop_destroy();

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void RenderLoop_requestAnimationFrame(
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderTicker>, ffi.Uint64,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void RenderTicker_renderRenderThread(
  ffi.Pointer<TRenderTicker> tRenderTicker,
  int frameTimeInNanos,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void RenderLoop_addTask(
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> task,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TScene>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TAnimationManager>)>>)>(isLeaf: true)
external void AnimationManager_createRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TScene> tScene,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TAnimationManager>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Int,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Uint8,
            ffi.Bool,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TEngine>)>>)>(
    isLeaf: true)
external void Engine_createRenderThread(
  int backend,
  ffi.Pointer<ffi.Void> platform,
  ffi.Pointer<ffi.Void> sharedContext,
  int stereoscopicEyeCount,
  bool disableHandleUseAfterFreeCheck,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TEngine>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TRenderer>)>>)>(
    isLeaf: true)
external void Engine_createRendererRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TRenderer>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<ffi.Void>,
            ffi.Uint64,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>)>(
    isLeaf: true)
external void Engine_createSwapChainRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Void> window,
  int flags,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint64,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>)>(
    isLeaf: true)
external void Engine_createHeadlessSwapChainRenderThread(
  ffi.Pointer<TEngine> tEngine,
  int width,
  int height,
  int flags,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TCamera>)>>)>(
    isLeaf: true)
external void Engine_createCameraRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TCamera>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TView>)>>)>(
    isLeaf: true)
external void Engine_createViewRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TView>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>)>(
    isLeaf: true)
external void Engine_buildMaterialRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> materialData,
  int length,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TSwapChain>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_destroySwapChainRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TSwapChain> tSwapChain,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TMaterial>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_destroyMaterialRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterial> tMaterial,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TMaterialInstance>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_destroyMaterialInstanceRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TSkybox>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_destroySkyboxRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TSkybox> tSkybox,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TIndirectLight>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_destroyIndirectLightRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TIndirectLight> tIndirectLight,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint8,
            ffi.Uint16,
            ffi.IntPtr,
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>)>(
    symbol: "Texture_buildRenderThread", isLeaf: true)
external void _Texture_buildRenderThread(
  ffi.Pointer<TEngine> engine,
  int width,
  int height,
  int depth,
  int levels,
  int tUsage,
  int import1,
  int sampler,
  int format,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>
      onComplete,
);

void Texture_buildRenderThread(
  ffi.Pointer<TEngine> engine,
  int width,
  int height,
  int depth,
  int levels,
  int tUsage,
  int import1,
  TTextureSamplerType sampler,
  TTextureFormat format,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>
      onComplete,
) =>
    _Texture_buildRenderThread(
      engine,
      width,
      height,
      depth,
      levels,
      tUsage,
      import1,
      sampler.value,
      format.value,
      onComplete,
    );

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TTexture>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_destroyTextureRenderThread(
  ffi.Pointer<TEngine> engine,
  ffi.Pointer<TTexture> tTexture,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TFence>)>>)>(
    isLeaf: true)
external void Engine_createFenceRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TFence>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TFence>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_destroyFenceRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TFence> tFence,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_flushAndWaitRenderThead(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Pointer<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSkybox>)>>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_buildSkyboxRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> skyboxData,
  int length,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSkybox>)>>
      onComplete,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onTextureUploadComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Float,
        ffi.Pointer<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TIndirectLight>)>>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_buildIndirectLightRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> iblData,
  int length,
  double intensity,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TIndirectLight>)>>
      onComplete,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onTextureUploadComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderer>,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Uint8,
        ffi.Bool,
        ffi.Bool,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Renderer_setClearOptionsRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  double clearR,
  double clearG,
  double clearB,
  double clearA,
  int clearStencil,
  bool clear,
  bool discard,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TRenderer>,
            ffi.Pointer<TSwapChain>,
            ffi.Uint64,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void Renderer_beginFrameRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TSwapChain> tSwapChain,
  int frameTimeInNanos,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderer>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Renderer_endFrameRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderer>, ffi.Pointer<TView>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Renderer_renderRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderer>, ffi.Pointer<TView>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Renderer_renderStandaloneViewRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TRenderTarget>,
        ffi.UnsignedInt,
        ffi.UnsignedInt,
        ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Renderer_readPixelsRenderThread(
  ffi.Pointer<TRenderer> tRenderer,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TRenderTarget> tRenderTarget,
  int tPixelBufferFormat,
  int tPixelDataType,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TMaterial>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TMaterialInstance>)>>)>(isLeaf: true)
external void Material_createInstanceRenderThread(
  ffi.Pointer<TMaterial> tMaterial,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterialInstance>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>)>(
    isLeaf: true)
external void Material_createImageMaterialRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TView>,
            ffi.Pointer<TEngine>,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(
    symbol: "View_setToneMappingRenderThread", isLeaf: true)
external void _View_setToneMappingRenderThread(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TEngine> tEngine,
  int toneMapping,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

void View_setToneMappingRenderThread(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TEngine> tEngine,
  TToneMapping toneMapping,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
) =>
    _View_setToneMappingRenderThread(
      tView,
      tEngine,
      toneMapping.value,
      callback,
    );

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TView>, ffi.Bool, ffi.Double,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void View_setBloomRenderThread(
  ffi.Pointer<TView> tView,
  bool enabled,
  double strength,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TCamera>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void View_setCameraRenderThread(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TCamera> tCamera,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<FilamentRenderCallback Function(FilamentRenderCallback)>(
    isLeaf: true)
external FilamentRenderCallback make_render_callback_fn_pointer(
  FilamentRenderCallback arg0,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void SceneAsset_destroyRenderThread(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TGltfAssetLoader>,
            ffi.Pointer<TGltfResourceLoader>,
            ffi.Pointer<TEngine>,
            ffi.Pointer<TNameComponentManager>,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneAsset_loadGlbRenderThread(
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
  ffi.Pointer<TGltfResourceLoader> tResourceLoader,
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TNameComponentManager> tNameComponentManager,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  int numInstances,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneAsset>,
            ffi.Pointer<ffi.Pointer<TMaterialInstance>>,
            ffi.Int,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneAsset_createInstanceRenderThread(
  ffi.Pointer<TSceneAsset> asset,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> tMaterialInstances,
  int materialInstanceCount,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<ffi.Float>,
            ffi.Uint32,
            ffi.Pointer<ffi.Float>,
            ffi.Uint32,
            ffi.Pointer<ffi.Float>,
            ffi.Uint32,
            ffi.Pointer<ffi.Uint16>,
            ffi.Uint32,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.Pointer<TMaterialInstance>>,
            ffi.Int,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneAsset_createGeometryRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Float> vertices,
  int numVertices,
  ffi.Pointer<ffi.Float> normals,
  int numNormals,
  ffi.Pointer<ffi.Float> uvs,
  int numUvs,
  ffi.Pointer<ffi.Uint16> indices,
  int numIndices,
  int tPrimitiveType,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TMaterialProvider>,
        ffi.Pointer<TMaterialKey>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TMaterialInstance>)>>)>(isLeaf: true)
external void MaterialProvider_createMaterialInstanceRenderThread(
  ffi.Pointer<TMaterialProvider> tMaterialProvider,
  ffi.Pointer<TMaterialKey> tKey,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterialInstance>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<TMaterialInstance>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void SceneManager_destroyMaterialInstanceRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TAnimationManager>,
            ffi.Pointer<TSceneAsset>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void AnimationManager_updateBoneMatricesRenderThread(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TAnimationManager>,
            EntityId,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void AnimationManager_setMorphTargetWeightsRenderThread(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  ffi.Pointer<ffi.Float> morphData,
  int numWeights,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TLinearImage>)>>)>(isLeaf: true)
external void Image_createEmptyRenderThread(
  int width,
  int height,
  int channel,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TLinearImage>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TLinearImage>)>>)>(isLeaf: true)
external void Image_decodeRenderThread(
  ffi.Pointer<ffi.Uint8> data,
  int length,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TLinearImage>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TLinearImage>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>)>(
    isLeaf: true)
external void Image_getBytesRenderThread(
  ffi.Pointer<TLinearImage> tLinearImage,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLinearImage>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Image_destroyRenderThread(
  ffi.Pointer<TLinearImage> tLinearImage,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TLinearImage>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>)>(
    isLeaf: true)
external void Image_getWidthRenderThread(
  ffi.Pointer<TLinearImage> tLinearImage,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TLinearImage>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>)>(
    isLeaf: true)
external void Image_getHeightRenderThread(
  ffi.Pointer<TLinearImage> tLinearImage,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TLinearImage>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>)>(
    isLeaf: true)
external void Image_getChannelsRenderThread(
  ffi.Pointer<TLinearImage> tLinearImage,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<TTexture>,
            ffi.Pointer<TLinearImage>,
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void Texture_loadImageRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  ffi.Pointer<TLinearImage> tImage,
  int bufferFormat,
  int pixelDataType,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<TTexture>,
            ffi.Uint32,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void Texture_setImageRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  int level,
  ffi.Pointer<ffi.Uint8> data,
  int size,
  int width,
  int height,
  int channels,
  int bufferFormat,
  int pixelDataType,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<TTexture>,
            ffi.Uint32,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void Texture_setImageWithDepthRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  int level,
  ffi.Pointer<ffi.Uint8> data,
  int size,
  int x_offset,
  int y_offset,
  int z_offset,
  int width,
  int height,
  int channels,
  int depth,
  int bufferFormat,
  int pixelDataType,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TRenderTarget>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>)>(
    isLeaf: true)
external void RenderTarget_getColorTextureRenderThread(
  ffi.Pointer<TRenderTarget> tRenderTarget,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<TTexture>,
        ffi.Pointer<TTexture>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TRenderTarget>)>>)>(isLeaf: true)
external void RenderTarget_createRenderThread(
  ffi.Pointer<TEngine> tEngine,
  int width,
  int height,
  ffi.Pointer<TTexture> color,
  ffi.Pointer<TTexture> depth,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TRenderTarget>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TTextureSampler>)>>)>(isLeaf: true)
external void TextureSampler_createRenderThread(
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTextureSampler>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<TTextureSampler>)>>)>(
    symbol: "TextureSampler_createWithFilteringRenderThread", isLeaf: true)
external void _TextureSampler_createWithFilteringRenderThread(
  int minFilter,
  int magFilter,
  int wrapS,
  int wrapT,
  int wrapR,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTextureSampler>)>>
      onComplete,
);

void TextureSampler_createWithFilteringRenderThread(
  TSamplerMinFilter minFilter,
  TSamplerMagFilter magFilter,
  TSamplerWrapMode wrapS,
  TSamplerWrapMode wrapT,
  TSamplerWrapMode wrapR,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTextureSampler>)>>
      onComplete,
) =>
    _TextureSampler_createWithFilteringRenderThread(
      minFilter.value,
      magFilter.value,
      wrapS.value,
      wrapT.value,
      wrapR.value,
      onComplete,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<TTextureSampler>)>>)>(
    symbol: "TextureSampler_createWithComparisonRenderThread", isLeaf: true)
external void _TextureSampler_createWithComparisonRenderThread(
  int compareMode,
  int compareFunc,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTextureSampler>)>>
      onComplete,
);

void TextureSampler_createWithComparisonRenderThread(
  TSamplerCompareMode compareMode,
  TSamplerCompareFunc compareFunc,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTextureSampler>)>>
      onComplete,
) =>
    _TextureSampler_createWithComparisonRenderThread(
      compareMode.value,
      compareFunc.value,
      onComplete,
    );

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(
    symbol: "TextureSampler_setMinFilterRenderThread", isLeaf: true)
external void _TextureSampler_setMinFilterRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int filter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

void TextureSampler_setMinFilterRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerMinFilter filter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
) =>
    _TextureSampler_setMinFilterRenderThread(
      sampler,
      filter.value,
      onComplete,
    );

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(
    symbol: "TextureSampler_setMagFilterRenderThread", isLeaf: true)
external void _TextureSampler_setMagFilterRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int filter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

void TextureSampler_setMagFilterRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerMagFilter filter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
) =>
    _TextureSampler_setMagFilterRenderThread(
      sampler,
      filter.value,
      onComplete,
    );

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(
    symbol: "TextureSampler_setWrapModeSRenderThread", isLeaf: true)
external void _TextureSampler_setWrapModeSRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

void TextureSampler_setWrapModeSRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
) =>
    _TextureSampler_setWrapModeSRenderThread(
      sampler,
      mode.value,
      onComplete,
    );

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(
    symbol: "TextureSampler_setWrapModeTRenderThread", isLeaf: true)
external void _TextureSampler_setWrapModeTRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

void TextureSampler_setWrapModeTRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
) =>
    _TextureSampler_setWrapModeTRenderThread(
      sampler,
      mode.value,
      onComplete,
    );

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(
    symbol: "TextureSampler_setWrapModeRRenderThread", isLeaf: true)
external void _TextureSampler_setWrapModeRRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

void TextureSampler_setWrapModeRRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
) =>
    _TextureSampler_setWrapModeRRenderThread(
      sampler,
      mode.value,
      onComplete,
    );

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.Double,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void TextureSampler_setAnisotropyRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  double anisotropy,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TTextureSampler>,
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(
    symbol: "TextureSampler_setCompareModeRenderThread", isLeaf: true)
external void _TextureSampler_setCompareModeRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  int func,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

void TextureSampler_setCompareModeRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerCompareMode mode,
  TSamplerCompareFunc func,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
) =>
    _TextureSampler_setCompareModeRenderThread(
      sampler,
      mode.value,
      func.value,
      onComplete,
    );

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void TextureSampler_destroyRenderThread(
  ffi.Pointer<TTextureSampler> sampler,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TAnimationManager>,
            EntityId,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void AnimationManager_setBoneTransformRenderThread(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int asset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> transform,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, EntityId,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void AnimationManager_resetToRestPoseRenderThread(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TMaterialProvider>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TGltfAssetLoader>)>>)>(isLeaf: true)
external void GltfAssetLoader_createRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterialProvider> tMaterialProvider,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TGltfAssetLoader>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TGltfResourceLoader>)>>)>(isLeaf: true)
external void GltfResourceLoader_createRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<TGltfResourceLoader>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TGltfAssetLoader>,
        ffi.Pointer<TGltfResourceLoader>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Uint8,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TFilamentAsset>)>>)>(isLeaf: true)
external void GltfAssetLoader_loadRenderThread(
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
  ffi.Pointer<TGltfResourceLoader> tResourceLoader,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  int numInstances,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TFilamentAsset>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TScene>, ffi.Pointer<TFilamentAsset>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Scene_addFilamentAssetRenderThread(
  ffi.Pointer<TScene> tScene,
  ffi.Pointer<TFilamentAsset> tAsset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderableManager>, EntityId, ffi.Int,
        ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external void RenderableManager_setMaterialInstanceAt(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int primitiveIndex,
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> RenderableManager_getMaterialInstanceAt(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int primitiveIndex,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_isRenderable(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_hasComponent(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>)>(isLeaf: true)
external bool RenderableManager_empty(
  ffi.Pointer<TRenderableManager> tRenderableManager,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId,
        ffi.UnsignedInt)>(isLeaf: true)
external bool RenderableManager_getLightChannel(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int channel,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_isShadowCaster(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Bool)>(isLeaf: true)
external void RenderableManager_setCastShadows(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  bool castShadows,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Bool)>(isLeaf: true)
external void RenderableManager_setReceiveShadows(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  bool receiveShadows,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_isShadowReceiver(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_getFogEnabled(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<Aabb3 Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external Aabb3 RenderableManager_getAabb(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Uint8)>(isLeaf: true)
external void RenderableManager_setVisibilityLayer(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int layer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Uint8)>(isLeaf: true)
external void RenderableManager_setPriority(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int priority,
);

@ffi.Native<
    ffi.Pointer<TEngine> Function(
        ffi.UnsignedInt,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Void>,
        ffi.Uint8,
        ffi.Bool)>(symbol: "Engine_create", isLeaf: true)
external ffi.Pointer<TEngine> _Engine_create(
  int backend,
  ffi.Pointer<ffi.Void> platform,
  ffi.Pointer<ffi.Void> sharedContext,
  int stereoscopicEyeCount,
  bool disableHandleUseAfterFreeCheck,
);

ffi.Pointer<TEngine> Engine_create(
  TBackend backend,
  ffi.Pointer<ffi.Void> platform,
  ffi.Pointer<ffi.Void> sharedContext,
  int stereoscopicEyeCount,
  bool disableHandleUseAfterFreeCheck,
) =>
    _Engine_create(
      backend.value,
      platform,
      sharedContext,
      stereoscopicEyeCount,
      disableHandleUseAfterFreeCheck,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external void Engine_destroy(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Pointer<TRenderer> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TRenderer> Engine_createRenderer(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<
    ffi.Pointer<TSwapChain> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<ffi.Void>, ffi.Uint64)>(isLeaf: true)
external ffi.Pointer<TSwapChain> Engine_createSwapChain(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Void> window,
  int flags,
);

@ffi.Native<
    ffi.Pointer<TSwapChain> Function(
        ffi.Pointer<TEngine>, ffi.Uint32, ffi.Uint32, ffi.Uint64)>(isLeaf: true)
external ffi.Pointer<TSwapChain> Engine_createHeadlessSwapChain(
  ffi.Pointer<TEngine> tEngine,
  int width,
  int height,
  int flags,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TSwapChain>)>(
    isLeaf: true)
external void Engine_destroySwapChain(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TSwapChain> tSwapChain,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TCamera> Engine_createCamera(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Pointer<TView> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TView> Engine_createView(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TEngine>, EntityId)>(
    isLeaf: true)
external ffi.Pointer<TCamera> Engine_getCameraComponent(
  ffi.Pointer<TEngine> tEngine,
  int entityId,
);

@ffi.Native<ffi.Pointer<TTransformManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TTransformManager> Engine_getTransformManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TRenderableManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TRenderableManager> Engine_getRenderableManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TLightManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TLightManager> Engine_getLightManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TEntityManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TEntityManager> Engine_getEntityManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TTexture>)>(
    isLeaf: true)
external void Engine_destroyTexture(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
);

@ffi.Native<ffi.Pointer<TFence> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TFence> Engine_createFence(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TFence>)>(
    isLeaf: true)
external void Engine_destroyFence(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TFence> tFence,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external void Engine_flushAndWait(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<
    ffi.Pointer<TMaterial> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<ffi.Uint8>, ffi.Size)>(isLeaf: true)
external ffi.Pointer<TMaterial> Engine_buildMaterial(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> materialData,
  int length,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TMaterial>)>(
    isLeaf: true)
external void Engine_destroyMaterial(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterial> tMaterial,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external void Engine_destroyMaterialInstance(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
);

@ffi.Native<ffi.Pointer<TScene> Function(ffi.Pointer<TEngine>)>(isLeaf: true)
external ffi.Pointer<TScene> Engine_createScene(
  ffi.Pointer<TEngine> tEngine,
);

@ffi.Native<
    ffi.Pointer<TSkybox> Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external ffi.Pointer<TSkybox> Engine_buildSkybox(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> ktxData,
  int length,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onTextureUploadComplete,
);

@ffi.Native<
    ffi.Pointer<TIndirectLight> Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Float,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external ffi.Pointer<TIndirectLight> Engine_buildIndirectLight(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> ktxData,
  int length,
  double intensity,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onTextureUploadComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TSkybox>)>(
    isLeaf: true)
external void Engine_destroySkybox(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TSkybox> tSkybox,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TIndirectLight>)>(isLeaf: true)
external void Engine_destroyIndirectLight(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TIndirectLight> tIndirectLight,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<ffi.Float>,
        ffi.Uint32,
        ffi.Pointer<ffi.Float>,
        ffi.Uint32,
        ffi.Pointer<ffi.Float>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint16>,
        ffi.Uint32,
        ffi.UnsignedInt,
        ffi.Pointer<ffi.Pointer<TMaterialInstance>>,
        ffi.Int)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_createGeometry(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Float> vertices,
  int numVertices,
  ffi.Pointer<ffi.Float> normals,
  int numNormals,
  ffi.Pointer<ffi.Float> uvs,
  int numUvs,
  ffi.Pointer<ffi.Uint16> indices,
  int numIndices,
  int tPrimitiveType,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TGltfAssetLoader>,
        ffi.Pointer<TGltfResourceLoader>,
        ffi.Pointer<TEngine>,
        ffi.Pointer<TNameComponentManager>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Size)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_loadGlb(
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
  ffi.Pointer<TGltfResourceLoader> tResourceLoader,
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TNameComponentManager> tNameComponentManager,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  int numInstances,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TGltfAssetLoader>,
        ffi.Pointer<TGltfResourceLoader>,
        ffi.Pointer<TEngine>,
        ffi.Pointer<TNameComponentManager>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Size)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_loadGltf(
  ffi.Pointer<TGltfAssetLoader> tAssetLoader,
  ffi.Pointer<TGltfResourceLoader> tResourceLoader,
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TNameComponentManager> tNameComponentManager,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  int numInstances,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TMaterial>)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_createGrid(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterial> tMaterial,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external void SceneAsset_destroy(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>, ffi.Pointer<TScene>)>(
    isLeaf: true)
external void SceneAsset_addToScene(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>, ffi.Pointer<TScene>)>(
    isLeaf: true)
external void SceneAsset_removeFromScene(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<EntityId Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getEntity(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getChildEntityCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>, ffi.Pointer<EntityId>)>(
    isLeaf: true)
external void SceneAsset_getChildEntities(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  ffi.Pointer<EntityId> out,
);

@ffi.Native<ffi.Pointer<EntityId> Function(ffi.Pointer<TSceneAsset>)>(
    isLeaf: true)
external ffi.Pointer<EntityId> SceneAsset_getCameraEntities(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getCameraEntityCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Pointer<EntityId> Function(ffi.Pointer<TSceneAsset>)>(
    isLeaf: true)
external ffi.Pointer<EntityId> SceneAsset_getLightEntities(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getLightEntityCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TSceneAsset>, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_getInstance(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  int index,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getInstanceCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.Pointer<TMaterialInstance>>, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_createInstance(
  ffi.Pointer<TSceneAsset> asset,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
);

@ffi.Native<Aabb3 Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external Aabb3 SceneAsset_getBoundingBox(
  ffi.Pointer<TSceneAsset> asset,
);

@ffi.Native<
    ffi.Pointer<TAnimationManager> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<TScene>)>(isLeaf: true)
external ffi.Pointer<TAnimationManager> AnimationManager_create(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TAnimationManager>, EntityId)>(
    isLeaf: true)
external void AnimationManager_addAnimationComponent(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TAnimationManager>, EntityId)>(
    isLeaf: true)
external void AnimationManager_removeAnimationComponent(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>,
        EntityId,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Uint32>,
        ffi.Int,
        ffi.Int,
        ffi.Float)>(isLeaf: true)
external bool AnimationManager_setMorphAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  ffi.Pointer<ffi.Float> morphData,
  ffi.Pointer<ffi.Uint32> morphIndices,
  int numMorphTargets,
  int numFrames,
  double frameLengthInMs,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TAnimationManager>, EntityId)>(
    isLeaf: true)
external bool AnimationManager_clearMorphAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external void AnimationManager_resetToRestPose(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TAnimationManager>,
        ffi.Pointer<TSceneAsset>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float)>(isLeaf: true)
external void AnimationManager_addBoneAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> frameData,
  int numFrames,
  double frameLengthInMs,
  double fadeOutInSecs,
  double fadeInInSecs,
  double maxDelta,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Int)>(isLeaf: true)
external int AnimationManager_getBone(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  int boneIndex,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getRestLocalTransforms(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  ffi.Pointer<ffi.Float> out,
  int numBones,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Int, ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void AnimationManager_getInverseBindMatrix(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> out,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TAnimationManager>,
        ffi.Pointer<TSceneAsset>,
        ffi.Int,
        ffi.Bool,
        ffi.Bool,
        ffi.Bool,
        ffi.Float,
        ffi.Float)>(isLeaf: true)
external void AnimationManager_playAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int index,
  bool loop,
  bool reverse,
  bool replaceActive,
  double crossfade,
  double startOffset,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int)>(isLeaf: true)
external void AnimationManager_stopAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int index,
);

@ffi.Native<
    ffi.Float Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int)>(isLeaf: true)
external double AnimationManager_getAnimationDuration(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int animationIndex,
);

@ffi.Native<
    ffi.Int Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int AnimationManager_getAnimationCount(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getAnimationName(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int)>(isLeaf: true)
external int AnimationManager_getBoneCount(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getBoneNames(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  ffi.Pointer<ffi.Pointer<ffi.Char>> out,
  int skinIndex,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        EntityId)>(isLeaf: true)
external int AnimationManager_getMorphTargetNameCount(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int childEntity,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        EntityId, ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getMorphTargetName(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int childEntity,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external bool AnimationManager_updateBoneMatrices(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TAnimationManager>, EntityId,
        ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external bool AnimationManager_setMorphTargetWeights(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  ffi.Pointer<ffi.Float> morphData,
  int numWeights,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Int)>(isLeaf: true)
external void AnimationManager_setGltfAnimationFrame(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
  int animationIndex,
  int frame,
);

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(LoadFilamentResourceFromOwner,
        FreeFilamentResourceFromOwner, ffi.Pointer<ffi.Void>)>(isLeaf: true)
external ffi.Pointer<ffi.Void> make_resource_loader(
  LoadFilamentResourceFromOwner loadFn,
  FreeFilamentResourceFromOwner freeFn,
  ffi.Pointer<ffi.Void> owner,
);

final class TCamera extends ffi.Opaque {}

final class TEngine extends ffi.Opaque {}

final class TEntityManager extends ffi.Opaque {}

final class TViewer extends ffi.Opaque {}

final class TSceneManager extends ffi.Opaque {}

final class TLightManager extends ffi.Opaque {}

final class TRenderer extends ffi.Opaque {}

final class TRenderTicker extends ffi.Opaque {}

final class TFence extends ffi.Opaque {}

final class TRenderTarget extends ffi.Opaque {}

final class TSwapChain extends ffi.Opaque {}

final class TView extends ffi.Opaque {}

final class TGizmo extends ffi.Opaque {}

final class TScene extends ffi.Opaque {}

final class TSkybox extends ffi.Opaque {}

final class TIndirectLight extends ffi.Opaque {}

final class TTransformManager extends ffi.Opaque {}

final class TAnimationManager extends ffi.Opaque {}

final class TCollisionComponentManager extends ffi.Opaque {}

final class TSceneAsset extends ffi.Opaque {}

final class TNameComponentManager extends ffi.Opaque {}

final class TMaterial extends ffi.Opaque {}

final class TMaterialInstance extends ffi.Opaque {}

final class TMaterialProvider extends ffi.Opaque {}

final class TRenderableManager extends ffi.Opaque {}

final class TRenderableInstance extends ffi.Opaque {}

final class TTexture extends ffi.Opaque {}

final class TTextureSampler extends ffi.Opaque {}

final class TLinearImage extends ffi.Opaque {}

final class TGltfAssetLoader extends ffi.Opaque {}

final class TGltfResourceLoader extends ffi.Opaque {}

final class TFilamentAsset extends ffi.Opaque {}

final class TMaterialKey extends ffi.Struct {
  @ffi.Bool()
  external bool doubleSided;

  @ffi.Bool()
  external bool unlit;

  @ffi.Bool()
  external bool hasVertexColors;

  @ffi.Bool()
  external bool hasBaseColorTexture;

  @ffi.Bool()
  external bool hasNormalTexture;

  @ffi.Bool()
  external bool hasOcclusionTexture;

  @ffi.Bool()
  external bool hasEmissiveTexture;

  @ffi.Bool()
  external bool useSpecularGlossiness;

  @ffi.Int()
  external int alphaMode;

  @ffi.Bool()
  external bool enableDiagnostics;

  external UnnamedUnion1 unnamed;

  @ffi.Uint8()
  external int baseColorUV;

  @ffi.Bool()
  external bool hasClearCoatTexture;

  @ffi.Uint8()
  external int clearCoatUV;

  @ffi.Bool()
  external bool hasClearCoatRoughnessTexture;

  @ffi.Uint8()
  external int clearCoatRoughnessUV;

  @ffi.Bool()
  external bool hasClearCoatNormalTexture;

  @ffi.Uint8()
  external int clearCoatNormalUV;

  @ffi.Bool()
  external bool hasClearCoat;

  @ffi.Bool()
  external bool hasTransmission;

  @ffi.Bool()
  external bool hasTextureTransforms;

  @ffi.Uint8()
  external int emissiveUV;

  @ffi.Uint8()
  external int aoUV;

  @ffi.Uint8()
  external int normalUV;

  @ffi.Bool()
  external bool hasTransmissionTexture;

  @ffi.Uint8()
  external int transmissionUV;

  @ffi.Bool()
  external bool hasSheenColorTexture;

  @ffi.Uint8()
  external int sheenColorUV;

  @ffi.Bool()
  external bool hasSheenRoughnessTexture;

  @ffi.Uint8()
  external int sheenRoughnessUV;

  @ffi.Bool()
  external bool hasVolumeThicknessTexture;

  @ffi.Uint8()
  external int volumeThicknessUV;

  @ffi.Bool()
  external bool hasSheen;

  @ffi.Bool()
  external bool hasIOR;

  @ffi.Bool()
  external bool hasVolume;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 unnamed;

  external UnnamedStruct2 unnamed1;
}

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.Bool()
  external bool hasMetallicRoughnessTexture;

  @ffi.Uint8()
  external int metallicRoughnessUV;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.Bool()
  external bool hasSpecularGlossinessTexture;

  @ffi.Uint8()
  external int specularGlossinessUV;
}

final class double3 extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;

  @ffi.Double()
  external double z;
}

final class double3x3 extends ffi.Struct {
  external double3 col1;

  external double3 col2;

  external double3 col3;
}

final class double4 extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;

  @ffi.Double()
  external double z;

  @ffi.Double()
  external double w;
}

final class double4x4 extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col1;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col2;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col3;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col4;
}

final class Aabb2 extends ffi.Struct {
  @ffi.Float()
  external double minX;

  @ffi.Float()
  external double minY;

  @ffi.Float()
  external double maxX;

  @ffi.Float()
  external double maxY;
}

final class Aabb3 extends ffi.Struct {
  @ffi.Float()
  external double centerX;

  @ffi.Float()
  external double centerY;

  @ffi.Float()
  external double centerZ;

  @ffi.Float()
  external double halfExtentX;

  @ffi.Float()
  external double halfExtentY;

  @ffi.Float()
  external double halfExtentZ;
}

enum TGizmoType {
  TRANSLATION(0),
  ROTATION(1);

  final int value;
  const TGizmoType(this.value);

  static TGizmoType fromValue(int value) => switch (value) {
        0 => TRANSLATION,
        1 => ROTATION,
        _ => throw ArgumentError("Unknown value for TGizmoType: $value"),
      };
}

abstract class TPrimitiveType {
  /// !< points
  static const PRIMITIVETYPE_POINTS = 0;

  /// !< lines
  static const PRIMITIVETYPE_LINES = 1;

  /// !< line strip
  static const PRIMITIVETYPE_LINE_STRIP = 3;

  /// !< triangles
  static const PRIMITIVETYPE_TRIANGLES = 4;

  /// !< triangle strip
  static const PRIMITIVETYPE_TRIANGLE_STRIP = 5;
}

enum TSamplerCompareFunc {
  /// !< Less or equal
  LE(0),

  /// !< Greater or equal
  GE(1),

  /// !< Strictly less than
  L(2),

  /// !< Strictly greater than
  G(3),

  /// !< Equal
  E(4),

  /// !< Not equal
  NE(5),

  /// !< Always. Depth / stencil testing is deactivated.
  A(6),

  /// !< Never. The depth / stencil test always fails.
  N(7);

  final int value;
  const TSamplerCompareFunc(this.value);

  static TSamplerCompareFunc fromValue(int value) => switch (value) {
        0 => LE,
        1 => GE,
        2 => L,
        3 => G,
        4 => E,
        5 => NE,
        6 => A,
        7 => N,
        _ =>
          throw ArgumentError("Unknown value for TSamplerCompareFunc: $value"),
      };
}

enum TStencilOperation {
  KEEP(0),
  ZERO(1),
  REPLACE(2),
  INCR(3),
  INCR_WRAP(4),
  DECR(5),
  DECR_WRAP(6),
  INVERT(7);

  final int value;
  const TStencilOperation(this.value);

  static TStencilOperation fromValue(int value) => switch (value) {
        0 => KEEP,
        1 => ZERO,
        2 => REPLACE,
        3 => INCR,
        4 => INCR_WRAP,
        5 => DECR,
        6 => DECR_WRAP,
        7 => INVERT,
        _ => throw ArgumentError("Unknown value for TStencilOperation: $value"),
      };
}

enum TStencilFace {
  STENCIL_FACE_FRONT(1),
  STENCIL_FACE_BACK(2),
  STENCIL_FACE_FRONT_AND_BACK(3);

  final int value;
  const TStencilFace(this.value);

  static TStencilFace fromValue(int value) => switch (value) {
        1 => STENCIL_FACE_FRONT,
        2 => STENCIL_FACE_BACK,
        3 => STENCIL_FACE_FRONT_AND_BACK,
        _ => throw ArgumentError("Unknown value for TStencilFace: $value"),
      };
}

enum TCullingMode {
  CULLING_MODE_NONE(0),
  CULLING_MODE_FRONT(1),
  CULLING_MODE_BACK(2),
  CULLING_MODE_FRONT_AND_BACK(3);

  final int value;
  const TCullingMode(this.value);

  static TCullingMode fromValue(int value) => switch (value) {
        0 => CULLING_MODE_NONE,
        1 => CULLING_MODE_FRONT,
        2 => CULLING_MODE_BACK,
        3 => CULLING_MODE_FRONT_AND_BACK,
        _ => throw ArgumentError("Unknown value for TCullingMode: $value"),
      };
}

enum TTransparencyMode {
  /// ! the transparent object is drawn honoring the raster state
  DEFAULT(0),

  /// the transparent object is first drawn in the depth buffer,
  /// then in the color buffer, honoring the culling mode, but ignoring the depth test function
  TWO_PASSES_ONE_SIDE(1),

  /// the transparent object is drawn twice in the color buffer,
  /// first with back faces only, then with front faces; the culling
  /// mode is ignored. Can be combined with two-sided lighting
  TWO_PASSES_TWO_SIDES(2);

  final int value;
  const TTransparencyMode(this.value);

  static TTransparencyMode fromValue(int value) => switch (value) {
        0 => DEFAULT,
        1 => TWO_PASSES_ONE_SIDE,
        2 => TWO_PASSES_TWO_SIDES,
        _ => throw ArgumentError("Unknown value for TTransparencyMode: $value"),
      };
}

enum TLightType {
  LIGHT_TYPE_SUN(0),
  LIGHT_TYPE_DIRECTIONAL(1),
  LIGHT_TYPE_POINT(2),
  LIGHT_TYPE_FOCUSED_SPOT(3),
  LIGHT_TYPE_SPOT(4);

  final int value;
  const TLightType(this.value);

  static TLightType fromValue(int value) => switch (value) {
        0 => LIGHT_TYPE_SUN,
        1 => LIGHT_TYPE_DIRECTIONAL,
        2 => LIGHT_TYPE_POINT,
        3 => LIGHT_TYPE_FOCUSED_SPOT,
        4 => LIGHT_TYPE_SPOT,
        _ => throw ArgumentError("Unknown value for TLightType: $value"),
      };
}

typedef EntityId = ffi.Int32;
typedef DartEntityId = int;

enum TTextureSamplerType {
  SAMPLER_2D(0),
  SAMPLER_2D_ARRAY(1),
  SAMPLER_CUBEMAP(2),
  SAMPLER_EXTERNAL(3),
  SAMPLER_3D(4),
  SAMPLER_CUBEMAP_ARRAY(5);

  final int value;
  const TTextureSamplerType(this.value);

  static TTextureSamplerType fromValue(int value) => switch (value) {
        0 => SAMPLER_2D,
        1 => SAMPLER_2D_ARRAY,
        2 => SAMPLER_CUBEMAP,
        3 => SAMPLER_EXTERNAL,
        4 => SAMPLER_3D,
        5 => SAMPLER_CUBEMAP_ARRAY,
        _ =>
          throw ArgumentError("Unknown value for TTextureSamplerType: $value"),
      };
}

enum TTextureFormat {
  TEXTUREFORMAT_R8(0),
  TEXTUREFORMAT_R8_SNORM(1),
  TEXTUREFORMAT_R8UI(2),
  TEXTUREFORMAT_R8I(3),
  TEXTUREFORMAT_STENCIL8(4),
  TEXTUREFORMAT_R16F(5),
  TEXTUREFORMAT_R16UI(6),
  TEXTUREFORMAT_R16I(7),
  TEXTUREFORMAT_RG8(8),
  TEXTUREFORMAT_RG8_SNORM(9),
  TEXTUREFORMAT_RG8UI(10),
  TEXTUREFORMAT_RG8I(11),
  TEXTUREFORMAT_RGB565(12),
  TEXTUREFORMAT_RGB9_E5(13),
  TEXTUREFORMAT_RGB5_A1(14),
  TEXTUREFORMAT_RGBA4(15),
  TEXTUREFORMAT_DEPTH16(16),
  TEXTUREFORMAT_RGB8(17),
  TEXTUREFORMAT_SRGB8(18),
  TEXTUREFORMAT_RGB8_SNORM(19),
  TEXTUREFORMAT_RGB8UI(20),
  TEXTUREFORMAT_RGB8I(21),
  TEXTUREFORMAT_DEPTH24(22),
  TEXTUREFORMAT_R32F(23),
  TEXTUREFORMAT_R32UI(24),
  TEXTUREFORMAT_R32I(25),
  TEXTUREFORMAT_RG16F(26),
  TEXTUREFORMAT_RG16UI(27),
  TEXTUREFORMAT_RG16I(28),
  TEXTUREFORMAT_R11F_G11F_B10F(29),
  TEXTUREFORMAT_RGBA8(30),
  TEXTUREFORMAT_SRGB8_A8(31),
  TEXTUREFORMAT_RGBA8_SNORM(32),
  TEXTUREFORMAT_UNUSED(33),
  TEXTUREFORMAT_RGB10_A2(34),
  TEXTUREFORMAT_RGBA8UI(35),
  TEXTUREFORMAT_RGBA8I(36),
  TEXTUREFORMAT_DEPTH32F(37),
  TEXTUREFORMAT_DEPTH24_STENCIL8(38),
  TEXTUREFORMAT_DEPTH32F_STENCIL8(39),
  TEXTUREFORMAT_RGB16F(40),
  TEXTUREFORMAT_RGB16UI(41),
  TEXTUREFORMAT_RGB16I(42),
  TEXTUREFORMAT_RG32F(43),
  TEXTUREFORMAT_RG32UI(44),
  TEXTUREFORMAT_RG32I(45),
  TEXTUREFORMAT_RGBA16F(46),
  TEXTUREFORMAT_RGBA16UI(47),
  TEXTUREFORMAT_RGBA16I(48),
  TEXTUREFORMAT_RGB32F(49),
  TEXTUREFORMAT_RGB32UI(50),
  TEXTUREFORMAT_RGB32I(51),
  TEXTUREFORMAT_RGBA32F(52),
  TEXTUREFORMAT_RGBA32UI(53),
  TEXTUREFORMAT_RGBA32I(54),
  TEXTUREFORMAT_EAC_R11(55),
  TEXTUREFORMAT_EAC_R11_SIGNED(56),
  TEXTUREFORMAT_EAC_RG11(57),
  TEXTUREFORMAT_EAC_RG11_SIGNED(58),
  TEXTUREFORMAT_ETC2_RGB8(59),
  TEXTUREFORMAT_ETC2_SRGB8(60),
  TEXTUREFORMAT_ETC2_RGB8_A1(61),
  TEXTUREFORMAT_ETC2_SRGB8_A1(62),
  TEXTUREFORMAT_ETC2_EAC_RGBA8(63),
  TEXTUREFORMAT_ETC2_EAC_SRGBA8(64),
  TEXTUREFORMAT_DXT1_RGB(65),
  TEXTUREFORMAT_DXT1_RGBA(66),
  TEXTUREFORMAT_DXT3_RGBA(67),
  TEXTUREFORMAT_DXT5_RGBA(68),
  TEXTUREFORMAT_DXT1_SRGB(69),
  TEXTUREFORMAT_DXT1_SRGBA(70),
  TEXTUREFORMAT_DXT3_SRGBA(71),
  TEXTUREFORMAT_DXT5_SRGBA(72),
  TEXTUREFORMAT_RGBA_ASTC_4x4(73),
  TEXTUREFORMAT_RGBA_ASTC_5x4(74),
  TEXTUREFORMAT_RGBA_ASTC_5x5(75),
  TEXTUREFORMAT_RGBA_ASTC_6x5(76),
  TEXTUREFORMAT_RGBA_ASTC_6x6(77),
  TEXTUREFORMAT_RGBA_ASTC_8x5(78),
  TEXTUREFORMAT_RGBA_ASTC_8x6(79),
  TEXTUREFORMAT_RGBA_ASTC_8x8(80),
  TEXTUREFORMAT_RGBA_ASTC_10x5(81),
  TEXTUREFORMAT_RGBA_ASTC_10x6(82),
  TEXTUREFORMAT_RGBA_ASTC_10x8(83),
  TEXTUREFORMAT_RGBA_ASTC_10x10(84),
  TEXTUREFORMAT_RGBA_ASTC_12x10(85),
  TEXTUREFORMAT_RGBA_ASTC_12x12(86),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_4x4(87),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x4(88),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x5(89),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x5(90),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x6(91),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x5(92),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x6(93),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x8(94),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x5(95),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x6(96),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x8(97),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x10(98),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x10(99),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x12(100),
  TEXTUREFORMAT_RED_RGTC1(101),
  TEXTUREFORMAT_SIGNED_RED_RGTC1(102),
  TEXTUREFORMAT_RED_GREEN_RGTC2(103),
  TEXTUREFORMAT_SIGNED_RED_GREEN_RGTC2(104),
  TEXTUREFORMAT_RGB_BPTC_SIGNED_FLOAT(105),
  TEXTUREFORMAT_RGB_BPTC_UNSIGNED_FLOAT(106),
  TEXTUREFORMAT_RGBA_BPTC_UNORM(107),
  TEXTUREFORMAT_SRGB_ALPHA_BPTC_UNORM(108);

  final int value;
  const TTextureFormat(this.value);

  static TTextureFormat fromValue(int value) => switch (value) {
        0 => TEXTUREFORMAT_R8,
        1 => TEXTUREFORMAT_R8_SNORM,
        2 => TEXTUREFORMAT_R8UI,
        3 => TEXTUREFORMAT_R8I,
        4 => TEXTUREFORMAT_STENCIL8,
        5 => TEXTUREFORMAT_R16F,
        6 => TEXTUREFORMAT_R16UI,
        7 => TEXTUREFORMAT_R16I,
        8 => TEXTUREFORMAT_RG8,
        9 => TEXTUREFORMAT_RG8_SNORM,
        10 => TEXTUREFORMAT_RG8UI,
        11 => TEXTUREFORMAT_RG8I,
        12 => TEXTUREFORMAT_RGB565,
        13 => TEXTUREFORMAT_RGB9_E5,
        14 => TEXTUREFORMAT_RGB5_A1,
        15 => TEXTUREFORMAT_RGBA4,
        16 => TEXTUREFORMAT_DEPTH16,
        17 => TEXTUREFORMAT_RGB8,
        18 => TEXTUREFORMAT_SRGB8,
        19 => TEXTUREFORMAT_RGB8_SNORM,
        20 => TEXTUREFORMAT_RGB8UI,
        21 => TEXTUREFORMAT_RGB8I,
        22 => TEXTUREFORMAT_DEPTH24,
        23 => TEXTUREFORMAT_R32F,
        24 => TEXTUREFORMAT_R32UI,
        25 => TEXTUREFORMAT_R32I,
        26 => TEXTUREFORMAT_RG16F,
        27 => TEXTUREFORMAT_RG16UI,
        28 => TEXTUREFORMAT_RG16I,
        29 => TEXTUREFORMAT_R11F_G11F_B10F,
        30 => TEXTUREFORMAT_RGBA8,
        31 => TEXTUREFORMAT_SRGB8_A8,
        32 => TEXTUREFORMAT_RGBA8_SNORM,
        33 => TEXTUREFORMAT_UNUSED,
        34 => TEXTUREFORMAT_RGB10_A2,
        35 => TEXTUREFORMAT_RGBA8UI,
        36 => TEXTUREFORMAT_RGBA8I,
        37 => TEXTUREFORMAT_DEPTH32F,
        38 => TEXTUREFORMAT_DEPTH24_STENCIL8,
        39 => TEXTUREFORMAT_DEPTH32F_STENCIL8,
        40 => TEXTUREFORMAT_RGB16F,
        41 => TEXTUREFORMAT_RGB16UI,
        42 => TEXTUREFORMAT_RGB16I,
        43 => TEXTUREFORMAT_RG32F,
        44 => TEXTUREFORMAT_RG32UI,
        45 => TEXTUREFORMAT_RG32I,
        46 => TEXTUREFORMAT_RGBA16F,
        47 => TEXTUREFORMAT_RGBA16UI,
        48 => TEXTUREFORMAT_RGBA16I,
        49 => TEXTUREFORMAT_RGB32F,
        50 => TEXTUREFORMAT_RGB32UI,
        51 => TEXTUREFORMAT_RGB32I,
        52 => TEXTUREFORMAT_RGBA32F,
        53 => TEXTUREFORMAT_RGBA32UI,
        54 => TEXTUREFORMAT_RGBA32I,
        55 => TEXTUREFORMAT_EAC_R11,
        56 => TEXTUREFORMAT_EAC_R11_SIGNED,
        57 => TEXTUREFORMAT_EAC_RG11,
        58 => TEXTUREFORMAT_EAC_RG11_SIGNED,
        59 => TEXTUREFORMAT_ETC2_RGB8,
        60 => TEXTUREFORMAT_ETC2_SRGB8,
        61 => TEXTUREFORMAT_ETC2_RGB8_A1,
        62 => TEXTUREFORMAT_ETC2_SRGB8_A1,
        63 => TEXTUREFORMAT_ETC2_EAC_RGBA8,
        64 => TEXTUREFORMAT_ETC2_EAC_SRGBA8,
        65 => TEXTUREFORMAT_DXT1_RGB,
        66 => TEXTUREFORMAT_DXT1_RGBA,
        67 => TEXTUREFORMAT_DXT3_RGBA,
        68 => TEXTUREFORMAT_DXT5_RGBA,
        69 => TEXTUREFORMAT_DXT1_SRGB,
        70 => TEXTUREFORMAT_DXT1_SRGBA,
        71 => TEXTUREFORMAT_DXT3_SRGBA,
        72 => TEXTUREFORMAT_DXT5_SRGBA,
        73 => TEXTUREFORMAT_RGBA_ASTC_4x4,
        74 => TEXTUREFORMAT_RGBA_ASTC_5x4,
        75 => TEXTUREFORMAT_RGBA_ASTC_5x5,
        76 => TEXTUREFORMAT_RGBA_ASTC_6x5,
        77 => TEXTUREFORMAT_RGBA_ASTC_6x6,
        78 => TEXTUREFORMAT_RGBA_ASTC_8x5,
        79 => TEXTUREFORMAT_RGBA_ASTC_8x6,
        80 => TEXTUREFORMAT_RGBA_ASTC_8x8,
        81 => TEXTUREFORMAT_RGBA_ASTC_10x5,
        82 => TEXTUREFORMAT_RGBA_ASTC_10x6,
        83 => TEXTUREFORMAT_RGBA_ASTC_10x8,
        84 => TEXTUREFORMAT_RGBA_ASTC_10x10,
        85 => TEXTUREFORMAT_RGBA_ASTC_12x10,
        86 => TEXTUREFORMAT_RGBA_ASTC_12x12,
        87 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_4x4,
        88 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x4,
        89 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x5,
        90 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x5,
        91 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x6,
        92 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x5,
        93 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x6,
        94 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x8,
        95 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x5,
        96 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x6,
        97 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x8,
        98 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x10,
        99 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x10,
        100 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x12,
        101 => TEXTUREFORMAT_RED_RGTC1,
        102 => TEXTUREFORMAT_SIGNED_RED_RGTC1,
        103 => TEXTUREFORMAT_RED_GREEN_RGTC2,
        104 => TEXTUREFORMAT_SIGNED_RED_GREEN_RGTC2,
        105 => TEXTUREFORMAT_RGB_BPTC_SIGNED_FLOAT,
        106 => TEXTUREFORMAT_RGB_BPTC_UNSIGNED_FLOAT,
        107 => TEXTUREFORMAT_RGBA_BPTC_UNORM,
        108 => TEXTUREFORMAT_SRGB_ALPHA_BPTC_UNORM,
        _ => throw ArgumentError("Unknown value for TTextureFormat: $value"),
      };
}

/// ! Pixel Data Format
abstract class TPixelDataFormat {
  /// !< One Red channel, float
  static const PIXELDATAFORMAT_R = 0;

  /// !< One Red channel, integer
  static const PIXELDATAFORMAT_R_INTEGER = 1;

  /// !< Two Red and Green channels, float
  static const PIXELDATAFORMAT_RG = 2;

  /// !< Two Red and Green channels, integer
  static const PIXELDATAFORMAT_RG_INTEGER = 3;

  /// !< Three Red, Green and Blue channels, float
  static const PIXELDATAFORMAT_RGB = 4;

  /// !< Three Red, Green and Blue channels, integer
  static const PIXELDATAFORMAT_RGB_INTEGER = 5;

  /// !< Four Red, Green, Blue and Alpha channels, float
  static const PIXELDATAFORMAT_RGBA = 6;

  /// !< Four Red, Green, Blue and Alpha channels, integer
  static const PIXELDATAFORMAT_RGBA_INTEGER = 7;
  static const PIXELDATAFORMAT_UNUSED = 8;

  /// !< Depth, 16-bit or 24-bits usually
  static const PIXELDATAFORMAT_DEPTH_COMPONENT = 9;

  /// !< Two Depth (24-bits) + Stencil (8-bits) channels
  static const PIXELDATAFORMAT_DEPTH_STENCIL = 10;
  static const PIXELDATAFORMAT_ALPHA = 11;
}

abstract class TPixelDataType {
  /// !< unsigned byte
  static const PIXELDATATYPE_UBYTE = 0;

  /// !< signed byte
  static const PIXELDATATYPE_BYTE = 1;

  /// !< unsigned short (16-bit)
  static const PIXELDATATYPE_USHORT = 2;

  /// !< signed short (16-bit)
  static const PIXELDATATYPE_SHORT = 3;

  /// !< unsigned int (32-bit)
  static const PIXELDATATYPE_UINT = 4;

  /// !< signed int (32-bit)
  static const PIXELDATATYPE_INT = 5;

  /// !< half-float (16-bit float)
  static const PIXELDATATYPE_HALF = 6;

  /// !< float (32-bits float)
  static const PIXELDATATYPE_FLOAT = 7;

  /// !< compressed pixels, @see CompressedPixelDataType
  static const PIXELDATATYPE_COMPRESSED = 8;

  /// !< three low precision floating-point numbers
  static const PIXELDATATYPE_UINT_10F_11F_11F_REV = 9;

  /// !< unsigned int (16-bit), encodes 3 RGB channels
  static const PIXELDATATYPE_USHORT_565 = 10;

  /// !< unsigned normalized 10 bits RGB, 2 bits alpha
  static const PIXELDATATYPE_UINT_2_10_10_10_REV = 11;
}

enum TTextureUsage {
  TEXTURE_USAGE_NONE(0),

  /// !< Texture can be used as a color attachment
  TEXTURE_USAGE_COLOR_ATTACHMENT(1),

  /// !< Texture can be used as a depth attachment
  TEXTURE_USAGE_DEPTH_ATTACHMENT(2),

  /// !< Texture can be used as a stencil attachment
  TEXTURE_USAGE_STENCIL_ATTACHMENT(4),

  /// !< Data can be uploaded into this texture (default)
  TEXTURE_USAGE_UPLOADABLE(8),

  /// !< Texture can be sampled (default)
  TEXTURE_USAGE_SAMPLEABLE(16),

  /// !< Texture can be used as a subpass input
  TEXTURE_USAGE_SUBPASS_INPUT(32),

  /// !< Texture can be used the source of a blit()
  TEXTURE_USAGE_BLIT_SRC(64),

  /// !< Texture can be used the destination of a blit()
  TEXTURE_USAGE_BLIT_DST(128),

  /// !< Texture can be used the destination of a blit()
  TEXTURE_USAGE_PROTECTED(256),

  /// !< Default texture usage
  TEXTURE_USAGE_DEFAULT(24);

  final int value;
  const TTextureUsage(this.value);

  static TTextureUsage fromValue(int value) => switch (value) {
        0 => TEXTURE_USAGE_NONE,
        1 => TEXTURE_USAGE_COLOR_ATTACHMENT,
        2 => TEXTURE_USAGE_DEPTH_ATTACHMENT,
        4 => TEXTURE_USAGE_STENCIL_ATTACHMENT,
        8 => TEXTURE_USAGE_UPLOADABLE,
        16 => TEXTURE_USAGE_SAMPLEABLE,
        32 => TEXTURE_USAGE_SUBPASS_INPUT,
        64 => TEXTURE_USAGE_BLIT_SRC,
        128 => TEXTURE_USAGE_BLIT_DST,
        256 => TEXTURE_USAGE_PROTECTED,
        24 => TEXTURE_USAGE_DEFAULT,
        _ => throw ArgumentError("Unknown value for TTextureUsage: $value"),
      };
}

enum TSamplerWrapMode {
  WRAP_CLAMP_TO_EDGE(0),
  WRAP_REPEAT(1),
  WRAP_MIRRORED_REPEAT(2);

  final int value;
  const TSamplerWrapMode(this.value);

  static TSamplerWrapMode fromValue(int value) => switch (value) {
        0 => WRAP_CLAMP_TO_EDGE,
        1 => WRAP_REPEAT,
        2 => WRAP_MIRRORED_REPEAT,
        _ => throw ArgumentError("Unknown value for TSamplerWrapMode: $value"),
      };
}

enum TSamplerMinFilter {
  FILTER_NEAREST(0),
  FILTER_LINEAR(1),
  FILTER_NEAREST_MIPMAP_NEAREST(2),
  FILTER_LINEAR_MIPMAP_NEAREST(3),
  FILTER_NEAREST_MIPMAP_LINEAR(4),
  FILTER_LINEAR_MIPMAP_LINEAR(5);

  final int value;
  const TSamplerMinFilter(this.value);

  static TSamplerMinFilter fromValue(int value) => switch (value) {
        0 => FILTER_NEAREST,
        1 => FILTER_LINEAR,
        2 => FILTER_NEAREST_MIPMAP_NEAREST,
        3 => FILTER_LINEAR_MIPMAP_NEAREST,
        4 => FILTER_NEAREST_MIPMAP_LINEAR,
        5 => FILTER_LINEAR_MIPMAP_LINEAR,
        _ => throw ArgumentError("Unknown value for TSamplerMinFilter: $value"),
      };
}

enum TSamplerMagFilter {
  MAG_FILTER_NEAREST(0),
  MAG_FILTER_LINEAR(1);

  final int value;
  const TSamplerMagFilter(this.value);

  static TSamplerMagFilter fromValue(int value) => switch (value) {
        0 => MAG_FILTER_NEAREST,
        1 => MAG_FILTER_LINEAR,
        _ => throw ArgumentError("Unknown value for TSamplerMagFilter: $value"),
      };
}

enum TSamplerCompareMode {
  COMPARE_MODE_NONE(0),
  COMPARE_MODE_COMPARE_TO_TEXTURE(1);

  final int value;
  const TSamplerCompareMode(this.value);

  static TSamplerCompareMode fromValue(int value) => switch (value) {
        0 => COMPARE_MODE_NONE,
        1 => COMPARE_MODE_COMPARE_TO_TEXTURE,
        _ =>
          throw ArgumentError("Unknown value for TSamplerCompareMode: $value"),
      };
}

final class TViewport extends ffi.Struct {
  @ffi.Int32()
  external int left;

  @ffi.Int32()
  external int bottom;

  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;
}

enum TToneMapping {
  ACES(0),
  FILMIC(1),
  LINEAR(2);

  final int value;
  const TToneMapping(this.value);

  static TToneMapping fromValue(int value) => switch (value) {
        0 => ACES,
        1 => FILMIC,
        2 => LINEAR,
        _ => throw ArgumentError("Unknown value for TToneMapping: $value"),
      };
}

enum TQualityLevel {
  LOW(0),
  MEDIUM(1),
  HIGH(2),
  ULTRA(3);

  final int value;
  const TQualityLevel(this.value);

  static TQualityLevel fromValue(int value) => switch (value) {
        0 => LOW,
        1 => MEDIUM,
        2 => HIGH,
        3 => ULTRA,
        _ => throw ArgumentError("Unknown value for TQualityLevel: $value"),
      };
}

typedef PickCallback = ffi.Pointer<ffi.NativeFunction<PickCallbackFunction>>;
typedef PickCallbackFunction = ffi.Void Function(
    ffi.Uint32 requestId,
    EntityId entityId,
    ffi.Float depth,
    ffi.Float fragX,
    ffi.Float fragY,
    ffi.Float fragZ);
typedef DartPickCallbackFunction = void Function(
    int requestId,
    DartEntityId entityId,
    double depth,
    double fragX,
    double fragY,
    double fragZ);

enum TGizmoAxis {
  X(0),
  Y(1),
  Z(2);

  final int value;
  const TGizmoAxis(this.value);

  static TGizmoAxis fromValue(int value) => switch (value) {
        0 => X,
        1 => Y,
        2 => Z,
        _ => throw ArgumentError("Unknown value for TGizmoAxis: $value"),
      };
}

enum TGizmoPickResultType {
  AxisX(0),
  AxisY(1),
  AxisZ(2),
  Parent(3),
  None(4);

  final int value;
  const TGizmoPickResultType(this.value);

  static TGizmoPickResultType fromValue(int value) => switch (value) {
        0 => AxisX,
        1 => AxisY,
        2 => AxisZ,
        3 => Parent,
        4 => None,
        _ =>
          throw ArgumentError("Unknown value for TGizmoPickResultType: $value"),
      };
}

typedef GizmoPickCallback
    = ffi.Pointer<ffi.NativeFunction<GizmoPickCallbackFunction>>;
typedef GizmoPickCallbackFunction = ffi.Void Function(
    ffi.UnsignedInt resultType, ffi.Float x, ffi.Float y, ffi.Float z);
typedef DartGizmoPickCallbackFunction = void Function(
    TGizmoPickResultType resultType, double x, double y, double z);

enum TProjection {
  Perspective(0),
  Orthographic(1);

  final int value;
  const TProjection(this.value);

  static TProjection fromValue(int value) => switch (value) {
        0 => Perspective,
        1 => Orthographic,
        _ => throw ArgumentError("Unknown value for TProjection: $value"),
      };
}

typedef FilamentRenderCallback
    = ffi.Pointer<ffi.NativeFunction<FilamentRenderCallbackFunction>>;
typedef FilamentRenderCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> owner);
typedef DartFilamentRenderCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> owner);

enum TBackend {
  /// !< Automatically selects an appropriate driver for the platform.
  BACKEND_DEFAULT(0),

  /// !< Selects the OpenGL/ES driver (default on Android)
  BACKEND_OPENGL(1),

  /// !< Selects the Vulkan driver if the platform supports it (default on Linux/Windows)
  BACKEND_VULKAN(2),

  /// !< Selects the Metal driver if the platform supports it (default on MacOS/iOS).
  BACKEND_METAL(3),

  /// !< Selects the no-op driver for testing purposes.
  BACKEND_NOOP(4);

  final int value;
  const TBackend(this.value);

  static TBackend fromValue(int value) => switch (value) {
        0 => BACKEND_DEFAULT,
        1 => BACKEND_OPENGL,
        2 => BACKEND_VULKAN,
        3 => BACKEND_METAL,
        4 => BACKEND_NOOP,
        _ => throw ArgumentError("Unknown value for TBackend: $value"),
      };
}

final class ResourceBuffer extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @ffi.Int32()
  external int size;

  @ffi.Int32()
  external int id;
}

final class ResourceLoaderWrapper extends ffi.Struct {
  external LoadFilamentResource loadResource;

  external FreeFilamentResource freeResource;

  external LoadFilamentResourceFromOwner loadFromOwner;

  external FreeFilamentResourceFromOwner freeFromOwner;

  external ffi.Pointer<ffi.Void> owner;

  external LoadFilamentResourceIntoOutPointer loadToOut;
}

typedef LoadFilamentResource
    = ffi.Pointer<ffi.NativeFunction<LoadFilamentResourceFunction>>;
typedef LoadFilamentResourceFunction = ResourceBuffer Function(
    ffi.Pointer<ffi.Char> uri);
typedef FreeFilamentResource
    = ffi.Pointer<ffi.NativeFunction<FreeFilamentResourceFunction>>;
typedef FreeFilamentResourceFunction = ffi.Void Function(ResourceBuffer);
typedef DartFreeFilamentResourceFunction = void Function(ResourceBuffer);
typedef LoadFilamentResourceFromOwner
    = ffi.Pointer<ffi.NativeFunction<LoadFilamentResourceFromOwnerFunction>>;
typedef LoadFilamentResourceFromOwnerFunction = ResourceBuffer Function(
    ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>);
typedef FreeFilamentResourceFromOwner
    = ffi.Pointer<ffi.NativeFunction<FreeFilamentResourceFromOwnerFunction>>;
typedef FreeFilamentResourceFromOwnerFunction = ffi.Void Function(
    ResourceBuffer, ffi.Pointer<ffi.Void>);
typedef DartFreeFilamentResourceFromOwnerFunction = void Function(
    ResourceBuffer, ffi.Pointer<ffi.Void>);
typedef LoadFilamentResourceIntoOutPointer = ffi
    .Pointer<ffi.NativeFunction<LoadFilamentResourceIntoOutPointerFunction>>;
typedef LoadFilamentResourceIntoOutPointerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Char> uri, ffi.Pointer<ResourceBuffer> out);
typedef DartLoadFilamentResourceIntoOutPointerFunction = void Function(
    ffi.Pointer<ffi.Char> uri, ffi.Pointer<ResourceBuffer> out);

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;
