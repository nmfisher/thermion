// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('package:thermion_dart/thermion_dart.dart')
library;

import 'dart:ffi' as ffi;

@ffi.Native<ffi.Pointer<TMaterialInstance> Function(ffi.Pointer<TMaterial>)>(
    isLeaf: true)
external ffi.Pointer<TMaterialInstance> Material_createInstance(
  ffi.Pointer<TMaterial> tMaterial,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external bool MaterialInstance_isStencilWriteEnabled(
  ffi.Pointer<TMaterialInstance> materialInstance,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setStencilWrite(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setCullingMode", isLeaf: true)
external void _MaterialInstance_setCullingMode(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int culling,
);

void MaterialInstance_setCullingMode(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TCullingMode culling,
) =>
    _MaterialInstance_setCullingMode(
      materialInstance,
      culling.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setDepthWrite(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setDepthCulling(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double, ffi.Double, ffi.Double, ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat4(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> name,
  double x,
  double y,
  double w,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat2(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> name,
  double x,
  double y,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Double)>(isLeaf: true)
external void MaterialInstance_setParameterFloat(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> name,
  double value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Int)>(isLeaf: true)
external void MaterialInstance_setParameterInt(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> name,
  int value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<TTexture>, ffi.Pointer<TTextureSampler>)>(isLeaf: true)
external void MaterialInstance_setParameterTexture(
  ffi.Pointer<TMaterialInstance> materialInstance,
  ffi.Pointer<ffi.Char> propertyName,
  ffi.Pointer<TTexture> texture,
  ffi.Pointer<TTextureSampler> sampler,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setDepthFunc", isLeaf: true)
external void _MaterialInstance_setDepthFunc(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int depthFunc,
);

void MaterialInstance_setDepthFunc(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TSamplerCompareFunc depthFunc,
) =>
    _MaterialInstance_setDepthFunc(
      materialInstance,
      depthFunc.value,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setStencilOpStencilFail", isLeaf: true)
external void _MaterialInstance_setStencilOpStencilFail(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int op,
  int face,
);

void MaterialInstance_setStencilOpStencilFail(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TStencilOperation op,
  TStencilFace face,
) =>
    _MaterialInstance_setStencilOpStencilFail(
      materialInstance,
      op.value,
      face.value,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setStencilOpDepthFail", isLeaf: true)
external void _MaterialInstance_setStencilOpDepthFail(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int op,
  int face,
);

void MaterialInstance_setStencilOpDepthFail(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TStencilOperation op,
  TStencilFace face,
) =>
    _MaterialInstance_setStencilOpDepthFail(
      materialInstance,
      op.value,
      face.value,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setStencilOpDepthStencilPass", isLeaf: true)
external void _MaterialInstance_setStencilOpDepthStencilPass(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int op,
  int face,
);

void MaterialInstance_setStencilOpDepthStencilPass(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TStencilOperation op,
  TStencilFace face,
) =>
    _MaterialInstance_setStencilOpDepthStencilPass(
      materialInstance,
      op.value,
      face.value,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setStencilCompareFunction", isLeaf: true)
external void _MaterialInstance_setStencilCompareFunction(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int func,
  int face,
);

void MaterialInstance_setStencilCompareFunction(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TSamplerCompareFunc func,
  TStencilFace face,
) =>
    _MaterialInstance_setStencilCompareFunction(
      materialInstance,
      func.value,
      face.value,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TMaterialInstance>, ffi.Uint8, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setStencilReferenceValue", isLeaf: true)
external void _MaterialInstance_setStencilReferenceValue(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int value,
  int face,
);

void MaterialInstance_setStencilReferenceValue(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int value,
  TStencilFace face,
) =>
    _MaterialInstance_setStencilReferenceValue(
      materialInstance,
      value,
      face.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Uint8)>(
    isLeaf: true)
external void MaterialInstance_setStencilReadMask(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int mask,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Uint8)>(
    isLeaf: true)
external void MaterialInstance_setStencilWriteMask(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int mask,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.UnsignedInt)>(
    symbol: "MaterialInstance_setTransparencyMode", isLeaf: true)
external void _MaterialInstance_setTransparencyMode(
  ffi.Pointer<TMaterialInstance> materialInstance,
  int transparencyMode,
);

void MaterialInstance_setTransparencyMode(
  ffi.Pointer<TMaterialInstance> materialInstance,
  TTransparencyMode transparencyMode,
) =>
    _MaterialInstance_setTransparencyMode(
      materialInstance,
      transparencyMode.value,
    );

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Double,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void LightManager_setPosition(
  ffi.Pointer<TLightManager> tLightManager,
  int light,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Double,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void LightManager_setDirection(
  ffi.Pointer<TLightManager> tLightManager,
  int light,
  double x,
  double y,
  double z,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TLightManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external int LightManager_createLight(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  int type,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLightManager>, EntityId)>(
    isLeaf: true)
external void LightManager_destroyLight(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Double,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void LightManager_setColor(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double r,
  double g,
  double b,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TLightManager>, EntityId, ffi.Double)>(isLeaf: true)
external void LightManager_setIntensity(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double intensity,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TLightManager>, EntityId, ffi.Double)>(isLeaf: true)
external void LightManager_setFalloff(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double falloff,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Double,
        ffi.Double)>(isLeaf: true)
external void LightManager_setSpotLightCone(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  double inner,
  double outer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLightManager>, EntityId, ffi.Bool)>(
    isLeaf: true)
external void LightManager_setShadowCaster(
  ffi.Pointer<TLightManager> tLightManager,
  int entity,
  bool enabled,
);

@ffi.Native<
    ffi.Pointer<TViewer> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>(isLeaf: true)
external ffi.Pointer<TViewer> Viewer_create(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<ffi.Void> loader,
  ffi.Pointer<ffi.Void> platform,
  ffi.Pointer<ffi.Char> uberArchivePath,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void Viewer_destroy(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Pointer<TSceneManager> Function(ffi.Pointer<TViewer>)>(
    isLeaf: true)
external ffi.Pointer<TSceneManager> Viewer_getSceneManager(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Pointer<TRenderTarget> Function(
        ffi.Pointer<TViewer>, ffi.IntPtr, ffi.Uint32, ffi.Uint32)>(isLeaf: true)
external ffi.Pointer<TRenderTarget> Viewer_createRenderTarget(
  ffi.Pointer<TViewer> viewer,
  int texture,
  int width,
  int height,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Pointer<TRenderTarget>)>(isLeaf: true)
external void Viewer_destroyRenderTarget(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TRenderTarget> tRenderTarget,
);

@ffi.Native<
    ffi.Pointer<TSwapChain> Function(
        ffi.Pointer<TViewer>, ffi.Pointer<ffi.Void>)>(isLeaf: true)
external ffi.Pointer<TSwapChain> Viewer_createSwapChain(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Void> window,
);

@ffi.Native<
    ffi.Pointer<TSwapChain> Function(
        ffi.Pointer<TViewer>, ffi.Uint32, ffi.Uint32)>(isLeaf: true)
external ffi.Pointer<TSwapChain> Viewer_createHeadlessSwapChain(
  ffi.Pointer<TViewer> viewer,
  int width,
  int height,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TSwapChain>)>(
    isLeaf: true)
external void Viewer_destroySwapChain(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TSwapChain> swapChain,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void Viewer_render(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TSwapChain>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_capture(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> view,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<ffi.Uint8> pixelBuffer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TSwapChain>,
        ffi.Pointer<TRenderTarget>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_captureRenderTarget(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> view,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<TRenderTarget> renderTarget,
  ffi.Pointer<ffi.Uint8> pixelBuffer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<ffi.Pointer<TView> Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external ffi.Pointer<TView> Viewer_createView(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Pointer<TView> Function(ffi.Pointer<TViewer>, ffi.Int)>(
    isLeaf: true)
external ffi.Pointer<TView> Viewer_getViewAt(
  ffi.Pointer<TViewer> viewer,
  int index,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TView>)>(
    isLeaf: true)
external void Viewer_setMainCamera(
  ffi.Pointer<TViewer> tViewer,
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Pointer<TSwapChain> Function(ffi.Pointer<TViewer>, ffi.Int)>(
    isLeaf: true)
external ffi.Pointer<TSwapChain> Viewer_getSwapChainAt(
  ffi.Pointer<TViewer> tViewer,
  int index,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TSwapChain>,
        ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void Viewer_setViewRenderable(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<TView> view,
  bool renderable,
);

@ffi.Native<ffi.Pointer<TEngine> Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external ffi.Pointer<TEngine> Viewer_getEngine(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_background_image(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Bool)>(isLeaf: true)
external void set_background_image(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> path,
  bool fillHeight,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Bool)>(isLeaf: true)
external void set_background_image_position(
  ffi.Pointer<TViewer> viewer,
  double x,
  double y,
  bool clamp,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void set_background_color(
  ffi.Pointer<TViewer> viewer,
  double r,
  double g,
  double b,
  double a,
);

@ffi.Native<EntityId Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external int Viewer_getMainCamera(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>)>(
    isLeaf: true)
external void Viewer_loadSkybox(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> skyboxPath,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void Viewer_removeSkybox(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Float)>(isLeaf: true)
external void Viewer_loadIbl(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> iblPath,
  double intensity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void Viewer_removeIbl(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void create_ibl(
  ffi.Pointer<TViewer> viewer,
  double r,
  double g,
  double b,
  double intensity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Float>)>(
    isLeaf: true)
external void rotate_ibl(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Float> rotationMatrix,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float)>(isLeaf: true)
external void set_frame_interval(
  ffi.Pointer<TViewer> viewer,
  double interval,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void queue_relative_position_update_world_axis(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double viewportX,
  double viewportY,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, ffi.Pointer<TView>, EntityId,
        ffi.Float, ffi.Float)>(isLeaf: true)
external void queue_position_update_from_viewport_coords(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TView> view,
  int entity,
  double viewportX,
  double viewportY,
);

@ffi.Native<ffi.Void Function()>(isLeaf: true)
external void ios_dummy();

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(isLeaf: true)
external void thermion_flutter_free(
  ffi.Pointer<ffi.Void> ptr,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(EntityId entityId1, EntityId entityId2)>>,
        ffi.Bool)>(isLeaf: true)
external void add_collision_component(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(EntityId entityId1, EntityId entityId2)>>
      callback,
  bool affectsCollidingTransform,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void remove_collision_component(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void test_collisions(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
);

@ffi.Native<
    Aabb2 Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<TView>, EntityId)>(isLeaf: true)
external Aabb2 get_bounding_box(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TView> view,
  int entity,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<TView>,
        EntityId,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void get_bounding_box_to_out(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TView> view,
  int entity,
  ffi.Pointer<ffi.Float> minX,
  ffi.Pointer<ffi.Float> minY,
  ffi.Pointer<ffi.Float> maxX,
  ffi.Pointer<ffi.Float> maxY,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<ffi.Void>)>(isLeaf: true)
external void destroy_texture(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Void> texture,
);

@ffi.Native<TViewport Function(ffi.Pointer<TView>)>(isLeaf: true)
external TViewport View_getViewport(
  ffi.Pointer<TView> view,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Uint32, ffi.Uint32)>(
    isLeaf: true)
external void View_updateViewport(
  ffi.Pointer<TView> view,
  int width,
  int height,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TRenderTarget>)>(
    isLeaf: true)
external void View_setRenderTarget(
  ffi.Pointer<TView> view,
  ffi.Pointer<TRenderTarget> renderTarget,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setFrustumCullingEnabled(
  ffi.Pointer<TView> view,
  bool enabled,
);

@ffi.Native<ffi.Pointer<TRenderTarget> Function(ffi.Pointer<TView>)>(
    isLeaf: true)
external ffi.Pointer<TRenderTarget> View_getRenderTarget(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setPostProcessing(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setShadowsEnabled(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Int)>(isLeaf: true)
external void View_setShadowType(
  ffi.Pointer<TView> tView,
  int shadowType,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Float, ffi.Float)>(
    isLeaf: true)
external void View_setSoftShadowOptions(
  ffi.Pointer<TView> tView,
  double penumbraScale,
  double penumbraRatioScale,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool, ffi.Float)>(
    isLeaf: true)
external void View_setBloom(
  ffi.Pointer<TView> tView,
  bool enabled,
  double strength,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.UnsignedInt)>(
    symbol: "View_setRenderQuality", isLeaf: true)
external void _View_setRenderQuality(
  ffi.Pointer<TView> tView,
  int qualityLevel,
);

void View_setRenderQuality(
  ffi.Pointer<TView> tView,
  TQualityLevel qualityLevel,
) =>
    _View_setRenderQuality(
      tView,
      qualityLevel.value,
    );

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TEngine>,
        ffi.UnsignedInt)>(symbol: "View_setToneMapping", isLeaf: true)
external void _View_setToneMapping(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TEngine> tEngine,
  int toneMapping,
);

void View_setToneMapping(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TEngine> tEngine,
  ToneMapping toneMapping,
) =>
    _View_setToneMapping(
      tView,
      tEngine,
      toneMapping.value,
    );

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TView>, ffi.Bool, ffi.Bool, ffi.Bool)>(isLeaf: true)
external void View_setAntiAliasing(
  ffi.Pointer<TView> tView,
  bool msaa,
  bool fxaa,
  bool taa,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Int, ffi.Bool)>(
    isLeaf: true)
external void View_setLayerEnabled(
  ffi.Pointer<TView> tView,
  int layer,
  bool visible,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TCamera>)>(
    isLeaf: true)
external void View_setCamera(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TCamera> tCamera,
);

@ffi.Native<ffi.Pointer<TScene> Function(ffi.Pointer<TView>)>(isLeaf: true)
external ffi.Pointer<TScene> View_getScene(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TView>)>(isLeaf: true)
external ffi.Pointer<TCamera> View_getCamera(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setStencilBufferEnabled(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TView>)>(isLeaf: true)
external bool View_isStencilBufferEnabled(
  ffi.Pointer<TView> tView,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool)>(isLeaf: true)
external void View_setDitheringEnabled(
  ffi.Pointer<TView> tView,
  bool enabled,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TView>)>(isLeaf: true)
external bool View_isDitheringEnabled(
  ffi.Pointer<TView> tView,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TView>, ffi.Uint32, ffi.Uint32, ffi.Uint32,
        PickCallback)>(isLeaf: true)
external void View_pick(
  ffi.Pointer<TView> tView,
  int requestId,
  int x,
  int y,
  PickCallback callback,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TNameComponentManager>, EntityId)>(isLeaf: true)
external ffi.Pointer<ffi.Char> NameComponentManager_getName(
  ffi.Pointer<TNameComponentManager> tNameComponentManager,
  int entity,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TEngine>,
        ffi.Pointer<TTexture>,
        ffi.Pointer<TLinearImage>,
        ffi.UnsignedInt,
        ffi.UnsignedInt)>(symbol: "Texture_loadImage", isLeaf: true)
external bool _Texture_loadImage(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  ffi.Pointer<TLinearImage> tImage,
  int bufferFormat,
  int pixelDataType,
);

bool Texture_loadImage(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
  ffi.Pointer<TLinearImage> tImage,
  TPixelDataFormat bufferFormat,
  TPixelDataType pixelDataType,
) =>
    _Texture_loadImage(
      tEngine,
      tTexture,
      tImage,
      bufferFormat.value,
      pixelDataType.value,
    );

@ffi.Native<
    ffi.Pointer<TLinearImage> Function(
        ffi.Uint32, ffi.Uint32, ffi.Uint32)>(isLeaf: true)
external ffi.Pointer<TLinearImage> Image_createEmpty(
  int width,
  int height,
  int channel,
);

@ffi.Native<
    ffi.Pointer<TLinearImage> Function(
        ffi.Pointer<ffi.Uint8>, ffi.Size, ffi.Pointer<ffi.Char>)>(isLeaf: true)
external ffi.Pointer<TLinearImage> Image_decode(
  ffi.Pointer<ffi.Uint8> data,
  int length,
  ffi.Pointer<ffi.Char> name,
);

@ffi.Native<ffi.Pointer<ffi.Float> Function(ffi.Pointer<TLinearImage>)>(
    isLeaf: true)
external ffi.Pointer<ffi.Float> Image_getBytes(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external void Image_destroy(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external int Image_getWidth(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external int Image_getHeight(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<TLinearImage>)>(isLeaf: true)
external int Image_getChannels(
  ffi.Pointer<TLinearImage> tLinearImage,
);

@ffi.Native<ffi.Pointer<TTexture> Function(ffi.Pointer<TRenderTarget>)>(
    isLeaf: true)
external ffi.Pointer<TTexture> RenderTarget_getColorTexture(
  ffi.Pointer<TRenderTarget> tRenderTarget,
);

@ffi.Native<ffi.Pointer<TTextureSampler> Function()>(isLeaf: true)
external ffi.Pointer<TTextureSampler> TextureSampler_create();

@ffi.Native<
        ffi.Pointer<TTextureSampler> Function(ffi.UnsignedInt, ffi.UnsignedInt,
            ffi.UnsignedInt, ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "TextureSampler_createWithFiltering", isLeaf: true)
external ffi.Pointer<TTextureSampler> _TextureSampler_createWithFiltering(
  int minFilter,
  int magFilter,
  int wrapS,
  int wrapT,
  int wrapR,
);

ffi.Pointer<TTextureSampler> TextureSampler_createWithFiltering(
  TSamplerMinFilter minFilter,
  TSamplerMagFilter magFilter,
  TSamplerWrapMode wrapS,
  TSamplerWrapMode wrapT,
  TSamplerWrapMode wrapR,
) =>
    _TextureSampler_createWithFiltering(
      minFilter.value,
      magFilter.value,
      wrapS.value,
      wrapT.value,
      wrapR.value,
    );

@ffi.Native<
        ffi.Pointer<TTextureSampler> Function(
            ffi.UnsignedInt, ffi.UnsignedInt)>(
    symbol: "TextureSampler_createWithComparison", isLeaf: true)
external ffi.Pointer<TTextureSampler> _TextureSampler_createWithComparison(
  int compareMode,
  int compareFunc,
);

ffi.Pointer<TTextureSampler> TextureSampler_createWithComparison(
  TSamplerCompareMode compareMode,
  TSamplerCompareFunc compareFunc,
) =>
    _TextureSampler_createWithComparison(
      compareMode.value,
      compareFunc.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    symbol: "TextureSampler_setMinFilter", isLeaf: true)
external void _TextureSampler_setMinFilter(
  ffi.Pointer<TTextureSampler> sampler,
  int filter,
);

void TextureSampler_setMinFilter(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerMinFilter filter,
) =>
    _TextureSampler_setMinFilter(
      sampler,
      filter.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    symbol: "TextureSampler_setMagFilter", isLeaf: true)
external void _TextureSampler_setMagFilter(
  ffi.Pointer<TTextureSampler> sampler,
  int filter,
);

void TextureSampler_setMagFilter(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerMagFilter filter,
) =>
    _TextureSampler_setMagFilter(
      sampler,
      filter.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    symbol: "TextureSampler_setWrapModeS", isLeaf: true)
external void _TextureSampler_setWrapModeS(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
);

void TextureSampler_setWrapModeS(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
) =>
    _TextureSampler_setWrapModeS(
      sampler,
      mode.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    symbol: "TextureSampler_setWrapModeT", isLeaf: true)
external void _TextureSampler_setWrapModeT(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
);

void TextureSampler_setWrapModeT(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
) =>
    _TextureSampler_setWrapModeT(
      sampler,
      mode.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt)>(
    symbol: "TextureSampler_setWrapModeR", isLeaf: true)
external void _TextureSampler_setWrapModeR(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
);

void TextureSampler_setWrapModeR(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerWrapMode mode,
) =>
    _TextureSampler_setWrapModeR(
      sampler,
      mode.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.Double)>(
    isLeaf: true)
external void TextureSampler_setAnisotropy(
  ffi.Pointer<TTextureSampler> sampler,
  double anisotropy,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTextureSampler>, ffi.UnsignedInt,
        ffi.UnsignedInt)>(symbol: "TextureSampler_setCompareMode", isLeaf: true)
external void _TextureSampler_setCompareMode(
  ffi.Pointer<TTextureSampler> sampler,
  int mode,
  int func,
);

void TextureSampler_setCompareMode(
  ffi.Pointer<TTextureSampler> sampler,
  TSamplerCompareMode mode,
  TSamplerCompareFunc func,
) =>
    _TextureSampler_setCompareMode(
      sampler,
      mode.value,
      func.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TTextureSampler>)>(isLeaf: true)
external void TextureSampler_destroy(
  ffi.Pointer<TTextureSampler> sampler,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TGizmo>, ffi.Uint32, ffi.Uint32,
        GizmoPickCallback)>(isLeaf: true)
external void Gizmo_pick(
  ffi.Pointer<TGizmo> tGizmo,
  int x,
  int y,
  GizmoPickCallback callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TGizmo>, ffi.UnsignedInt)>(
    symbol: "Gizmo_highlight", isLeaf: true)
external void _Gizmo_highlight(
  ffi.Pointer<TGizmo> tGizmo,
  int axis,
);

void Gizmo_highlight(
  ffi.Pointer<TGizmo> tGizmo,
  TGizmoAxis axis,
) =>
    _Gizmo_highlight(
      tGizmo,
      axis.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TGizmo>)>(isLeaf: true)
external void Gizmo_unhighlight(
  ffi.Pointer<TGizmo> tGizmo,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(ffi.Pointer<TMaterialProvider>,
        ffi.Pointer<TMaterialKey>)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> MaterialProvider_createMaterialInstance(
  ffi.Pointer<TMaterialProvider> provider,
  ffi.Pointer<TMaterialKey> key,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void set_camera_exposure(
  ffi.Pointer<TCamera> camera,
  double aperture,
  double shutterSpeed,
  double sensitivity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, double4x4)>(isLeaf: true)
external void set_camera_model_matrix(
  ffi.Pointer<TCamera> camera,
  double4x4 matrix,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TViewer>, EntityId)>(
    isLeaf: true)
external ffi.Pointer<TCamera> get_camera(
  ffi.Pointer<TViewer> viewer,
  int entity,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_model_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_view_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_projection_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_culling_projection_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Pointer<ffi.Double> Function(ffi.Pointer<TCamera>)>(
    isLeaf: true)
external ffi.Pointer<ffi.Double> get_camera_frustum(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, double4x4, ffi.Double, ffi.Double)>(isLeaf: true)
external void set_camera_projection_matrix(
  ffi.Pointer<TCamera> camera,
  double4x4 matrix,
  double near,
  double far,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Double, ffi.Double, ffi.Double,
        ffi.Double, ffi.Bool)>(isLeaf: true)
external void set_camera_projection_from_fov(
  ffi.Pointer<TCamera> camera,
  double fovInDegrees,
  double aspect,
  double near,
  double far,
  bool horizontal,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double get_camera_focal_length(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getFocalLength(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getNear(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getCullingFar(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getViewMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getModelMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double get_camera_near(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double get_camera_culling_far(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Float Function(ffi.Pointer<TCamera>, ffi.Bool)>(isLeaf: true)
external double get_camera_fov(
  ffi.Pointer<TCamera> camera,
  bool horizontal,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, ffi.Float)>(isLeaf: true)
external void set_camera_focus_distance(
  ffi.Pointer<TCamera> camera,
  double focusDistance,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, double4x4, ffi.Double, ffi.Double)>(isLeaf: true)
external void Camera_setCustomProjectionWithCulling(
  ffi.Pointer<TCamera> camera,
  double4x4 projectionMatrix,
  double near,
  double far,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, double4x4)>(isLeaf: true)
external void Camera_setModelMatrix(
  ffi.Pointer<TCamera> camera,
  double4x4 modelMatrix,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Double, ffi.Double, ffi.Double,
        ffi.Double)>(isLeaf: true)
external void Camera_setLensProjection(
  ffi.Pointer<TCamera> camera,
  double near,
  double far,
  double aspect,
  double focalLength,
);

@ffi.Native<EntityId Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external int Camera_getEntity(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>,
        ffi.UnsignedInt,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double,
        ffi.Double)>(symbol: "Camera_setProjection", isLeaf: true)
external void _Camera_setProjection(
  ffi.Pointer<TCamera> tCamera,
  int projection,
  double left,
  double right,
  double bottom,
  double top,
  double near,
  double far,
);

void Camera_setProjection(
  ffi.Pointer<TCamera> tCamera,
  Projection projection,
  double left,
  double right,
  double bottom,
  double top,
  double near,
  double far,
) =>
    _Camera_setProjection(
      tCamera,
      projection.value,
      left,
      right,
      bottom,
      top,
      near,
      far,
    );

@ffi.Native<double4x4 Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external double4x4 TransformManager_getLocalTransform(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external double4x4 TransformManager_getWorldTransform(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TTransformManager>, EntityId, double4x4)>(isLeaf: true)
external void TransformManager_setTransform(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
  double4x4 transform,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external void TransformManager_transformToUnitCube(
  ffi.Pointer<TTransformManager> tTransformManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TTransformManager>, EntityId, EntityId,
        ffi.Bool)>(isLeaf: true)
external void TransformManager_setParent(
  ffi.Pointer<TTransformManager> tTransformManager,
  int child,
  int parent,
  bool preserveScaling,
);

@ffi.Native<EntityId Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external int TransformManager_getParent(
  ffi.Pointer<TTransformManager> tTransformManager,
  int child,
);

@ffi.Native<EntityId Function(ffi.Pointer<TTransformManager>, EntityId)>(
    isLeaf: true)
external int TransformManager_getAncestor(
  ffi.Pointer<TTransformManager> tTransformManager,
  int childEntityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> renderCallbackOwner)>>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TViewer> viewer)>>)>(isLeaf: true)
external void Viewer_createOnRenderThread(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<ffi.Void> platform,
  ffi.Pointer<ffi.Char> uberArchivePath,
  ffi.Pointer<ffi.Void> loader,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> renderCallbackOwner)>>
      renderCallback,
  ffi.Pointer<ffi.Void> renderCallbackOwner,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TViewer> viewer)>>
      callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void Viewer_destroyOnRenderThread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TViewer>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>)>(
    isLeaf: true)
external void Viewer_createSwapChainRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Void> surface,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>
      onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TViewer>,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>)>(
    isLeaf: true)
external void Viewer_createHeadlessSwapChainRenderThread(
  ffi.Pointer<TViewer> viewer,
  int width,
  int height,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSwapChain>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TSwapChain>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_destroySwapChainRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TView>,
        ffi.Pointer<TSwapChain>)>(isLeaf: true)
external void Viewer_renderRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> view,
  ffi.Pointer<TSwapChain> swapChain,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TSwapChain>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_captureRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> view,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Pointer<TView>,
        ffi.Pointer<TSwapChain>,
        ffi.Pointer<TRenderTarget>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_captureRenderTargetRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TView> view,
  ffi.Pointer<TSwapChain> swapChain,
  ffi.Pointer<TRenderTarget> renderTarget,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_requestFrameRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Float,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_loadIblRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> iblPath,
  double intensity,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_removeIblRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.IntPtr,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TRenderTarget>)>>)>(isLeaf: true)
external void Viewer_createRenderTargetRenderThread(
  ffi.Pointer<TViewer> viewer,
  int texture,
  int width,
  int height,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TRenderTarget>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<TRenderTarget>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_destroyRenderTargetRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<TRenderTarget> tRenderTarget,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_loadSkyboxRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> skyboxPath,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Viewer_removeSkyboxRenderThread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>)>(
    isLeaf: true)
external void Engine_buildMaterialRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> materialData,
  int length,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterial>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TMaterial>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void Engine_destroyMaterialRenderThread(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterial> tMaterial,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TEngine>,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint8,
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>)>(
    symbol: "Engine_buildTextureRenderThread", isLeaf: true)
external void _Engine_buildTextureRenderThread(
  ffi.Pointer<TEngine> engine,
  int width,
  int height,
  int levels,
  int sampler,
  int format,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>
      onComplete,
);

void Engine_buildTextureRenderThread(
  ffi.Pointer<TEngine> engine,
  int width,
  int height,
  int levels,
  TTextureSamplerType sampler,
  TTextureFormat format,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TTexture>)>>
      onComplete,
) =>
    _Engine_buildTextureRenderThread(
      engine,
      width,
      height,
      levels,
      sampler.value,
      format.value,
      onComplete,
    );

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TMaterial>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TMaterialInstance>)>>)>(isLeaf: true)
external void Material_createInstanceRenderThread(
  ffi.Pointer<TMaterial> tMaterial,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterialInstance>)>>
      onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TView>, ffi.Pointer<TEngine>, ffi.Int)>(isLeaf: true)
external void View_setToneMappingRenderThread(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TEngine> tEngine,
  int thermion,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TView>, ffi.Bool, ffi.Double)>(
    isLeaf: true)
external void View_setBloomRenderThread(
  ffi.Pointer<TView> tView,
  bool enabled,
  double strength,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TView>, ffi.Pointer<TCamera>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void View_setCameraRenderThread(
  ffi.Pointer<TView> tView,
  ffi.Pointer<TCamera> tCamera,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<FilamentRenderCallback Function(FilamentRenderCallback)>(
    isLeaf: true)
external FilamentRenderCallback make_render_callback_fn_pointer(
  FilamentRenderCallback arg0,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Bool,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void set_rendering_render_thread(
  ffi.Pointer<TViewer> viewer,
  bool rendering,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float)>(isLeaf: true)
external void set_frame_interval_render_thread(
  ffi.Pointer<TViewer> viewer,
  double frameInterval,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void set_background_color_render_thread(
  ffi.Pointer<TViewer> viewer,
  double r,
  double g,
  double b,
  double a,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_background_image_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Bool,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void set_background_image_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> path,
  bool fillHeight,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Bool)>(isLeaf: true)
external void set_background_image_position_render_thread(
  ffi.Pointer<TViewer> viewer,
  double x,
  double y,
  bool clamp,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<TMaterial>,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneManager_createGridRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<TMaterial> tMaterial,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
        ffi.Pointer<TGizmo> Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<TView>,
            ffi.Pointer<TScene>,
            ffi.UnsignedInt,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TGizmo>)>>)>(
    symbol: "SceneManager_createGizmoRenderThread", isLeaf: true)
external ffi.Pointer<TGizmo> _SceneManager_createGizmoRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TScene> tScene,
  int tGizmoType,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TGizmo>)>>
      onComplete,
);

ffi.Pointer<TGizmo> SceneManager_createGizmoRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TScene> tScene,
  TGizmoType tGizmoType,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TGizmo>)>>
      onComplete,
) =>
    _SceneManager_createGizmoRenderThread(
      tSceneManager,
      tView,
      tScene,
      tGizmoType.value,
      onComplete,
    );

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.Uint16>,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<TMaterialInstance>>,
            ffi.Int,
            ffi.Bool,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneManager_createGeometryRenderThread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Float> vertices,
  int numVertices,
  ffi.Pointer<ffi.Float> normals,
  int numNormals,
  ffi.Pointer<ffi.Float> uvs,
  int numUvs,
  ffi.Pointer<ffi.Uint16> indices,
  int numIndices,
  int primitiveType,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
  bool keepData,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Int,
            ffi.Bool,
            ffi.Int,
            ffi.Int,
            ffi.Bool,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneManager_loadGlbFromBufferRenderThread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  int numInstances,
  bool keepData,
  int priority,
  int layer,
  bool loadResourcesAsync,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TMaterialInstance>)>>)>(isLeaf: true)
external void SceneManager_createUnlitMaterialInstanceRenderThread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterialInstance>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TMaterialInstance>)>>)>(isLeaf: true)
external void SceneManager_createUnlitFixedSizeMaterialInstanceRenderThread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterialInstance>)>>
      callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Char>,
            ffi.Int,
            ffi.Bool,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneManager_loadGlbRenderThread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  int numInstances,
  bool keepData,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Bool,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneManager_loadGltfRenderThread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  ffi.Pointer<ffi.Char> relativePath,
  bool keepData,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void SceneManager_destroyAllRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void SceneManager_destroyAssetRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void SceneManager_destroyAssetsRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void SceneManager_destroyLightsRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Uint8,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Bool,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void SceneManager_addLightRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  int type,
  double colour,
  double intensity,
  double posX,
  double posY,
  double posZ,
  double dirX,
  double dirY,
  double dirZ,
  double falloffRadius,
  double spotLightConeInner,
  double spotLightConeOuter,
  double sunAngularRadius,
  double sunHaloSize,
  double sunHaloFallof,
  bool shadows,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void SceneManager_removeLightRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  int entityId,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TCamera>)>>)>(
    isLeaf: true)
external void SceneManager_createCameraRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TCamera>)>>
      callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneAsset>,
            ffi.Pointer<ffi.Pointer<TMaterialInstance>>,
            ffi.Int,
            ffi.Pointer<
                ffi
                .NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>)>(
    isLeaf: true)
external void SceneAsset_createInstanceRenderThread(
  ffi.Pointer<TSceneAsset> asset,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> tMaterialInstances,
  int materialInstanceCount,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSceneAsset>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TMaterialProvider>,
        ffi.Pointer<TMaterialKey>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<TMaterialInstance>)>>)>(isLeaf: true)
external void MaterialProvider_createMaterialInstanceRenderThread(
  ffi.Pointer<TMaterialProvider> tMaterialProvider,
  ffi.Pointer<TMaterialKey> tKey,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TMaterialInstance>)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<TMaterialInstance>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void SceneManager_destroyMaterialInstanceRenderThread(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TAnimationManager>,
            ffi.Pointer<TSceneAsset>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void AnimationManager_updateBoneMatricesRenderThread(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TAnimationManager>,
            EntityId,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void AnimationManager_setMorphTargetWeightsRenderThread(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  ffi.Pointer<ffi.Float> morphData,
  int numWeights,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void update_bone_matrices_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            EntityId,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void set_bone_transform_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> transform,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Bool)>(isLeaf: true)
external void set_post_processing_render_thread(
  ffi.Pointer<TViewer> viewer,
  bool enabled,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void reset_to_rest_pose_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Pointer<TGizmo> Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<TView>,
        ffi.Pointer<TScene>,
        ffi.UnsignedInt)>(symbol: "SceneManager_createGizmo", isLeaf: true)
external ffi.Pointer<TGizmo> _SceneManager_createGizmo(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TScene> tScene,
  int tGizmoType,
);

ffi.Pointer<TGizmo> SceneManager_createGizmo(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<TView> tView,
  ffi.Pointer<TScene> tScene,
  TGizmoType tGizmoType,
) =>
    _SceneManager_createGizmo(
      tSceneManager,
      tView,
      tScene,
      tGizmoType.value,
    );

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.Uint16>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<ffi.Pointer<TMaterialInstance>>,
        ffi.Int,
        ffi.Bool)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneManager_createGeometry(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Float> vertices,
  int numVertices,
  ffi.Pointer<ffi.Float> normals,
  int numNormals,
  ffi.Pointer<ffi.Float> uvs,
  int numUvs,
  ffi.Pointer<ffi.Uint16> indices,
  int numIndices,
  int primitiveType,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
  bool keepData,
);

@ffi.Native<
    ffi.Pointer<TMaterialProvider> Function(
        ffi.Pointer<TSceneManager>)>(isLeaf: true)
external ffi.Pointer<TMaterialProvider>
    SceneManager_getUbershaderMaterialProvider(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Pointer<TMaterialProvider> Function(
        ffi.Pointer<TSceneManager>)>(isLeaf: true)
external ffi.Pointer<TMaterialProvider> SceneManager_getUnlitMaterialProvider(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TSceneManager>)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance>
    SceneManager_createUnlitMaterialInstance(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TSceneManager>)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance>
    SceneManager_createUnlitFixedSizeMaterialInstance(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, ffi.Pointer<EntityId>,
        ffi.Pointer<ffi.Double>, ffi.Int)>(isLeaf: true)
external void SceneManager_queueTransformUpdates(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<EntityId> entities,
  ffi.Pointer<ffi.Double> transforms,
  int numEntities,
);

@ffi.Native<
    ffi.Pointer<TCamera> Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>)>(isLeaf: true)
external ffi.Pointer<TCamera> SceneManager_findCameraByName(
  ffi.Pointer<TSceneManager> tSceneManager,
  int entity,
  ffi.Pointer<ffi.Char> name,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external void SceneManager_setVisibilityLayer(
  ffi.Pointer<TSceneManager> tSceneManager,
  int entity,
  int layer,
);

@ffi.Native<ffi.Pointer<TScene> Function(ffi.Pointer<TSceneManager>)>(
    isLeaf: true)
external ffi.Pointer<TScene> SceneManager_getScene(
  ffi.Pointer<TSceneManager> tSceneManager,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TSceneManager>)>(
    isLeaf: true)
external ffi.Pointer<TCamera> SceneManager_createCamera(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<TCamera>)>(isLeaf: true)
external void SceneManager_destroyCamera(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneManager>)>(isLeaf: true)
external int SceneManager_getCameraCount(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Pointer<TCamera> Function(
        ffi.Pointer<TSceneManager>, ffi.Size)>(isLeaf: true)
external ffi.Pointer<TCamera> SceneManager_getCameraAt(
  ffi.Pointer<TSceneManager> sceneManager,
  int index,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>,
        ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external void SceneManager_destroyMaterialInstance(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TMaterialInstance> instance,
);

@ffi.Native<Aabb3 Function(ffi.Pointer<TSceneManager>, EntityId)>(isLeaf: true)
external Aabb3 SceneManager_getRenderableBoundingBox(
  ffi.Pointer<TSceneManager> tSceneManager,
  int entity,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int SceneManager_addToScene(
  ffi.Pointer<TSceneManager> tSceneManager,
  int entity,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int SceneManager_removeFromScene(
  ffi.Pointer<TSceneManager> tSceneManager,
  int entity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void SceneManager_transformToUnitCube(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Int,
        ffi.Bool,
        ffi.Int,
        ffi.Int,
        ffi.Bool)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneManager_loadGlbFromBuffer(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<ffi.Uint8> arg1,
  int length,
  int numInstances,
  bool keepData,
  int priority,
  int layer,
  bool loadResourcesAsync,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.Char>, ffi.Int, ffi.Bool)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneManager_loadGlb(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  int numInstances,
  bool keepData,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Bool)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneManager_loadGltf(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  ffi.Pointer<ffi.Char> relativePath,
  bool keepData,
);

@ffi.Native<
    EntityId Function(
        ffi.Pointer<TSceneManager>,
        ffi.Uint8,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Bool)>(isLeaf: true)
external int SceneManager_addLight(
  ffi.Pointer<TSceneManager> tSceneManager,
  int type,
  double colour,
  double intensity,
  double posX,
  double posY,
  double posZ,
  double dirX,
  double dirY,
  double dirZ,
  double falloffRadius,
  double spotLightConeInner,
  double spotLightConeOuter,
  double sunAngularRadius,
  double sunHaloSize,
  double sunHaloFallof,
  bool shadows,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void SceneManager_removeLight(
  ffi.Pointer<TSceneManager> tSceneManager,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>)>(isLeaf: true)
external void SceneManager_destroyLights(
  ffi.Pointer<TSceneManager> tSceneManager,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external void SceneManager_destroyAsset(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>)>(isLeaf: true)
external void SceneManager_destroyAssets(
  ffi.Pointer<TSceneManager> tSceneManager,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>)>(isLeaf: true)
external void SceneManager_destroyAll(
  ffi.Pointer<TSceneManager> tSceneManager,
);

@ffi.Native<
    ffi.Pointer<TAnimationManager> Function(
        ffi.Pointer<TSceneManager>)>(isLeaf: true)
external ffi.Pointer<TAnimationManager> SceneManager_getAnimationManager(
  ffi.Pointer<TSceneManager> tSceneManager,
);

@ffi.Native<
    ffi.Pointer<TNameComponentManager> Function(
        ffi.Pointer<TSceneManager>)>(isLeaf: true)
external ffi.Pointer<TNameComponentManager>
    SceneManager_getNameComponentManager(
  ffi.Pointer<TSceneManager> tSceneManager,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<TMaterial>)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneManager_createGrid(
  ffi.Pointer<TSceneManager> tSceneManager,
  ffi.Pointer<TMaterial> tMaterial,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external bool SceneManager_isGridEntity(
  ffi.Pointer<TSceneManager> tSceneManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TRenderableManager>, EntityId, ffi.Int,
        ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external void RenderableManager_setMaterialInstanceAt(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int primitiveIndex,
  ffi.Pointer<TMaterialInstance> tMaterialInstance,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Int)>(isLeaf: true)
external void RenderableManager_setPriority(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int priority,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TRenderableManager>, EntityId, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> RenderableManager_getMaterialInstanceAt(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int primitiveIndex,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_isRenderable(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

/// Checks if the given entity has a renderable component
@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_hasComponent(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

/// Returns true if this manager has no components
@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>)>(isLeaf: true)
external bool RenderableManager_empty(
  ffi.Pointer<TRenderableManager> tRenderableManager,
);

/// Returns whether a light channel is enabled on a specified renderable
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId,
        ffi.UnsignedInt)>(isLeaf: true)
external bool RenderableManager_getLightChannel(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
  int channel,
);

/// Checks if the renderable can cast shadows
@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_isShadowCaster(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

/// Checks if the renderable can receive shadows
@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_isShadowReceiver(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

/// Returns whether large-scale fog is enabled for this renderable
@ffi.Native<ffi.Bool Function(ffi.Pointer<TRenderableManager>, EntityId)>(
    isLeaf: true)
external bool RenderableManager_getFogEnabled(
  ffi.Pointer<TRenderableManager> tRenderableManager,
  int entityId,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TEngine>, EntityId)>(
    isLeaf: true)
external ffi.Pointer<TCamera> Engine_getCameraComponent(
  ffi.Pointer<TEngine> tEngine,
  int entityId,
);

@ffi.Native<ffi.Pointer<TTransformManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TTransformManager> Engine_getTransformManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TRenderableManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TRenderableManager> Engine_getRenderableManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TLightManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TLightManager> Engine_getLightManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TEntityManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TEntityManager> Engine_getEntityManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<
    ffi.Pointer<TTexture> Function(
        ffi.Pointer<TEngine>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Uint8,
        ffi.UnsignedInt,
        ffi.UnsignedInt)>(symbol: "Engine_buildTexture", isLeaf: true)
external ffi.Pointer<TTexture> _Engine_buildTexture(
  ffi.Pointer<TEngine> engine,
  int width,
  int height,
  int levels,
  int sampler,
  int format,
);

ffi.Pointer<TTexture> Engine_buildTexture(
  ffi.Pointer<TEngine> engine,
  int width,
  int height,
  int levels,
  TTextureSamplerType sampler,
  TTextureFormat format,
) =>
    _Engine_buildTexture(
      engine,
      width,
      height,
      levels,
      sampler.value,
      format.value,
    );

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TTexture>)>(
    isLeaf: true)
external void Engine_destroyTexture(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TTexture> tTexture,
);

@ffi.Native<
    ffi.Pointer<TMaterial> Function(
        ffi.Pointer<TEngine>, ffi.Pointer<ffi.Uint8>, ffi.Size)>(isLeaf: true)
external ffi.Pointer<TMaterial> Engine_buildMaterial(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<ffi.Uint8> materialData,
  int length,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, ffi.Pointer<TMaterial>)>(
    isLeaf: true)
external void Engine_destroyMaterial(
  ffi.Pointer<TEngine> tEngine,
  ffi.Pointer<TMaterial> tMaterial,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>, ffi.Pointer<TScene>)>(
    isLeaf: true)
external void SceneAsset_addToScene(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  ffi.Pointer<TScene> tScene,
);

@ffi.Native<EntityId Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getEntity(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getChildEntityCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneAsset>, ffi.Pointer<EntityId>)>(
    isLeaf: true)
external void SceneAsset_getChildEntities(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  ffi.Pointer<EntityId> out,
);

@ffi.Native<ffi.Int>()
external final int utils;

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getCameraEntityCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getLightEntityCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(
        ffi.Pointer<TSceneAsset>, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_getInstance(
  ffi.Pointer<TSceneAsset> tSceneAsset,
  int index,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int SceneAsset_getInstanceCount(
  ffi.Pointer<TSceneAsset> tSceneAsset,
);

@ffi.Native<
    ffi.Pointer<TSceneAsset> Function(ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.Pointer<TMaterialInstance>>, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TSceneAsset> SceneAsset_createInstance(
  ffi.Pointer<TSceneAsset> asset,
  ffi.Pointer<ffi.Pointer<TMaterialInstance>> materialInstances,
  int materialInstanceCount,
);

@ffi.Native<Aabb3 Function(ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external Aabb3 SceneAsset_getBoundingBox(
  ffi.Pointer<TSceneAsset> asset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TAnimationManager>, EntityId)>(
    isLeaf: true)
external void AnimationManager_addAnimationComponent(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TAnimationManager>, EntityId)>(
    isLeaf: true)
external void AnimationManager_removeAnimationComponent(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>,
        EntityId,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Uint32>,
        ffi.Int,
        ffi.Int,
        ffi.Float)>(isLeaf: true)
external bool AnimationManager_setMorphAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  ffi.Pointer<ffi.Float> morphData,
  ffi.Pointer<ffi.Uint32> morphIndices,
  int numMorphTargets,
  int numFrames,
  double frameLengthInMs,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TAnimationManager>, EntityId)>(
    isLeaf: true)
external bool AnimationManager_clearMorphAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external void AnimationManager_resetToRestPose(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TAnimationManager>,
        ffi.Pointer<TSceneAsset>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float)>(isLeaf: true)
external void AnimationManager_addBoneAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> frameData,
  int numFrames,
  double frameLengthInMs,
  double fadeOutInSecs,
  double fadeInInSecs,
  double maxDelta,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Int)>(isLeaf: true)
external int AnimationManager_getBone(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  int boneIndex,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getRestLocalTransforms(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  ffi.Pointer<ffi.Float> out,
  int numBones,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Int, ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void AnimationManager_getInverseBindMatrix(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> out,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TAnimationManager>,
        ffi.Pointer<TSceneAsset>,
        ffi.Int,
        ffi.Bool,
        ffi.Bool,
        ffi.Bool,
        ffi.Float,
        ffi.Float)>(isLeaf: true)
external void AnimationManager_playAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int index,
  bool loop,
  bool reverse,
  bool replaceActive,
  double crossfade,
  double startOffset,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int)>(isLeaf: true)
external void AnimationManager_stopAnimation(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int index,
);

@ffi.Native<
    ffi.Float Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int)>(isLeaf: true)
external double AnimationManager_getAnimationDuration(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int animationIndex,
);

@ffi.Native<
    ffi.Int Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external int AnimationManager_getAnimationCount(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getAnimationName(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int)>(isLeaf: true)
external int AnimationManager_getBoneCount(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int skinIndex,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getBoneNames(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  ffi.Pointer<ffi.Pointer<ffi.Char>> out,
  int skinIndex,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        EntityId)>(isLeaf: true)
external int AnimationManager_getMorphTargetNameCount(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int childEntity,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        EntityId, ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void AnimationManager_getMorphTargetName(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
  int childEntity,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>)>(isLeaf: true)
external bool AnimationManager_updateBoneMatrices(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> sceneAsset,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TAnimationManager>, EntityId,
        ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external bool AnimationManager_setMorphTargetWeights(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  int entityId,
  ffi.Pointer<ffi.Float> morphData,
  int numWeights,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TAnimationManager>, ffi.Pointer<TSceneAsset>,
        ffi.Int, ffi.Int)>(isLeaf: true)
external void AnimationManager_setGltfAnimationFrame(
  ffi.Pointer<TAnimationManager> tAnimationManager,
  ffi.Pointer<TSceneAsset> tSceneAsset,
  int animationIndex,
  int frame,
);

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(LoadFilamentResourceFromOwner,
        FreeFilamentResourceFromOwner, ffi.Pointer<ffi.Void>)>(isLeaf: true)
external ffi.Pointer<ffi.Void> make_resource_loader(
  LoadFilamentResourceFromOwner loadFn,
  FreeFilamentResourceFromOwner freeFn,
  ffi.Pointer<ffi.Void> owner,
);

final class TCamera extends ffi.Opaque {}

final class TEngine extends ffi.Opaque {}

final class TEntityManager extends ffi.Opaque {}

final class TViewer extends ffi.Opaque {}

final class TSceneManager extends ffi.Opaque {}

final class TLightManager extends ffi.Opaque {}

final class TRenderTarget extends ffi.Opaque {}

final class TSwapChain extends ffi.Opaque {}

final class TView extends ffi.Opaque {}

final class TGizmo extends ffi.Opaque {}

final class TScene extends ffi.Opaque {}

final class TTransformManager extends ffi.Opaque {}

final class TAnimationManager extends ffi.Opaque {}

final class TCollisionComponentManager extends ffi.Opaque {}

final class TSceneAsset extends ffi.Opaque {}

final class TNameComponentManager extends ffi.Opaque {}

final class TMaterial extends ffi.Opaque {}

final class TMaterialInstance extends ffi.Opaque {}

final class TMaterialProvider extends ffi.Opaque {}

final class TRenderableManager extends ffi.Opaque {}

final class TRenderableInstance extends ffi.Opaque {}

final class TTexture extends ffi.Opaque {}

final class TTextureSampler extends ffi.Opaque {}

final class TLinearImage extends ffi.Opaque {}

final class TMaterialKey extends ffi.Struct {
  @ffi.Bool()
  external bool doubleSided;

  @ffi.Bool()
  external bool unlit;

  @ffi.Bool()
  external bool hasVertexColors;

  @ffi.Bool()
  external bool hasBaseColorTexture;

  @ffi.Bool()
  external bool hasNormalTexture;

  @ffi.Bool()
  external bool hasOcclusionTexture;

  @ffi.Bool()
  external bool hasEmissiveTexture;

  @ffi.Bool()
  external bool useSpecularGlossiness;

  @ffi.Int()
  external int alphaMode;

  @ffi.Bool()
  external bool enableDiagnostics;

  external UnnamedUnion1 unnamed;

  @ffi.Uint8()
  external int baseColorUV;

  @ffi.Bool()
  external bool hasClearCoatTexture;

  @ffi.Uint8()
  external int clearCoatUV;

  @ffi.Bool()
  external bool hasClearCoatRoughnessTexture;

  @ffi.Uint8()
  external int clearCoatRoughnessUV;

  @ffi.Bool()
  external bool hasClearCoatNormalTexture;

  @ffi.Uint8()
  external int clearCoatNormalUV;

  @ffi.Bool()
  external bool hasClearCoat;

  @ffi.Bool()
  external bool hasTransmission;

  @ffi.Bool()
  external bool hasTextureTransforms;

  @ffi.Uint8()
  external int emissiveUV;

  @ffi.Uint8()
  external int aoUV;

  @ffi.Uint8()
  external int normalUV;

  @ffi.Bool()
  external bool hasTransmissionTexture;

  @ffi.Uint8()
  external int transmissionUV;

  @ffi.Bool()
  external bool hasSheenColorTexture;

  @ffi.Uint8()
  external int sheenColorUV;

  @ffi.Bool()
  external bool hasSheenRoughnessTexture;

  @ffi.Uint8()
  external int sheenRoughnessUV;

  @ffi.Bool()
  external bool hasVolumeThicknessTexture;

  @ffi.Uint8()
  external int volumeThicknessUV;

  @ffi.Bool()
  external bool hasSheen;

  @ffi.Bool()
  external bool hasIOR;

  @ffi.Bool()
  external bool hasVolume;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 unnamed;

  external UnnamedStruct2 unnamed1;
}

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.Bool()
  external bool hasMetallicRoughnessTexture;

  @ffi.Uint8()
  external int metallicRoughnessUV;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.Bool()
  external bool hasSpecularGlossinessTexture;

  @ffi.Uint8()
  external int specularGlossinessUV;
}

final class double4 extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;

  @ffi.Double()
  external double z;

  @ffi.Double()
  external double w;
}

final class double4x4 extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col1;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col2;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col3;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col4;
}

final class Aabb2 extends ffi.Struct {
  @ffi.Float()
  external double minX;

  @ffi.Float()
  external double minY;

  @ffi.Float()
  external double maxX;

  @ffi.Float()
  external double maxY;
}

final class Aabb3 extends ffi.Struct {
  @ffi.Float()
  external double centerX;

  @ffi.Float()
  external double centerY;

  @ffi.Float()
  external double centerZ;

  @ffi.Float()
  external double halfExtentX;

  @ffi.Float()
  external double halfExtentY;

  @ffi.Float()
  external double halfExtentZ;
}

enum TGizmoType {
  TRANSLATION(0),
  ROTATION(1);

  final int value;
  const TGizmoType(this.value);

  static TGizmoType fromValue(int value) => switch (value) {
        0 => TRANSLATION,
        1 => ROTATION,
        _ => throw ArgumentError("Unknown value for TGizmoType: $value"),
      };
}

enum TSamplerCompareFunc {
  /// !< Less or equal
  LE(0),

  /// !< Greater or equal
  GE(1),

  /// !< Strictly less than
  L(2),

  /// !< Strictly greater than
  G(3),

  /// !< Equal
  E(4),

  /// !< Not equal
  NE(5),

  /// !< Always. Depth / stencil testing is deactivated.
  A(6),

  /// !< Never. The depth / stencil test always fails.
  N(7);

  final int value;
  const TSamplerCompareFunc(this.value);

  static TSamplerCompareFunc fromValue(int value) => switch (value) {
        0 => LE,
        1 => GE,
        2 => L,
        3 => G,
        4 => E,
        5 => NE,
        6 => A,
        7 => N,
        _ =>
          throw ArgumentError("Unknown value for TSamplerCompareFunc: $value"),
      };
}

enum TStencilOperation {
  KEEP(0),
  ZERO(1),
  REPLACE(2),
  INCR(3),
  INCR_WRAP(4),
  DECR(5),
  DECR_WRAP(6),
  INVERT(7);

  final int value;
  const TStencilOperation(this.value);

  static TStencilOperation fromValue(int value) => switch (value) {
        0 => KEEP,
        1 => ZERO,
        2 => REPLACE,
        3 => INCR,
        4 => INCR_WRAP,
        5 => DECR,
        6 => DECR_WRAP,
        7 => INVERT,
        _ => throw ArgumentError("Unknown value for TStencilOperation: $value"),
      };
}

enum TStencilFace {
  STENCIL_FACE_FRONT(1),
  STENCIL_FACE_BACK(2),
  STENCIL_FACE_FRONT_AND_BACK(3);

  final int value;
  const TStencilFace(this.value);

  static TStencilFace fromValue(int value) => switch (value) {
        1 => STENCIL_FACE_FRONT,
        2 => STENCIL_FACE_BACK,
        3 => STENCIL_FACE_FRONT_AND_BACK,
        _ => throw ArgumentError("Unknown value for TStencilFace: $value"),
      };
}

enum TCullingMode {
  CULLING_MODE_NONE(0),
  CULLING_MODE_FRONT(1),
  CULLING_MODE_BACK(2),
  CULLING_MODE_FRONT_AND_BACK(3);

  final int value;
  const TCullingMode(this.value);

  static TCullingMode fromValue(int value) => switch (value) {
        0 => CULLING_MODE_NONE,
        1 => CULLING_MODE_FRONT,
        2 => CULLING_MODE_BACK,
        3 => CULLING_MODE_FRONT_AND_BACK,
        _ => throw ArgumentError("Unknown value for TCullingMode: $value"),
      };
}

enum TTransparencyMode {
  /// ! the transparent object is drawn honoring the raster state
  DEFAULT(0),

  /// the transparent object is first drawn in the depth buffer,
  /// then in the color buffer, honoring the culling mode, but ignoring the depth test function
  TWO_PASSES_ONE_SIDE(1),

  /// the transparent object is drawn twice in the color buffer,
  /// first with back faces only, then with front faces; the culling
  /// mode is ignored. Can be combined with two-sided lighting
  TWO_PASSES_TWO_SIDES(2);

  final int value;
  const TTransparencyMode(this.value);

  static TTransparencyMode fromValue(int value) => switch (value) {
        0 => DEFAULT,
        1 => TWO_PASSES_ONE_SIDE,
        2 => TWO_PASSES_TWO_SIDES,
        _ => throw ArgumentError("Unknown value for TTransparencyMode: $value"),
      };
}

typedef EntityId = ffi.Int32;
typedef DartEntityId = int;

final class TViewport extends ffi.Struct {
  @ffi.Int32()
  external int left;

  @ffi.Int32()
  external int bottom;

  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;
}

enum ToneMapping {
  ACES(0),
  FILMIC(1),
  LINEAR(2);

  final int value;
  const ToneMapping(this.value);

  static ToneMapping fromValue(int value) => switch (value) {
        0 => ACES,
        1 => FILMIC,
        2 => LINEAR,
        _ => throw ArgumentError("Unknown value for ToneMapping: $value"),
      };
}

enum TQualityLevel {
  LOW(0),
  MEDIUM(1),
  HIGH(2),
  ULTRA(3);

  final int value;
  const TQualityLevel(this.value);

  static TQualityLevel fromValue(int value) => switch (value) {
        0 => LOW,
        1 => MEDIUM,
        2 => HIGH,
        3 => ULTRA,
        _ => throw ArgumentError("Unknown value for TQualityLevel: $value"),
      };
}

typedef PickCallback = ffi.Pointer<ffi.NativeFunction<PickCallbackFunction>>;
typedef PickCallbackFunction = ffi.Void Function(
    ffi.Uint32 requestId,
    EntityId entityId,
    ffi.Float depth,
    ffi.Float fragX,
    ffi.Float fragY,
    ffi.Float fragZ);
typedef DartPickCallbackFunction = void Function(
    int requestId,
    DartEntityId entityId,
    double depth,
    double fragX,
    double fragY,
    double fragZ);

enum TTextureSamplerType {
  SAMPLER_2D(0),
  SAMPLER_CUBEMAP(1),
  SAMPLER_EXTERNAL(2),
  SAMPLER_3D(3),
  SAMPLER_2D_ARRAY(4);

  final int value;
  const TTextureSamplerType(this.value);

  static TTextureSamplerType fromValue(int value) => switch (value) {
        0 => SAMPLER_2D,
        1 => SAMPLER_CUBEMAP,
        2 => SAMPLER_EXTERNAL,
        3 => SAMPLER_3D,
        4 => SAMPLER_2D_ARRAY,
        _ =>
          throw ArgumentError("Unknown value for TTextureSamplerType: $value"),
      };
}

enum TTextureFormat {
  TEXTUREFORMAT_R8(0),
  TEXTUREFORMAT_R8_SNORM(1),
  TEXTUREFORMAT_R8UI(2),
  TEXTUREFORMAT_R8I(3),
  TEXTUREFORMAT_STENCIL8(4),
  TEXTUREFORMAT_R16F(5),
  TEXTUREFORMAT_R16UI(6),
  TEXTUREFORMAT_R16I(7),
  TEXTUREFORMAT_RG8(8),
  TEXTUREFORMAT_RG8_SNORM(9),
  TEXTUREFORMAT_RG8UI(10),
  TEXTUREFORMAT_RG8I(11),
  TEXTUREFORMAT_RGB565(12),
  TEXTUREFORMAT_RGB9_E5(13),
  TEXTUREFORMAT_RGB5_A1(14),
  TEXTUREFORMAT_RGBA4(15),
  TEXTUREFORMAT_DEPTH16(16),
  TEXTUREFORMAT_RGB8(17),
  TEXTUREFORMAT_SRGB8(18),
  TEXTUREFORMAT_RGB8_SNORM(19),
  TEXTUREFORMAT_RGB8UI(20),
  TEXTUREFORMAT_RGB8I(21),
  TEXTUREFORMAT_DEPTH24(22),
  TEXTUREFORMAT_R32F(23),
  TEXTUREFORMAT_R32UI(24),
  TEXTUREFORMAT_R32I(25),
  TEXTUREFORMAT_RG16F(26),
  TEXTUREFORMAT_RG16UI(27),
  TEXTUREFORMAT_RG16I(28),
  TEXTUREFORMAT_R11F_G11F_B10F(29),
  TEXTUREFORMAT_RGBA8(30),
  TEXTUREFORMAT_SRGB8_A8(31),
  TEXTUREFORMAT_RGBA8_SNORM(32),
  TEXTUREFORMAT_UNUSED(33),
  TEXTUREFORMAT_RGB10_A2(34),
  TEXTUREFORMAT_RGBA8UI(35),
  TEXTUREFORMAT_RGBA8I(36),
  TEXTUREFORMAT_DEPTH32F(37),
  TEXTUREFORMAT_DEPTH24_STENCIL8(38),
  TEXTUREFORMAT_DEPTH32F_STENCIL8(39),
  TEXTUREFORMAT_RGB16F(40),
  TEXTUREFORMAT_RGB16UI(41),
  TEXTUREFORMAT_RGB16I(42),
  TEXTUREFORMAT_RG32F(43),
  TEXTUREFORMAT_RG32UI(44),
  TEXTUREFORMAT_RG32I(45),
  TEXTUREFORMAT_RGBA16F(46),
  TEXTUREFORMAT_RGBA16UI(47),
  TEXTUREFORMAT_RGBA16I(48),
  TEXTUREFORMAT_RGB32F(49),
  TEXTUREFORMAT_RGB32UI(50),
  TEXTUREFORMAT_RGB32I(51),
  TEXTUREFORMAT_RGBA32F(52),
  TEXTUREFORMAT_RGBA32UI(53),
  TEXTUREFORMAT_RGBA32I(54),
  TEXTUREFORMAT_EAC_R11(55),
  TEXTUREFORMAT_EAC_R11_SIGNED(56),
  TEXTUREFORMAT_EAC_RG11(57),
  TEXTUREFORMAT_EAC_RG11_SIGNED(58),
  TEXTUREFORMAT_ETC2_RGB8(59),
  TEXTUREFORMAT_ETC2_SRGB8(60),
  TEXTUREFORMAT_ETC2_RGB8_A1(61),
  TEXTUREFORMAT_ETC2_SRGB8_A1(62),
  TEXTUREFORMAT_ETC2_EAC_RGBA8(63),
  TEXTUREFORMAT_ETC2_EAC_SRGBA8(64),
  TEXTUREFORMAT_DXT1_RGB(65),
  TEXTUREFORMAT_DXT1_RGBA(66),
  TEXTUREFORMAT_DXT3_RGBA(67),
  TEXTUREFORMAT_DXT5_RGBA(68),
  TEXTUREFORMAT_DXT1_SRGB(69),
  TEXTUREFORMAT_DXT1_SRGBA(70),
  TEXTUREFORMAT_DXT3_SRGBA(71),
  TEXTUREFORMAT_DXT5_SRGBA(72),
  TEXTUREFORMAT_RGBA_ASTC_4x4(73),
  TEXTUREFORMAT_RGBA_ASTC_5x4(74),
  TEXTUREFORMAT_RGBA_ASTC_5x5(75),
  TEXTUREFORMAT_RGBA_ASTC_6x5(76),
  TEXTUREFORMAT_RGBA_ASTC_6x6(77),
  TEXTUREFORMAT_RGBA_ASTC_8x5(78),
  TEXTUREFORMAT_RGBA_ASTC_8x6(79),
  TEXTUREFORMAT_RGBA_ASTC_8x8(80),
  TEXTUREFORMAT_RGBA_ASTC_10x5(81),
  TEXTUREFORMAT_RGBA_ASTC_10x6(82),
  TEXTUREFORMAT_RGBA_ASTC_10x8(83),
  TEXTUREFORMAT_RGBA_ASTC_10x10(84),
  TEXTUREFORMAT_RGBA_ASTC_12x10(85),
  TEXTUREFORMAT_RGBA_ASTC_12x12(86),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_4x4(87),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x4(88),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x5(89),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x5(90),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x6(91),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x5(92),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x6(93),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x8(94),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x5(95),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x6(96),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x8(97),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x10(98),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x10(99),
  TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x12(100),
  TEXTUREFORMAT_RED_RGTC1(101),
  TEXTUREFORMAT_SIGNED_RED_RGTC1(102),
  TEXTUREFORMAT_RED_GREEN_RGTC2(103),
  TEXTUREFORMAT_SIGNED_RED_GREEN_RGTC2(104),
  TEXTUREFORMAT_RGB_BPTC_SIGNED_FLOAT(105),
  TEXTUREFORMAT_RGB_BPTC_UNSIGNED_FLOAT(106),
  TEXTUREFORMAT_RGBA_BPTC_UNORM(107),
  TEXTUREFORMAT_SRGB_ALPHA_BPTC_UNORM(108);

  final int value;
  const TTextureFormat(this.value);

  static TTextureFormat fromValue(int value) => switch (value) {
        0 => TEXTUREFORMAT_R8,
        1 => TEXTUREFORMAT_R8_SNORM,
        2 => TEXTUREFORMAT_R8UI,
        3 => TEXTUREFORMAT_R8I,
        4 => TEXTUREFORMAT_STENCIL8,
        5 => TEXTUREFORMAT_R16F,
        6 => TEXTUREFORMAT_R16UI,
        7 => TEXTUREFORMAT_R16I,
        8 => TEXTUREFORMAT_RG8,
        9 => TEXTUREFORMAT_RG8_SNORM,
        10 => TEXTUREFORMAT_RG8UI,
        11 => TEXTUREFORMAT_RG8I,
        12 => TEXTUREFORMAT_RGB565,
        13 => TEXTUREFORMAT_RGB9_E5,
        14 => TEXTUREFORMAT_RGB5_A1,
        15 => TEXTUREFORMAT_RGBA4,
        16 => TEXTUREFORMAT_DEPTH16,
        17 => TEXTUREFORMAT_RGB8,
        18 => TEXTUREFORMAT_SRGB8,
        19 => TEXTUREFORMAT_RGB8_SNORM,
        20 => TEXTUREFORMAT_RGB8UI,
        21 => TEXTUREFORMAT_RGB8I,
        22 => TEXTUREFORMAT_DEPTH24,
        23 => TEXTUREFORMAT_R32F,
        24 => TEXTUREFORMAT_R32UI,
        25 => TEXTUREFORMAT_R32I,
        26 => TEXTUREFORMAT_RG16F,
        27 => TEXTUREFORMAT_RG16UI,
        28 => TEXTUREFORMAT_RG16I,
        29 => TEXTUREFORMAT_R11F_G11F_B10F,
        30 => TEXTUREFORMAT_RGBA8,
        31 => TEXTUREFORMAT_SRGB8_A8,
        32 => TEXTUREFORMAT_RGBA8_SNORM,
        33 => TEXTUREFORMAT_UNUSED,
        34 => TEXTUREFORMAT_RGB10_A2,
        35 => TEXTUREFORMAT_RGBA8UI,
        36 => TEXTUREFORMAT_RGBA8I,
        37 => TEXTUREFORMAT_DEPTH32F,
        38 => TEXTUREFORMAT_DEPTH24_STENCIL8,
        39 => TEXTUREFORMAT_DEPTH32F_STENCIL8,
        40 => TEXTUREFORMAT_RGB16F,
        41 => TEXTUREFORMAT_RGB16UI,
        42 => TEXTUREFORMAT_RGB16I,
        43 => TEXTUREFORMAT_RG32F,
        44 => TEXTUREFORMAT_RG32UI,
        45 => TEXTUREFORMAT_RG32I,
        46 => TEXTUREFORMAT_RGBA16F,
        47 => TEXTUREFORMAT_RGBA16UI,
        48 => TEXTUREFORMAT_RGBA16I,
        49 => TEXTUREFORMAT_RGB32F,
        50 => TEXTUREFORMAT_RGB32UI,
        51 => TEXTUREFORMAT_RGB32I,
        52 => TEXTUREFORMAT_RGBA32F,
        53 => TEXTUREFORMAT_RGBA32UI,
        54 => TEXTUREFORMAT_RGBA32I,
        55 => TEXTUREFORMAT_EAC_R11,
        56 => TEXTUREFORMAT_EAC_R11_SIGNED,
        57 => TEXTUREFORMAT_EAC_RG11,
        58 => TEXTUREFORMAT_EAC_RG11_SIGNED,
        59 => TEXTUREFORMAT_ETC2_RGB8,
        60 => TEXTUREFORMAT_ETC2_SRGB8,
        61 => TEXTUREFORMAT_ETC2_RGB8_A1,
        62 => TEXTUREFORMAT_ETC2_SRGB8_A1,
        63 => TEXTUREFORMAT_ETC2_EAC_RGBA8,
        64 => TEXTUREFORMAT_ETC2_EAC_SRGBA8,
        65 => TEXTUREFORMAT_DXT1_RGB,
        66 => TEXTUREFORMAT_DXT1_RGBA,
        67 => TEXTUREFORMAT_DXT3_RGBA,
        68 => TEXTUREFORMAT_DXT5_RGBA,
        69 => TEXTUREFORMAT_DXT1_SRGB,
        70 => TEXTUREFORMAT_DXT1_SRGBA,
        71 => TEXTUREFORMAT_DXT3_SRGBA,
        72 => TEXTUREFORMAT_DXT5_SRGBA,
        73 => TEXTUREFORMAT_RGBA_ASTC_4x4,
        74 => TEXTUREFORMAT_RGBA_ASTC_5x4,
        75 => TEXTUREFORMAT_RGBA_ASTC_5x5,
        76 => TEXTUREFORMAT_RGBA_ASTC_6x5,
        77 => TEXTUREFORMAT_RGBA_ASTC_6x6,
        78 => TEXTUREFORMAT_RGBA_ASTC_8x5,
        79 => TEXTUREFORMAT_RGBA_ASTC_8x6,
        80 => TEXTUREFORMAT_RGBA_ASTC_8x8,
        81 => TEXTUREFORMAT_RGBA_ASTC_10x5,
        82 => TEXTUREFORMAT_RGBA_ASTC_10x6,
        83 => TEXTUREFORMAT_RGBA_ASTC_10x8,
        84 => TEXTUREFORMAT_RGBA_ASTC_10x10,
        85 => TEXTUREFORMAT_RGBA_ASTC_12x10,
        86 => TEXTUREFORMAT_RGBA_ASTC_12x12,
        87 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_4x4,
        88 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x4,
        89 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_5x5,
        90 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x5,
        91 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_6x6,
        92 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x5,
        93 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x6,
        94 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_8x8,
        95 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x5,
        96 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x6,
        97 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x8,
        98 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_10x10,
        99 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x10,
        100 => TEXTUREFORMAT_SRGB8_ALPHA8_ASTC_12x12,
        101 => TEXTUREFORMAT_RED_RGTC1,
        102 => TEXTUREFORMAT_SIGNED_RED_RGTC1,
        103 => TEXTUREFORMAT_RED_GREEN_RGTC2,
        104 => TEXTUREFORMAT_SIGNED_RED_GREEN_RGTC2,
        105 => TEXTUREFORMAT_RGB_BPTC_SIGNED_FLOAT,
        106 => TEXTUREFORMAT_RGB_BPTC_UNSIGNED_FLOAT,
        107 => TEXTUREFORMAT_RGBA_BPTC_UNORM,
        108 => TEXTUREFORMAT_SRGB_ALPHA_BPTC_UNORM,
        _ => throw ArgumentError("Unknown value for TTextureFormat: $value"),
      };
}

/// ! Pixel Data Format
enum TPixelDataFormat {
  /// !< One Red channel, float
  PIXELDATAFORMAT_R(0),

  /// !< One Red channel, integer
  PIXELDATAFORMAT_R_INTEGER(1),

  /// !< Two Red and Green channels, float
  PIXELDATAFORMAT_RG(2),

  /// !< Two Red and Green channels, integer
  PIXELDATAFORMAT_RG_INTEGER(3),

  /// !< Three Red, Green and Blue channels, float
  PIXELDATAFORMAT_RGB(4),

  /// !< Three Red, Green and Blue channels, integer
  PIXELDATAFORMAT_RGB_INTEGER(5),

  /// !< Four Red, Green, Blue and Alpha channels, float
  PIXELDATAFORMAT_RGBA(6),

  /// !< Four Red, Green, Blue and Alpha channels, integer
  PIXELDATAFORMAT_RGBA_INTEGER(7),
  PIXELDATAFORMAT_UNUSED(8),

  /// !< Depth, 16-bit or 24-bits usually
  PIXELDATAFORMAT_DEPTH_COMPONENT(9),

  /// !< Two Depth (24-bits) + Stencil (8-bits) channels
  PIXELDATAFORMAT_DEPTH_STENCIL(10),
  PIXELDATAFORMAT_ALPHA(11);

  final int value;
  const TPixelDataFormat(this.value);

  static TPixelDataFormat fromValue(int value) => switch (value) {
        0 => PIXELDATAFORMAT_R,
        1 => PIXELDATAFORMAT_R_INTEGER,
        2 => PIXELDATAFORMAT_RG,
        3 => PIXELDATAFORMAT_RG_INTEGER,
        4 => PIXELDATAFORMAT_RGB,
        5 => PIXELDATAFORMAT_RGB_INTEGER,
        6 => PIXELDATAFORMAT_RGBA,
        7 => PIXELDATAFORMAT_RGBA_INTEGER,
        8 => PIXELDATAFORMAT_UNUSED,
        9 => PIXELDATAFORMAT_DEPTH_COMPONENT,
        10 => PIXELDATAFORMAT_DEPTH_STENCIL,
        11 => PIXELDATAFORMAT_ALPHA,
        _ => throw ArgumentError("Unknown value for TPixelDataFormat: $value"),
      };
}

enum TPixelDataType {
  /// !< unsigned byte
  PIXELDATATYPE_UBYTE(0),

  /// !< signed byte
  PIXELDATATYPE_BYTE(1),

  /// !< unsigned short (16-bit)
  PIXELDATATYPE_USHORT(2),

  /// !< signed short (16-bit)
  PIXELDATATYPE_SHORT(3),

  /// !< unsigned int (32-bit)
  PIXELDATATYPE_UINT(4),

  /// !< signed int (32-bit)
  PIXELDATATYPE_INT(5),

  /// !< half-float (16-bit float)
  PIXELDATATYPE_HALF(6),

  /// !< float (32-bits float)
  PIXELDATATYPE_FLOAT(7),

  /// !< compressed pixels, @see CompressedPixelDataType
  PIXELDATATYPE_COMPRESSED(8),

  /// !< three low precision floating-point numbers
  PIXELDATATYPE_UINT_10F_11F_11F_REV(9),

  /// !< unsigned int (16-bit), encodes 3 RGB channels
  PIXELDATATYPE_USHORT_565(10),

  /// !< unsigned normalized 10 bits RGB, 2 bits alpha
  PIXELDATATYPE_UINT_2_10_10_10_REV(11);

  final int value;
  const TPixelDataType(this.value);

  static TPixelDataType fromValue(int value) => switch (value) {
        0 => PIXELDATATYPE_UBYTE,
        1 => PIXELDATATYPE_BYTE,
        2 => PIXELDATATYPE_USHORT,
        3 => PIXELDATATYPE_SHORT,
        4 => PIXELDATATYPE_UINT,
        5 => PIXELDATATYPE_INT,
        6 => PIXELDATATYPE_HALF,
        7 => PIXELDATATYPE_FLOAT,
        8 => PIXELDATATYPE_COMPRESSED,
        9 => PIXELDATATYPE_UINT_10F_11F_11F_REV,
        10 => PIXELDATATYPE_USHORT_565,
        11 => PIXELDATATYPE_UINT_2_10_10_10_REV,
        _ => throw ArgumentError("Unknown value for TPixelDataType: $value"),
      };
}

enum TSamplerWrapMode {
  WRAP_CLAMP_TO_EDGE(0),
  WRAP_REPEAT(1),
  WRAP_MIRRORED_REPEAT(2);

  final int value;
  const TSamplerWrapMode(this.value);

  static TSamplerWrapMode fromValue(int value) => switch (value) {
        0 => WRAP_CLAMP_TO_EDGE,
        1 => WRAP_REPEAT,
        2 => WRAP_MIRRORED_REPEAT,
        _ => throw ArgumentError("Unknown value for TSamplerWrapMode: $value"),
      };
}

enum TSamplerMinFilter {
  FILTER_NEAREST(0),
  FILTER_LINEAR(1),
  FILTER_NEAREST_MIPMAP_NEAREST(2),
  FILTER_LINEAR_MIPMAP_NEAREST(3),
  FILTER_NEAREST_MIPMAP_LINEAR(4),
  FILTER_LINEAR_MIPMAP_LINEAR(5);

  final int value;
  const TSamplerMinFilter(this.value);

  static TSamplerMinFilter fromValue(int value) => switch (value) {
        0 => FILTER_NEAREST,
        1 => FILTER_LINEAR,
        2 => FILTER_NEAREST_MIPMAP_NEAREST,
        3 => FILTER_LINEAR_MIPMAP_NEAREST,
        4 => FILTER_NEAREST_MIPMAP_LINEAR,
        5 => FILTER_LINEAR_MIPMAP_LINEAR,
        _ => throw ArgumentError("Unknown value for TSamplerMinFilter: $value"),
      };
}

enum TSamplerMagFilter {
  MAG_FILTER_NEAREST(0),
  MAG_FILTER_LINEAR(1);

  final int value;
  const TSamplerMagFilter(this.value);

  static TSamplerMagFilter fromValue(int value) => switch (value) {
        0 => MAG_FILTER_NEAREST,
        1 => MAG_FILTER_LINEAR,
        _ => throw ArgumentError("Unknown value for TSamplerMagFilter: $value"),
      };
}

enum TSamplerCompareMode {
  COMPARE_MODE_NONE(0),
  COMPARE_MODE_COMPARE_TO_TEXTURE(1);

  final int value;
  const TSamplerCompareMode(this.value);

  static TSamplerCompareMode fromValue(int value) => switch (value) {
        0 => COMPARE_MODE_NONE,
        1 => COMPARE_MODE_COMPARE_TO_TEXTURE,
        _ =>
          throw ArgumentError("Unknown value for TSamplerCompareMode: $value"),
      };
}

enum TGizmoAxis {
  X(0),
  Y(1),
  Z(2);

  final int value;
  const TGizmoAxis(this.value);

  static TGizmoAxis fromValue(int value) => switch (value) {
        0 => X,
        1 => Y,
        2 => Z,
        _ => throw ArgumentError("Unknown value for TGizmoAxis: $value"),
      };
}

enum TGizmoPickResultType {
  AxisX(0),
  AxisY(1),
  AxisZ(2),
  Parent(3),
  None(4);

  final int value;
  const TGizmoPickResultType(this.value);

  static TGizmoPickResultType fromValue(int value) => switch (value) {
        0 => AxisX,
        1 => AxisY,
        2 => AxisZ,
        3 => Parent,
        4 => None,
        _ =>
          throw ArgumentError("Unknown value for TGizmoPickResultType: $value"),
      };
}

typedef GizmoPickCallback
    = ffi.Pointer<ffi.NativeFunction<GizmoPickCallbackFunction>>;
typedef GizmoPickCallbackFunction = ffi.Void Function(
    ffi.UnsignedInt resultType, ffi.Float x, ffi.Float y, ffi.Float z);
typedef DartGizmoPickCallbackFunction = void Function(
    TGizmoPickResultType resultType, double x, double y, double z);

enum Projection {
  Perspective(0),
  Orthographic(1);

  final int value;
  const Projection(this.value);

  static Projection fromValue(int value) => switch (value) {
        0 => Perspective,
        1 => Orthographic,
        _ => throw ArgumentError("Unknown value for Projection: $value"),
      };
}

typedef FilamentRenderCallback
    = ffi.Pointer<ffi.NativeFunction<FilamentRenderCallbackFunction>>;
typedef FilamentRenderCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> owner);
typedef DartFilamentRenderCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> owner);

final class ResourceBuffer extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @ffi.Int32()
  external int size;

  @ffi.Int32()
  external int id;
}

final class ResourceLoaderWrapper extends ffi.Struct {
  external LoadFilamentResource loadResource;

  external FreeFilamentResource freeResource;

  external LoadFilamentResourceFromOwner loadFromOwner;

  external FreeFilamentResourceFromOwner freeFromOwner;

  external ffi.Pointer<ffi.Void> owner;

  external LoadFilamentResourceIntoOutPointer loadToOut;
}

typedef LoadFilamentResource
    = ffi.Pointer<ffi.NativeFunction<LoadFilamentResourceFunction>>;
typedef LoadFilamentResourceFunction = ResourceBuffer Function(
    ffi.Pointer<ffi.Char> uri);
typedef FreeFilamentResource
    = ffi.Pointer<ffi.NativeFunction<FreeFilamentResourceFunction>>;
typedef FreeFilamentResourceFunction = ffi.Void Function(ResourceBuffer);
typedef DartFreeFilamentResourceFunction = void Function(ResourceBuffer);
typedef LoadFilamentResourceFromOwner
    = ffi.Pointer<ffi.NativeFunction<LoadFilamentResourceFromOwnerFunction>>;
typedef LoadFilamentResourceFromOwnerFunction = ResourceBuffer Function(
    ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>);
typedef FreeFilamentResourceFromOwner
    = ffi.Pointer<ffi.NativeFunction<FreeFilamentResourceFromOwnerFunction>>;
typedef FreeFilamentResourceFromOwnerFunction = ffi.Void Function(
    ResourceBuffer, ffi.Pointer<ffi.Void>);
typedef DartFreeFilamentResourceFromOwnerFunction = void Function(
    ResourceBuffer, ffi.Pointer<ffi.Void>);
typedef LoadFilamentResourceIntoOutPointer = ffi
    .Pointer<ffi.NativeFunction<LoadFilamentResourceIntoOutPointerFunction>>;
typedef LoadFilamentResourceIntoOutPointerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Char> uri, ffi.Pointer<ResourceBuffer> out);
typedef DartLoadFilamentResourceIntoOutPointerFunction = void Function(
    ffi.Pointer<ffi.Char> uri, ffi.Pointer<ResourceBuffer> out);

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;
